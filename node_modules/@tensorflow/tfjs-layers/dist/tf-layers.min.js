/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports,require("@tensorflow/tfjs-core")):"function"==typeof define&&define.amd?define(["exports","@tensorflow/tfjs-core"],e):e((t=t||self).tf=t.tf||{},t.tf)}(this,(function(t,e){"use strict";const n="Add",r="BatchMatMul",i="BatchToSpaceND",a="Cast",s="Concat",o="Conv2D",u="Conv2DBackpropInput",l="Cosh",c="Cumsum",h="RealDiv",p="ExpandDims",d="Floor",f="FloorDiv",g="GatherV2",m="GreaterEqual",y="Identity",v="Maximum",b="Multiply",w="Pack",k="PadV2",S="Reshape",N="Reverse",x="Rsqrt",z="Select",I="Slice",A="Sinh",C="Sigmoid",T="Sqrt",E="SpaceToBatchND",F="SplitV",D="Tile",L="Transpose",_="Unpack",R="UnsortedSegmentSum",O="ZerosLike",M="Step";function B(t){throw new Error(`'${t}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function P(t,e){if(!t)throw new Error("string"==typeof e?e:e())}function $(t,e=[],n=!1){if(null==e&&(e=[]),Array.isArray(t)||q(t)&&!n)for(let r=0;r<t.length;++r)$(t[r],e,n);else e.push(t);return e}function W(t){if(0===t.length)return 1;let e=t[0];for(let n=1;n<t.length;n++)e*=t[n];return e}function U(t,e){if(t===e)return!0;if(null==t||null==e)return!1;if(t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(t[n]!==e[n])return!1;return!0}function j(t){return t%1==0}function V(t,e){return e<=t.length?t:t+" ".repeat(e-t.length)}function K(t,e){const n=e.length;return P((t=null==t?e.map(((t,e)=>e)):[].concat(t)).every((t=>t>=-n&&t<n)),(()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${t}`)),P(t.every((t=>j(t))),(()=>`All values in axis param must be integers but got axis ${t}`)),t.map((t=>t<0?n+t:t))}function q(t){return t instanceof Float32Array||t instanceof Int32Array||t instanceof Uint8Array}function G(t){if("float32"===t||"int32"===t)return 4;if("complex64"===t)return 8;if("bool"===t)return 1;throw new Error(`Unknown dtype ${t}`)}function H(t){return"string"==typeof t||t instanceof String}function J(t){return Array.isArray(t)?J(t[0]):t instanceof Float32Array?"float32":t instanceof Int32Array||t instanceof Uint8Array?"int32":"number"==typeof t?"float32":H(t)?"string":function(t){return"boolean"==typeof t}(t)?"bool":"float32"}function Z(t){return!!(t&&t.constructor&&t.call&&t.apply)}function Y(t){const e=t.length;if(e<2)return[];const n=new Array(e-1);n[e-2]=t[e-1];for(let r=e-3;r>=0;--r)n[r]=n[r+1]*t[r+1];return n}function X(t,e,n,r=!1){const i=new Array;if(1===e.length){const a=e[0]*(r?2:1);for(let e=0;e<a;e++)i[e]=n[t+e]}else{const a=e[0],s=e.slice(1),o=s.reduce(((t,e)=>t*e))*(r?2:1);for(let e=0;e<a;e++)i[e]=X(t+e*o,s,n,r)}return i}function Q(t,e,n=!1){if(0===t.length)return e[0];const r=t.reduce(((t,e)=>t*e))*(n?2:1);if(0===r)return[];if(r!==e.length)throw new Error(`[${t}] does not match the input size ${e.length}${n?" for a complex tensor":""}.`);return X(0,t,e,n)}function tt(t,e){const n=et(t,e);for(let t=0;t<n.length;t++)n[t]=1;return n}function et(t,e){if(null==e||"float32"===e||"complex64"===e)return new Float32Array(t);if("int32"===e)return new Int32Array(t);if("bool"===e)return new Uint8Array(t);throw new Error(`Unknown data type ${e}`)}function nt(t){return t&&t.then&&"function"==typeof t.then}const rt="tfjsflags";class it{constructor(t){this.global=t,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=at,this.populateURLFlags()}setPlatform(t,e){null!=this.platform&&console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`),this.platformName=t,this.platform=e}registerFlag(t,e,n){if(this.flagRegistry[t]={evaluationFn:e,setHook:n},null!=this.urlFlags[t]){const e=this.urlFlags[t];console.warn(`Setting feature override from URL ${t}: ${e}.`),this.set(t,e)}}async getAsync(t){return t in this.flags||(this.flags[t]=await this.evaluateFlag(t)),this.flags[t]}get(t){if(t in this.flags)return this.flags[t];const e=this.evaluateFlag(t);if(nt(e))throw new Error(`Flag ${t} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[t]=e,this.flags[t]}getNumber(t){return this.get(t)}getBool(t){return this.get(t)}getFlags(){return this.flags}get features(){return this.flags}set(t,e){if(null==this.flagRegistry[t])throw new Error(`Cannot set flag ${t} as it has not been registered.`);this.flags[t]=e,null!=this.flagRegistry[t].setHook&&this.flagRegistry[t].setHook(e)}evaluateFlag(t){if(null==this.flagRegistry[t])throw new Error(`Cannot evaluate flag '${t}': no evaluation function found.`);return this.flagRegistry[t].evaluationFn()}setFlags(t){this.flags=Object.assign({},t)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(void 0===this.global||void 0===this.global.location||void 0===this.global.location.search)return;const t=this.getQueryParams(this.global.location.search);if(rt in t){t.tfjsflags.split(",").forEach((t=>{const[e,n]=t.split(":");this.urlFlags[e]=function(t,e){if("true"===(e=e.toLowerCase())||"false"===e)return"true"===e;if(""+ +e===e)return+e;throw new Error(`Could not parse value flag value ${e} for flag ${t}.`)}(e,n)}))}}}function at(t){const e={};return t.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,((t,...n)=>(function(t,e,n){t[decodeURIComponent(e)]=decodeURIComponent(n||"")}(e,n[0],n[1]),n.join("=")))),e}function st(){return ut}let ot,ut=null;function lt(){if(null==ot){let t;if("undefined"!=typeof window)t=window;else if("undefined"!=typeof global)t=global;else if("undefined"!=typeof process)t=process;else{if("undefined"==typeof self)throw new Error("Could not find a global object");t=self}ot=t}return ot}function ct(t,e){const n=function(){const t=lt();return null==t._tfGlobals&&(t._tfGlobals=new Map),t._tfGlobals}();if(n.has(t))return n.get(t);{const r=e();return n.set(t,r),n.get(t)}}const ht=ct("kernelRegistry",(()=>new Map)),pt=ct("gradRegistry",(()=>new Map));function dt(t,e){const n=function(t,e){return`${e}_${t}`}(t,e);return ht.get(n)}function ft(t){return pt.get(t)}function gt(t){const e=ht.entries(),n=[];for(;;){const{done:r,value:i}=e.next();if(r)break;const[a,s]=i,[o]=a.split("_");o===t&&n.push(s)}return n}function mt(t){const{kernelName:e}=t;pt.has(e)&&st().getBool("DEBUG")&&console.warn(`Overriding the gradient for '${e}'`),pt.set(e,t)}function yt(t,e){if("string"===e)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(t)&&(t=$(t)),st().getBool("DEBUG")&&function(t,e){for(let n=0;n<t.length;n++){const r=t[n];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${e} being uploaded contains ${r}.`)}}(t,e),function(t,e){return t instanceof Float32Array&&"float32"===e||t instanceof Int32Array&&"int32"===e||t instanceof Uint8Array&&"bool"===e}(t,e))return t;if(null==e||"float32"===e||"complex64"===e)return new Float32Array(t);if("int32"===e)return new Int32Array(t);if("bool"===e){const e=new Uint8Array(t.length);for(let n=0;n<e.length;++n)0!==Math.round(t[n])&&(e[n]=1);return e}throw new Error(`Unknown data type ${e}`)}function vt(){return st().platform.now()}function bt(t,e="utf-8"){return e=e||"utf-8",st().platform.decode(t,e)}class wt{constructor(t,e){this.backendTimer=t,this.logger=e,null==e&&(this.logger=new St)}profileKernel(t,e,n){let r;const i=()=>{r=n()};let a;const s=vt();if(this.backendTimer.timerAvailable())a=this.backendTimer.time(i);else{i();for(const t of r)t.dataSync();a=Promise.resolve({kernelMs:vt()-s})}if(st().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let e=0;e<r.length;e++){const n=r[e];n.data().then((e=>{kt(e,n.dtype,t)}))}return{kernelName:t,outputs:r,inputs:e,timeMs:a.then((t=>t.kernelMs)),extraInfo:a.then((t=>null!=t.getExtraProfileInfo?t.getExtraProfileInfo():""))}}logKernelProfile(t){const{kernelName:e,outputs:n,timeMs:r,inputs:i,extraInfo:a}=t;n.forEach((t=>{Promise.all([t.data(),r,a]).then((n=>{this.logger.logKernelProfile(e,t,n[0],n[1],i,n[2])}))}))}}function kt(t,e,n){if("float32"!==e)return!1;for(let e=0;e<t.length;e++){const r=t[e];if(isNaN(r)||!isFinite(r))return console.warn(`Found ${r} in the result of '${n}'`),!0}return!1}class St{logKernelProfile(t,e,n,r,i,a){const s="number"==typeof r?V(`${r}ms`,9):r.error,o=V(t,25),u=e.rank,l=e.size,c=V(e.shape.toString(),14);let h="";for(const t in i){const n=i[t];if(null!=n){const r=n.shape||e.shape,i=r.length;h+=`${t}: ${i}D ${i>0?r:""} `}}console.log(`%c${o}\t%c${s}\t%c${u}D ${c}\t%c${l}\t%c${h}\t%c${a}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}function Nt(t,e,n,r){const i=Y(e),a=function(t,e,n,r){const i=W(e),a=r[r.length-1],s=new Array(a).fill(0),o=e.length,u="complex64"===n?At(t):t;if(o>1)for(let t=0;t<i/a;t++){const e=t*a;for(let t=0;t<a;t++)s[t]=Math.max(s[t],xt(u[e+t],0,n).length)}return s}(t,e,n,i),s=e.length,o=It(t,e,n,i,a),u=["Tensor"];return r&&(u.push(`  dtype: ${n}`),u.push(`  rank: ${s}`),u.push(`  shape: [${e}]`),u.push("  values:")),u.push(o.map((t=>"    "+t)).join("\n")),u.join("\n")}function xt(t,e,n){let r;return r=Array.isArray(t)?`${parseFloat(t[0].toFixed(7))} + ${parseFloat(t[1].toFixed(7))}j`:H(t)?`'${t}'`:"bool"===n?zt(t):parseFloat(t.toFixed(7)).toString(),V(r,e)}function zt(t){return 0===t?"false":"true"}function It(t,e,n,r,i,a=!0){const s="complex64"===n?2:1,o=e[0],u=e.length;if(0===u){if("complex64"===n){return[xt(At(t)[0],0,n)]}return"bool"===n?[zt(t[0])]:[t[0].toString()]}if(1===u){if(o>20){const e=3*s;let r=Array.from(t.slice(0,e)),a=Array.from(t.slice((o-3)*s,o*s));return"complex64"===n&&(r=At(r),a=At(a)),["["+r.map(((t,e)=>xt(t,i[e],n))).join(", ")+", ..., "+a.map(((t,e)=>xt(t,i[o-3+e],n))).join(", ")+"]"]}return["["+("complex64"===n?At(t):Array.from(t)).map(((t,e)=>xt(t,i[e],n))).join(", ")+"]"]}const l=e.slice(1),c=r.slice(1),h=r[0]*s,p=[];if(o>20){for(let e=0;e<3;e++){const r=e*h,a=r+h;p.push(...It(t.slice(r,a),l,n,c,i,!1))}p.push("...");for(let e=o-3;e<o;e++){const r=e*h,a=r+h;p.push(...It(t.slice(r,a),l,n,c,i,e===o-1))}}else for(let e=0;e<o;e++){const r=e*h,a=r+h;p.push(...It(t.slice(r,a),l,n,c,i,e===o-1))}const d=2===u?",":"";p[0]="["+p[0]+d;for(let t=1;t<p.length-1;t++)p[t]=" "+p[t]+d;let f=",\n";for(let t=2;t<u;t++)f+="\n";return p[p.length-1]=" "+p[p.length-1]+"]"+(a?"":f),p}function At(t){const e=[];for(let n=0;n<t.length;n+=2)e.push([t[n],t[n+1]]);return e}let Ct=null,Tt=null;class Et{constructor(t,e,n,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=t.slice(),this.dtype=e||"float32",this.size=W(t),this.strides=Y(t),this.dataId=n,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const t=await this.data();return Tt.buffer(this.shape,this.dtype,t)}bufferSync(){return Tt.buffer(this.shape,this.dtype,this.dataSync())}async array(){const t=await this.data();return Q(this.shape,t,"complex64"===this.dtype)}arraySync(){return Q(this.shape,this.dataSync(),"complex64"===this.dtype)}async data(){this.throwIfDisposed();const t=Ct().read(this.dataId);if("string"===this.dtype){const e=await t;try{return e.map((t=>bt(t)))}catch(t){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return t}dataSync(){this.throwIfDisposed();const t=Ct().readSync(this.dataId);if("string"===this.dtype)try{return t.map((t=>bt(t)))}catch(t){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return t}async bytes(){this.throwIfDisposed();const t=await Ct().read(this.dataId);return"string"===this.dtype?t:new Uint8Array(t.buffer)}dispose(){this.isDisposed||(Ct().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(t=!1){return Tt.print(this,t)}clone(){return this.throwIfDisposed(),Tt.clone(this)}toString(t=!1){return Nt(this.dataSync(),this.shape,this.dtype,t)}cast(t){return this.throwIfDisposed(),Tt.cast(this,t)}variable(t=!0,e,n){return this.throwIfDisposed(),Ct().makeVariable(this,t,e,n)}}Object.defineProperty(Et,Symbol.hasInstance,{value:t=>!!t&&null!=t.data&&null!=t.dataSync&&null!=t.throwIfDisposed}),ct("Tensor",(()=>Et));class Ft extends Et{constructor(t,e,n,r){super(t.shape,t.dtype,t.dataId,r),this.trainable=e,this.name=n}assign(t){if(t.dtype!==this.dtype)throw new Error(`dtype of the new value (${t.dtype}) and previous value (${this.dtype}) must match`);if(!U(t.shape,this.shape))throw new Error(`shape of the new value (${t.shape}) and previous value (${this.shape}) must match`);Ct().disposeTensor(this),this.dataId=t.dataId,Ct().incRef(this,null)}dispose(){Ct().disposeVariable(this),this.isDisposedInternal=!0}}var Dt,Lt,_t,Rt,Ot;Object.defineProperty(Ft,Symbol.hasInstance,{value:t=>t instanceof Et&&null!=t.assign&&t.assign instanceof Function}),function(t){t.R0="R0",t.R1="R1",t.R2="R2",t.R3="R3",t.R4="R4",t.R5="R5",t.R6="R6"}(Dt||(Dt={})),function(t){t.float32="float32",t.int32="int32",t.bool="int32",t.complex64="complex64"}(Lt||(Lt={})),function(t){t.float32="float32",t.int32="int32",t.bool="bool",t.complex64="complex64"}(_t||(_t={})),function(t){t.float32="float32",t.int32="float32",t.bool="float32",t.complex64="complex64"}(Rt||(Rt={})),function(t){t.float32="complex64",t.int32="complex64",t.bool="complex64",t.complex64="complex64"}(Ot||(Ot={}));const Mt={float32:Rt,int32:Lt,bool:_t,complex64:Ot};function Bt(t,e){if(t.dtype===e.dtype)return[t,e];const n=function(t,e){if("string"===t||"string"===e){if("string"===t&&"string"===e)return"string";throw new Error(`Can not upcast ${t} with ${e}`)}return Mt[t][e]}(t.dtype,e.dtype);return[t.cast(n),e.cast(n)]}function Pt(t){const e=[];return $t(t,e,new Set),e}function $t(t,e,n){if(null==t)return;if(t instanceof Et)return void e.push(t);if(r=t,!Array.isArray(r)&&"object"!=typeof r)return;var r;const i=t;for(const t in i){const r=i[t];n.has(r)||(n.add(r),$t(r,e,n))}}function Wt(t){return null!=t.kernelName}class Ut{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map((t=>t.name))))}}}dispose(){for(const t in this.registeredVariables)this.registeredVariables[t].dispose()}}class jt{constructor(t){this.ENV=t,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new Ut}async ready(){if(null!=this.pendingBackendInit)return this.pendingBackendInit.then((()=>{}));if(null!=this.backendInstance)return;const t=this.getSortedBackends();for(let e=0;e<t.length;e++){const n=t[e];if(await this.initializeBackend(n).success)return void await this.setBackend(n)}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(null!=this.pendingBackendInit)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(null==this.backendInstance){const{name:t,asyncInit:e}=this.initializeBackendsAndReturnBest();if(e)throw new Error(`The highest priority backend '${t}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(t)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(t){if(!(t in this.registry)){if(!(t in this.registryFactory))return null;{const{asyncInit:e}=this.initializeBackend(t);if(e)return null}}return this.registry[t]}findBackendFactory(t){return t in this.registryFactory?this.registryFactory[t].factory:null}registerBackend(t,e,n=1){return t in this.registryFactory?(console.warn(`${t} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[t]={factory:e,priority:n},!0)}async setBackend(t){if(null==this.registryFactory[t])throw new Error(`Backend name '${t}' not found in registry`);if(this.backendName=t,null==this.registry[t]){this.backendInstance=null;const{success:e,asyncInit:n}=this.initializeBackend(t);if(!(n?await e:e))return!1}return this.backendInstance=this.registry[t],this.setupRegisteredKernels(),this.profiler=new wt(this.backendInstance),!0}setupRegisteredKernels(){gt(this.backendName).forEach((t=>{null!=t.setupFunc&&t.setupFunc(this.backendInstance)}))}disposeRegisteredKernels(t){gt(t).forEach((e=>{null!=e.disposeFunc&&e.disposeFunc(this.registry[t])}))}initializeBackend(t){const e=this.registryFactory[t];if(null==e)throw new Error(`Cannot initialize backend ${t}, no registration found.`);try{const n=e.factory();if(!n||n instanceof class{refCount(t){return B("refCount")}incRef(t){return B("incRef")}timerAvailable(){return!0}time(t){return B("time")}read(t){return B("read")}readSync(t){return B("readSync")}numDataIds(){return B("numDataIds")}disposeData(t,e){return B("disposeData")}write(t,e,n){return B("write")}move(t,e,n,r,i){return B("move")}memory(){return B("memory")}floatPrecision(){return B("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}dispose(){return B("dispose")}}||"function"!=typeof n.then)return this.registry[t]=n,{success:!0,asyncInit:!1};{const e=++this.pendingBackendInitId,r=n.then((n=>!(e<this.pendingBackendInitId)&&(this.registry[t]=n,this.pendingBackendInit=null,!0))).catch((n=>(e<this.pendingBackendInitId||(this.pendingBackendInit=null,console.warn(`Initialization of backend ${t} failed`),console.warn(n.stack||n.message)),!1)));return this.pendingBackendInit=r,{success:r,asyncInit:!0}}}catch(e){return console.warn(`Initialization of backend ${t} failed`),console.warn(e.stack||e.message),{success:!1,asyncInit:!1}}}removeBackend(t){if(!(t in this.registryFactory))throw new Error(`${t} backend not found in registry`);this.backendName===t&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,t in this.registry&&(this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t]),delete this.registryFactory[t],this.backendName===t&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort(((t,e)=>this.registryFactory[e].priority-this.registryFactory[t].priority))}initializeBackendsAndReturnBest(){const t=this.getSortedBackends();for(let e=0;e<t.length;e++){const n=t[e],{success:r,asyncInit:i}=this.initializeBackend(n);if(i||r)return{name:n,asyncInit:i}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(t,e){const n=this.state.tensorInfo.get(e),r=n.backend,i=this.readSync(e),a=r.refCount(e);r.disposeData(e,!0),n.backend=t,t.move(e,i,n.shape,n.dtype,a),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(t,e){let n,r=null;if(null==e){if("function"!=typeof t)throw new Error("Please provide a function to tidy()");e=t}else{if("string"!=typeof t&&!(t instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!=typeof e)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=t}return this.scopedRun((()=>this.startScope(r)),(()=>this.endScope(n)),(()=>(n=e(),n instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),n)))}scopedRun(t,e,n){t();try{const t=n();return e(),t}catch(t){throw e(),t}}nextTensorId(){return jt.nextTensorId++}nextVariableId(){return jt.nextVariableId++}clone(t){const e=Vt.runKernel(y,{x:t}),n={x:t};return this.addTapeNode(this.state.activeScope.name,n,[e],(t=>({x:()=>{const e={x:t},n={dtype:"float32"};return Vt.runKernel(a,e,n)}})),[],{}),e}runKernel(t,e,n){null==this.backendName&&this.backend;if(!(null!=dt(t,this.backendName)))throw new Error(`Kernel '${t}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:t,inputs:e,attrs:n})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(t,e,n){const r=this.backend.numDataIds();let i=0;n.forEach((t=>{i+="complex64"===t.dtype?3:1}));const a=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],s=r-e-i-a;if(s>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${s} data ids) after running '${t}'`)}runKernelFunc(t){let e,n=[];const r=this.isTapeOn(),i=this.state.numBytes,a=this.state.numTensors;let s,o;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0),null==this.backendName&&this.backend;const u=Wt(t)?t.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(Wt(t)){const{kernelName:e,inputs:i,attrs:a}=t;null==this.backendName&&this.backend;const u=dt(e,this.backendName);P(null!=u,(()=>`Cannot find registered kernel '${e}' for backend '${this.backendName}'`)),s=()=>{const t=this.backend.numDataIds();o=u.kernelFunc({inputs:i,attrs:a,backend:this.backend});const s=Array.isArray(o)?o:[o];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(e,t,s);const l=s.map((t=>{if(null!=t.rank)return t;const{dataId:e,shape:n,dtype:r}=t;return this.makeTensorFromDataId(e,n,r)}));if(r){const t=this.getTensorsForGradient(e,i,l);n=this.saveTensorsForBackwardMode(t)}return l}}else{const{forwardFunc:e}=t,i=t=>{r&&(n=t.map((t=>this.keep(this.clone(t)))))};s=()=>{const t=this.backend.numDataIds();o=this.tidy((()=>e(this.backend,i)));const n=Array.isArray(o)?o:[o];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(u,t,n),n}}const{inputs:l,attrs:c}=t,h=Wt(t)?null:t.backwardsFunc;let p;return this.scopedRun((()=>this.state.kernelDepth++),(()=>this.state.kernelDepth--),(()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(p=this.profiler.profileKernel(u,l,(()=>s())),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(p),e=p.outputs):e=s()})),r&&this.addTapeNode(u,l,e,h,n,c),this.state.profiling&&this.state.activeProfile.kernels.push({name:u,bytesAdded:this.state.numBytes-i,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-a,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(l).map((t=>null!=l[t]?l[t].shape:null)),outputShapes:e.map((t=>t.shape)),kernelTimeMs:p.timeMs,extraInfo:p.extraInfo}),Array.isArray(o)?e:e[0]}saveTensorsForBackwardMode(t){return t.map((t=>this.keep(this.clone(t))))}getTensorsForGradient(t,e,n){const r=ft(t);if(null!=r){const t=r.inputsToSave||[],i=r.outputsToSave||[];let a;r.saveAllInputs?(P(Array.isArray(e),(()=>"saveAllInputs is true, expected inputs to be an array.")),a=Object.keys(e).map((t=>e[t]))):a=t.map((t=>e[t]));const s=n.filter(((t,e)=>i[e]));return a.concat(s)}return[]}makeTensor(t,e,n,r){if(null==t)throw new Error("Values passed to engine.makeTensor() are null");n=n||"float32",r=r||this.backend;let i=t;"string"===n&&H(t[0])&&(i=t.map((t=>function(t,e="utf-8"){return e=e||"utf-8",st().platform.encode(t,e)}(t))));const a=r.write(i,e,n),s=new Et(e,n,a,this.nextTensorId());if(this.trackTensor(s,r),"string"===n){const t=this.state.tensorInfo.get(a),e=function(t){if(null==t)return 0;let e=0;return t.forEach((t=>e+=t.length)),e}(i);this.state.numBytes+=e-t.bytes,t.bytes=e}return s}makeTensorFromDataId(t,e,n,r){const i=new Et(e,n=n||"float32",t,this.nextTensorId());return this.trackTensor(i,r),i}makeVariable(t,e=!0,n,r){n=n||this.nextVariableId().toString(),null!=r&&r!==t.dtype&&(t=t.cast(r));const i=new Ft(t,e,n,this.nextTensorId());if(null!=this.state.registeredVariables[i.name])throw new Error(`Variable with name ${i.name} was already registered`);return this.state.registeredVariables[i.name]=i,this.incRef(i,this.backend),i}trackTensor(t,e){this.state.numTensors++,"string"===t.dtype&&this.state.numStringTensors++;let n=0;"complex64"!==t.dtype&&"string"!==t.dtype&&(n=t.size*G(t.dtype)),this.state.numBytes+=n,this.state.tensorInfo.has(t.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(t.dataId,{backend:e||this.backend,dtype:t.dtype,shape:t.shape,bytes:n})),t instanceof Ft||this.track(t)}incRef(t,e){this.trackTensor(t,e),this.backend.incRef(t.dataId)}removeDataId(t,e){this.state.tensorInfo.has(t)&&this.state.tensorInfo.get(t).backend===e&&(this.state.tensorInfo.delete(t),this.state.numDataBuffers--)}disposeTensor(t){if(!this.state.tensorInfo.has(t.dataId))return;const e=this.state.tensorInfo.get(t.dataId);if(this.state.numTensors--,"string"===t.dtype&&(this.state.numStringTensors--,this.state.numBytes-=e.bytes),"complex64"!==t.dtype&&"string"!==t.dtype){const e=t.size*G(t.dtype);this.state.numBytes-=e}e.backend.disposeData(t.dataId)&&this.removeDataId(t.dataId,e.backend)}disposeVariables(){for(const t in this.state.registeredVariables){const e=this.state.registeredVariables[t];this.disposeVariable(e)}}disposeVariable(t){this.disposeTensor(t),null!=this.state.registeredVariables[t.name]&&delete this.state.registeredVariables[t.name]}memory(){const t=this.backend.memory();return t.numTensors=this.state.numTensors,t.numDataBuffers=this.state.numDataBuffers,t.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(t.unreliable=!0,null==t.reasons&&(t.reasons=[]),t.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),t}async profile(t){this.state.profiling=!0;const e=this.state.numBytes,n=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await t(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map((t=>t.totalBytesSnapshot))),this.state.activeProfile.newBytes=this.state.numBytes-e,this.state.activeProfile.newTensors=this.state.numTensors-n;for(const t of this.state.activeProfile.kernels)t.kernelTimeMs=await t.kernelTimeMs,t.extraInfo=await t.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(t,e,n,r,i,a){const s={id:this.state.nextTapeNodeId++,kernelName:t,inputs:e,outputs:n,saved:i},o=ft(t);null!=o&&(r=o.gradFunc),null!=r&&(s.gradient=t=>(t=t.map(((t,e)=>{if(null==t){const t=n[e],r=et(t.size,t.dtype);return this.makeTensor(r,t.shape,t.dtype)}return t})),r(t.length>1?t:t[0],i,a))),this.state.activeTape.push(s)}keep(t){return t.kept=!0,t}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(t){const e={track:[],name:"unnamed scope",id:this.state.nextScopeId++};t&&(e.name=t),this.state.scopeStack.push(e),this.state.activeScope=e}endScope(t){const e=Pt(t),n=new Set(e.map((t=>t.id)));for(let t=0;t<this.state.activeScope.track.length;t++){const e=this.state.activeScope.track[t];e.kept||n.has(e.id)||e.dispose()}const r=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],e.forEach((t=>{t.kept||t.scopeId!==r.id||this.track(t)}))}gradients(t,e,n,r=!1){if(P(e.length>0,(()=>"gradients() received an empty list of xs.")),null!=n&&"float32"!==n.dtype)throw new Error(`dy must have 'float32' dtype, but has '${n.dtype}'`);const i=this.scopedRun((()=>this.startTape()),(()=>this.endTape()),(()=>this.tidy("forward",t)));P(i instanceof Et,(()=>"The result y returned by f() must be a tensor."));const a=function(t,e,n){const r={},i={};for(let t=0;t<e.length;t++)r[e[t].id]=!0;for(let n=0;n<t.length;n++){const a=t[n],s=a.inputs;for(const t in s){const n=s[t];let o=!1;for(let t=0;t<e.length;t++)if(r[n.id]){a.outputs.forEach((t=>r[t.id]=!0)),o=!0,i[a.id]=!0;break}if(o)break}}const a={};a[n.id]=!0;const s={};for(let e=t.length-1;e>=0;e--){const n=t[e],r=n.inputs;for(let t=0;t<n.outputs.length;t++)if(a[n.outputs[t].id]){for(const t in r)a[r[t].id]=!0,s[n.id]=!0;break}}const o=[];for(let e=0;e<t.length;e++){const n=t[e];if(i[n.id]&&s[n.id]){const t={};for(const e in n.inputs){const i=n.inputs[e];r[i.id]&&(t[e]=i)}const e=Object.assign({},n);e.inputs=t,e.outputs=n.outputs,o.push(e)}}return o}(this.state.activeTape,e,i);if(!r&&0===a.length&&e.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",(()=>{const t={};t[i.id]=null==n?function(t){const e=tt(W(t),"float32");return Vt.makeTensor(e,t,"float32")}(i.shape):n,function(t,e,n,r){for(let i=e.length-1;i>=0;i--){const a=e[i],s=[];if(a.outputs.forEach((e=>{const n=t[e.id];null!=n?s.push(n):s.push(null)})),null==a.gradient)throw new Error(`Cannot compute gradient: gradient function not found for ${a.kernelName}.`);const o=a.gradient(s);for(const e in a.inputs){if(!(e in o))throw new Error(`Cannot backprop through input ${e}. Available gradients found: ${Object.keys(o)}.`);const i=n((()=>o[e]()));if("float32"!==i.dtype)throw new Error(`Error in gradient for op ${a.kernelName}. The gradient of input ${e} must have 'float32' dtype, but has '${i.dtype}'`);const s=a.inputs[e];if(!U(i.shape,s.shape))throw new Error(`Error in gradient for op ${a.kernelName}. The gradient of input '${e}' has shape '${i.shape}', which does not match the shape of the input '${s.shape}'`);if(null==t[s.id])t[s.id]=i;else{const e=t[s.id];t[s.id]=r(e,i),e.dispose()}}}}(t,a,(t=>this.tidy(t)),Kt);const r=e.map((e=>t[e.id]));return 0===this.state.gradientDepth&&(this.state.activeTape.forEach((t=>{for(const e of t.saved)e.dispose()})),this.state.activeTape=null),{value:i,grads:r}}))}customGrad(t){return P(Z(t),(()=>"The f passed in customGrad(f) must be a function.")),(...e)=>{let n;P(e.every((t=>t instanceof Et)),(()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors"));const r={};e.forEach(((t,e)=>{r[e]=t}));return this.runKernelFunc({forwardFunc:(r,i)=>(n=t(...e,i),P(n.value instanceof Et,(()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor")),P(Z(n.gradFunc),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function.")),n.value),backwardsFunc:(t,r)=>{const i=n.gradFunc(t,r),a=Array.isArray(i)?i:[i];P(a.length===e.length,(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...).")),P(a.every((t=>t instanceof Et)),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors."));const s={};return a.forEach(((t,e)=>{s[e]=()=>t})),s},inputs:r})}}readSync(t){return this.state.tensorInfo.get(t).backend.readSync(t)}read(t){return this.state.tensorInfo.get(t).backend.read(t)}async time(t){const e=vt(),n=await this.backend.time(t);return n.wallMs=vt()-e,n}track(t){return null!=this.state.activeScope&&(t.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(t)),t}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new Ut;for(const t in this.registry)this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}jt.nextTensorId=0,jt.nextVariableId=0;const Vt=function(){const t=lt();if(null==t._tfengine){const e=new it(t);t._tfengine=new jt(e)}var e;return e=t._tfengine.ENV,ut=e,Ct=()=>t._tfengine,t._tfengine}();function Kt(t,e){const r={a:t,b:e};return Vt.runKernel(n,r)}function qt(t,e){let n=t;if(q(t))return"string"===e?[]:[t.length];if(!Array.isArray(t))return[];const r=[];for(;Array.isArray(n)||q(n)&&"string"!==e;)r.push(n.length),n=n[0];return Array.isArray(t)&&st().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&Gt(t,r,[]),r}function Gt(t,e,n){if(n=n||[],!Array.isArray(t)&&!q(t))return void P(0===e.length,(()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${e[0]} elements`));P(e.length>0,(()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${t.length} elements`)),P(t.length===e[0],(()=>`Element arr[${n.join("][")}] should have ${e[0]} elements, but has ${t.length} elements`));const r=e.slice(1);for(let e=0;e<t.length;++e)Gt(t[e],r,n.concat(e))}function Ht(t,e,n,r){if("string_or_numeric"!==t){if(null==t)throw new Error("Expected dtype cannot be null.");if("numeric"!==t&&t!==e||"numeric"===t&&"string"===e)throw new Error(`Argument '${n}' passed to '${r}' must be ${t} tensor, but got ${e} tensor`)}}function Jt(t,e,n,r="numeric"){if(t instanceof Et)return Ht(r,t.dtype,e,n),t;let i=J(t);if("string"!==i&&["bool","int32","float32"].indexOf(r)>=0&&(i=r),Ht(r,i,e,n),null==t||!q(t)&&!Array.isArray(t)&&"number"!=typeof t&&"boolean"!=typeof t&&"string"!=typeof t){const r=null==t?"null":t.constructor.name;throw new Error(`Argument '${e}' passed to '${n}' must be a Tensor or TensorLike, but got '${r}'`)}const a=qt(t,i);q(t)||Array.isArray(t)||(t=[t]);const s="string"!==i?yt(t,i):$(t,[],!0);return Vt.makeTensor(s,a,i)}function Zt(t,e,n,r="numeric"){if(!Array.isArray(t))throw new Error(`Argument ${e} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return t.map(((t,i)=>Jt(t,`${e}[${i}]`,n,r)))}function Yt(t){const e=Object.keys(t);if(1!==e.length)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${e.length} keys.`);let n=e[0];const r=t[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n+="__op";const i=(...t)=>{Vt.startScope(n);try{const e=r(...t);return nt(e)&&console.error("Cannot return a Promise inside of tidy."),Vt.endScope(e),e}catch(t){throw Vt.endScope(null),t}};return Object.defineProperty(i,"name",{value:n,configurable:!0}),i}const Xt=Yt({cast_:function(t,e){const n=Jt(t,"x","cast");if(!function(t){return"bool"===t||"complex64"===t||"float32"===t||"int32"===t||"string"===t}(e))throw new Error(`Failed to cast to unknown dtype ${e}`);if("string"===e&&"string"!==n.dtype||"string"!==e&&"string"===n.dtype)throw new Error("Only strings can be casted to strings");const r={x:n},i={dtype:e};return Vt.runKernel(a,r,i)}});const Qt=Yt({mul_:function(t,e){let n=Jt(t,"a","mul"),r=Jt(e,"b","mul");[n,r]=Bt(n,r);const i={a:n,b:r};return Vt.runKernel(b,i)}});const te=Yt({step_:function(t,e=0){const n={x:Jt(t,"x","step")},r={alpha:e};return Vt.runKernel(M,n,r)}}),ee={kernelName:"Abs",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Qt(t,te(Xt(n,"float32"),-1))}}};const ne=Yt({floorDiv_:function(t,e){let n=Jt(t,"a","floorDiv"),r=Jt(e,"b","floorDiv");[n,r]=Bt(n,r);const i={a:n,b:r};return Vt.runKernel(f,i)}});const re=Yt({div_:function(t,e){let n=Jt(t,"a","div"),r=Jt(e,"b","div");if([n,r]=Bt(n,r),"int32"===n.dtype&&"int32"===r.dtype)return ne(n,r);const i={a:n,b:r};return Vt.runKernel(h,i,{})}});const ie=Yt({neg_:function(t){const e={x:Jt(t,"x","neg")};return Vt.runKernel("Neg",e)}});function ae(t,e,n,r){if(null==r&&(r=J(t)),"complex64"===r)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(!q(t)&&!Array.isArray(t)&&"number"!=typeof t&&"boolean"!=typeof t&&"string"!=typeof t)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=e){!function(t){t.forEach((e=>{P(Number.isInteger(e)&&e>=0,(()=>`Tensor must have a shape comprised of positive integers but got shape [${t}].`))}))}(e);const t=W(e),r=W(n);P(t===r,(()=>`Based on the provided shape, [${e}], the tensor should have ${t} values but has ${r}`));for(let t=0;t<n.length;++t){const r=n[t],i=t!==n.length-1||r!==W(e.slice(t));P(n[t]===e[t]||!i,(()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${e}). `))}}return q(t)||Array.isArray(t)||(t=[t]),e=e||n,t="string"!==r?yt(t,r):$(t,[],!0),Vt.makeTensor(t,e,r)}function se(t,e){if((q(t)&&"string"!==e||Array.isArray(t))&&"complex64"!==e)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===e&&q(t)&&!(t instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return ae(t,[],[],e)}const oe=Yt({sqrt_:function(t){const e={x:Jt(t,"x","sqrt")};return Vt.runKernel(T,e)}});const ue=Yt({square_:function(t){const e=Jt(t,"x","square");return Vt.runKernel("Square",{x:e},{})}});const le=Yt({sub_:function(t,e){let n=Jt(t,"a","sub"),r=Jt(e,"b","sub");[n,r]=Bt(n,r);const i={a:n,b:r};return Vt.runKernel("Sub",i)}}),ce={kernelName:"Acos",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>{const e=ue(Xt(n,"float32")),r=oe(le(se(1),e));return ie(re(t,r))}}}},he={kernelName:"Acosh",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>{const e=oe(le(ue(Xt(n,"float32")),1));return re(t,e)}}}};function pe(t,e){const n=[];for(let r=0;r<e.length;r++){const i=t[t.length-r-1],a=e.length-r-1,s=e[a];(null==i||1===i&&s>1)&&n.unshift(a)}return n}function de(t,e){const n=[],r=Math.max(t.length,e.length);for(let i=0;i<r;i++){let r=t[t.length-i-1];null==r&&(r=1);let a=e[e.length-i-1];if(null==a&&(a=1),1===r)n.unshift(a);else if(1===a)n.unshift(r);else{if(r!==a){throw Error(`Operands could not be broadcast together with shapes ${t} and ${e}.`)}n.unshift(r)}}return n}const fe=Yt({reshape_:function(t,e){const n={x:Jt(t,"x","reshape","string_or_numeric")},r={shape:e};return Vt.runKernel(S,n,r)}});const ge=Yt({sum_:function(t,e=null,n=!1){let r=Jt(t,"x","sum");"bool"===r.dtype&&(r=Xt(r,"int32"));const i={x:r},a={axis:e,keepDims:n};return Vt.runKernel("Sum",i,a)}}),me={kernelName:n,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,i=de(n.shape,r.shape);return{a:()=>{let e=t;const r=pe(n.shape,i);return r.length>0&&(e=ge(e,r)),fe(e,n.shape)},b:()=>{let e=t;const n=pe(r.shape,i);return n.length>0&&(e=ge(e,n)),fe(e,r.shape)}}}},ye={kernelName:"AddN",saveAllInputs:!0,gradFunc:(t,e)=>{const n={};return e.forEach(((e,r)=>{n[r]=()=>t.clone()})),n}};const ve=Yt({zerosLike_:function(t){const e={x:Jt(t,"x","zerosLike")};return Vt.runKernel(O,e)}}),be={kernelName:"ArgMax",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>ve(n)}}},we={kernelName:"ArgMin",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>ve(n)}}},ke={kernelName:"Asin",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>re(t,oe(le(se(1),ue(Xt(n,"float32")))))}}};const Se=Yt({add_:function(t,e){let r=Jt(t,"a","add"),i=Jt(e,"b","add");[r,i]=Bt(r,i);const a={a:r,b:i};return Vt.runKernel(n,a)}}),Ne={kernelName:"Asinh",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>{const e=oe(Se(se(1),ue(Xt(n,"float32"))));return re(t,e)}}}},xe={kernelName:"Atan2",inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,i=de(n.shape,r.shape);return{a:()=>{const e=Se(ue(n),ue(r));let a=Qt(t,re(r,e));const s=pe(n.shape,i);return s.length>0&&(a=ge(a,s)),fe(a,n.shape)},b:()=>{const e=Se(ue(n),ue(r));let a=ie(Qt(t,re(n,e)));const s=pe(r.shape,i);return s.length>0&&(a=ge(a,s)),fe(a,r.shape)}}}},ze={kernelName:"Atan",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>re(t,Se(ue(Xt(n,"float32")),1))}}},Ie={kernelName:"Atanh",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>re(t,le(se(1),ue(Xt(n,"float32"))))}}};const Ae=Yt({avgPool3dGrad_:function(t,e,n,r,i,a){const s=Jt(t,"dy","avgPool3dGrad"),o=Jt(e,"input","avgPool3dGrad");let u=s,l=o,c=!1;4===o.rank&&(c=!0,u=fe(s,[1,s.shape[0],s.shape[1],s.shape[2],s.shape[3]]),l=fe(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),P(5===u.rank,(()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${u.rank}.`)),P(5===l.rank,(()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${l.rank}.`)),null!=a&&P(j(i),(()=>`Error in avgPool3dGrad: pad must be an integer when using, dimRoundingMode ${a} but got pad ${i}.`));const h={dy:u,input:l},p={filterSize:n,strides:r,pad:i,dimRoundingMode:a},d=Vt.runKernel("AvgPool3DGrad",h,p);return c?fe(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}}),Ce={kernelName:"AvgPool3D",inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{filterSize:i,strides:a,pad:s,dimRoundingMode:o}=n;return{x:()=>Ae(t,r,i,a,s,o)}}};const Te=Yt({avgPoolGrad_:function(t,e,n,r,i){const a=Jt(t,"dy","avgPoolGrad"),s=Jt(e,"input","avgPoolGrad");P(s.rank===a.rank,(()=>`Rank of input (${s.rank}) does not match rank of dy (${a.rank})`));let o=s,u=a,l=!1;3===s.rank&&(l=!0,o=fe(s,[1,s.shape[0],s.shape[1],s.shape[2]]),u=fe(a,[1,a.shape[0],a.shape[1],a.shape[2]])),P(4===u.rank,(()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${u.rank}.`)),P(4===o.rank,(()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${o.rank}.`));const c={dy:u,input:o},h={filterSize:n,strides:r,pad:i},p=Vt.runKernel("AvgPoolGrad",c,h);return l?fe(p,[p.shape[1],p.shape[2],p.shape[3]]):p}}),Ee={kernelName:"AvgPool",inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{filterSize:i,strides:a,pad:s}=n;return{x:()=>Te(t,r,i,a,s)}}};const Fe=Yt({matMul_:function(t,e,n=!1,i=!1){let a=Jt(t,"a","matMul"),s=Jt(e,"b","matMul");[a,s]=Bt(a,s);const o={a:a,b:s},u={transposeA:n,transposeB:i};return Vt.runKernel(r,o,u)}}),De={kernelName:r,inputsToSave:["a","b"],gradFunc:(t,e,n)=>{const[r,i]=e,{transposeA:a,transposeB:s}=n;return a||s?!a&&s?{a:()=>Fe(t,i,!1,!1),b:()=>Fe(t,r,!0,!1)}:a&&!s?{a:()=>Fe(i,t,!1,!0),b:()=>Fe(r,t,!1,!1)}:{a:()=>Fe(i,t,!0,!0),b:()=>Fe(t,r,!0,!0)}:{a:()=>Fe(t,i,!1,!0),b:()=>Fe(r,t,!0,!1)}}};const Le=Yt({spaceToBatchND_:function(t,e,n){const r=Jt(t,"x","spaceToBatchND");P(r.rank>=1+e.length,(()=>`input rank ${r.rank} should be > than [blockShape] ${e.length}`)),P(n.length===e.length,(()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${e.length}`)),P(r.shape.reduce(((t,r,i)=>i>0&&i<=e.length?t&&(r+n[i-1][0]+n[i-1][1])%e[i-1]==0:t),!0),(()=>`input spatial dimensions ${r.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${e.toString()}`));const i={x:r},a={blockShape:e,paddings:n};return Vt.runKernel(E,i,a)}}),_e={kernelName:i,gradFunc:(t,e,n)=>{const{blockShape:r,crops:i}=n;return{x:()=>Le(t,r,i)}}},Re={kernelName:"BroadcastTo",gradFunc:(t,e,n)=>{const r=n,i=r.inputShape,a=r.shape,s=Array.from(a);for(let t=i.length-1;t>=0;t--)if(i[t]===a[t])s[t]=1;else if(1!==i[t])throw new Error(`broadcastTo(): [${i}] cannot be broadcast to [${a}].`);const o=[];for(let t=0;t<s.length;t++)s[t]>1&&o.push(t);return{x:()=>ge(t,o,!0)}}},Oe={kernelName:a,gradFunc:t=>({x:()=>t.clone()})},Me={kernelName:"Ceil",gradFunc:t=>({x:()=>ve(t)})};const Be=Yt({greaterEqual_:function(t,e){let n=Jt(t,"a","greaterEqual","string_or_numeric"),r=Jt(e,"b","greaterEqual","string_or_numeric");[n,r]=Bt(n,r),de(n.shape,r.shape);const i={a:n,b:r};return Vt.runKernel(m,i)}});const Pe=Yt({lessEqual_:function(t,e){let n=Jt(t,"a","lessEqual","string_or_numeric"),r=Jt(e,"b","lessEqual","string_or_numeric");[n,r]=Bt(n,r),de(n.shape,r.shape);const i={a:n,b:r};return Vt.runKernel("LessEqual",i)}});const $e=Yt({logicalAnd_:function(t,e){const n=Jt(t,"a","logicalAnd","bool"),r=Jt(e,"b","logicalAnd","bool");de(n.shape,r.shape);const i={a:n,b:r};return Vt.runKernel("LogicalAnd",i)}});const We=Yt({clone_:function(t){const e={x:Jt(t,"x","clone","string_or_numeric")};return Vt.runKernel(y,e)}});const Ue=Yt({broadcastTo_:function(t,e){let n=Jt(t,"broadcastTo","x");const r=n.shape;if(e.some((t=>!(t>0)||t%1!=0)))throw new Error(`broadcastTo(): Invalid broadcast shape [${e}].`);if(e.length<n.rank)throw new Error(`broadcastTo(): shape.length=${e.length} < input.rank=${n.rank}.`);if(e.length>n.rank){const t=n.shape.slice();for(;t.length<e.length;)t.unshift(1);n=fe(n,t)}const i=n.shape,a=Array.from(e);for(let t=e.length-1;t>=0;t--)if(i[t]===e[t])a[t]=1;else if(1!==n.shape[t])throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${e}].`);if(0===a.map(((t,e)=>t>1?e:-1)).filter((t=>t>=0)).length)return We(n);const s={x:n},o={reps:a};return Vt.runKernel(D,s,o)}});const je=Yt({where_:function(t,e,n){const r=Jt(e,"a","where"),i=Jt(n,"b","where"),a=Jt(t,"condition","where","bool"),s=de(de(a.shape,r.shape),i.shape),o={condition:Ue(a,s),t:Ue(r,s),e:Ue(i,s)};return Vt.runKernel(z,o)}}),Ve={kernelName:"ClipByValue",inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{clipValueMin:i,clipValueMax:a}=n;return{x:()=>je($e(Be(r,i),Pe(r,a)),t,ve(t))}}},Ke={kernelName:"ComplexAbs",inputsToSave:["x"],gradFunc:ee.gradFunc};const qe=Yt({split_:function(t,e,n=0){const r={x:Jt(t,"x","split")},i={numOrSizeSplits:e,axis:n};return Vt.runKernel(F,r,i)}}),Ge={kernelName:s,saveAllInputs:!0,gradFunc:(t,e,n)=>{const r=e.map((t=>t.shape)),{axis:i}=n,a=K(i,e[0].shape)[0],s=r.map((t=>t[a]));return qe(t,s,a).map((t=>()=>t))}};const He=Yt({conv2DBackpropFilter_:function(t,e,n,r,i,a="NHWC",s){let o=t;3===t.rank&&(o=fe(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let u=e;3===u.rank&&(u=fe(e,[1,e.shape[0],e.shape[1],e.shape[2]])),P(4===o.rank,(()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${o.shape}.`)),P(4===u.rank,(()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${u.shape}.`)),P(4===n.length,(()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`));const l="NHWC"===a?o.shape[3]:o.shape[1],c="NHWC"===a?u.shape[3]:u.shape[1];P(l===n[2],(()=>`Error in conv2dDerFilter: depth of input ${l}) must match input depth in filter (${n[2]}.`)),P(c===n[3],(()=>`Error in conv2dDerFilter: depth of dy (${c}) must match output depth for filter (${n[3]}).`)),null!=s&&P(j(i),(()=>`Error in conv2dDerFilter: pad must be an integer when using, dimRoundingMode ${s} but got pad ${i}.`));const h={x:o,dy:u},p={strides:r,pad:i,dataFormat:a,dimRoundingMode:s,filterShape:n};return Vt.runKernel("Conv2DBackpropFilter",h,p)}});const Je=Yt({conv2DBackpropInput_:function(t,e,n,r,i,a="NHWC",s){P(t.length===e.rank,(()=>`Length of inShape (${t.length}) and rank of dy (${e.rank}) must match`));let o=t,l=e,c=!1;3===e.rank&&(c=!0,l=fe(e,[1,e.shape[0],e.shape[1],e.shape[2]]),o=[1,t[0],t[1],t[2]]),P(4===o.length,(()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${o.length}.`)),P(4===l.rank,(()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`)),P(4===n.rank,(()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${n.rank}`));const h="NHWC"===a?o[3]:o[1],p="NHWC"===a?l.shape[3]:l.shape[1];P(h===n.shape[2],(()=>`Error in conv2dDerInput: depth of input (${h}) must match input depth for filter ${n.shape[2]}.`)),P(p===n.shape[3],(()=>`Error in conv2dDerInput: depth of output (${p}) must match output depth for filter ${n.shape[3]}.`)),null!=s&&P(j(i),(()=>`Error in conv2dDerInput: pad must be an integer when using, dimRoundingMode ${s} but got pad ${i}.`));const d={dy:l,filter:n},f={strides:r,pad:i,dataFormat:a,dimRoundingMode:s,inputShape:o},g=Vt.runKernel(u,d,f);return c?fe(g,[g.shape[1],g.shape[2],g.shape[3]]):g}});function Ze(t){const[e,n,r]=function(t){return"number"==typeof t?[t,t,t]:2===t.length?[t[0],t[1],1]:t}(t);return 1===e&&1===n&&1===r}function Ye(t,e){return Ze(t)||Ze(e)}const Xe={kernelName:o,inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const[r,i]=e,{dilations:a,strides:s,pad:o,dataFormat:u}=n;return P(Ze(a),(()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${a}'`)),{x:()=>Je(r.shape,t,i,s,o,u),filter:()=>He(r,t,i.shape,s,o,u)}}};const Qe=Yt({conv2d_:function(t,e,n,r,i="NHWC",a=[1,1],s){const u=Jt(t,"x","conv2d"),l=Jt(e,"filter","conv2d");let c=u,h=!1;3===u.rank&&(h=!0,c=fe(u,[1,u.shape[0],u.shape[1],u.shape[2]])),P(4===c.rank,(()=>`Error in conv2d: input must be rank 4, but got rank ${c.rank}.`)),P(4===l.rank,(()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`)),null!=s&&P(j(r),(()=>`Error in conv2d: pad must be an integer when using, dimRoundingMode ${s} but got pad ${r}.`));const p="NHWC"===i?c.shape[3]:c.shape[1];P(p===l.shape[2],(()=>`Error in conv2d: depth of input (${p}) must match input depth for filter ${l.shape[2]}.`)),P(Ye(n,a),(()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`));const d={x:c,filter:l},f={strides:n,pad:r,dataFormat:i,dilations:a,dimRoundingMode:s},g=Vt.runKernel(o,d,f);return h?fe(g,[g.shape[1],g.shape[2],g.shape[3]]):g}}),tn={kernelName:u,inputsToSave:["dy","filter"],gradFunc:(t,e,n)=>{const[r,i]=e,{strides:a,pad:s,dataFormat:o,dimRoundingMode:u}=n;return{dy:()=>Qe(t,i,a,s,o,1,u),filter:()=>He(t,r,i.shape,a,s,o,u)}}};const en=Yt({conv3DBackpropFilter_:function(t,e,n,r,i){let a=t;4===t.rank&&(a=fe(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]));let s=e;4===s.rank&&(s=fe(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]])),P(5===a.rank,(()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${a.shape}.`)),P(5===s.rank,(()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${s.shape}.`)),P(5===n.length,(()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${n}.`)),P(a.shape[4]===n[3],(()=>`Error in conv3dDerFilter: depth of input ${a.shape[4]}) must match input depth in filter (${n[3]}.`)),P(s.shape[4]===n[4],(()=>`Error in conv3dDerFilter: depth of dy (${s.shape[4]}) must match output depth for filter (${n[4]}).`));const o={x:a,dy:s},u={strides:r,pad:i,filterShape:n};return Vt.runKernel("Conv3DBackpropFilterV2",o,u)}});const nn=Yt({conv3DBackpropInput_:function(t,e,n,r,i){P(t.length===e.rank,(()=>`Length of inShape (${t.length}) and rank of dy (${e.rank}) must match`));let a=t,s=e,o=!1;4===e.rank&&(o=!0,s=fe(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]),a=[1,t[0],t[1],t[2],t[3]]);const u=a[4],l=s.shape[4];P(5===a.length,(()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${a.length}.`)),P(5===s.rank,(()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${s.rank}`)),P(5===n.rank,(()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${n.rank}`)),P(u===n.shape[3],(()=>`Error in conv3dDerInput: depth of input (${u}) must match input depth for filter ${n.shape[3]}.`)),P(l===n.shape[4],(()=>`Error in conv3dDerInput: depth of output (${l}) must match output depth for filter ${n.shape[4]}.`));const c={dy:s,filter:n},h={pad:i,strides:r,inputShape:a},p=Vt.runKernel("Conv3DBackpropInputV2",c,h);return o?fe(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}}),rn={kernelName:"Conv3D",inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const{dilations:r,strides:i,pad:a}=n;P(Ze(r),(()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`));const[s,o]=e;return{x:()=>nn(s.shape,t,o,i,a),filter:()=>en(s,t,o.shape,i,a)}}};const an=Yt({sin_:function(t){const e={x:Jt(t,"x","sin")};return Vt.runKernel("Sin",e)}}),sn={kernelName:"Cos",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Qt(ie(an(Xt(n,"float32"))),t)}}};const on=Yt({sinh_:function(t){const e={x:Jt(t,"x","sinh")};return Vt.runKernel(A,e)}}),un={kernelName:l,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Qt(on(Xt(n,"float32")),t)}}};function ln(t,e){return function(t,e,n){const r=t.length+e.length,i=[];let a=0,s=0;for(let o=0;o<r;o++)-1===n.indexOf(o)?i.push(t[a++]):i.push(e[s++]);return i}(t,e.map((t=>1)),e)}function cn(t){return t.map(((t,e)=>[e,t])).sort(((t,e)=>t[1]-e[1])).map((t=>t[0]))}const hn=Yt({cumsum_:function(t,e=0,n=!1,r=!1){const i={x:Jt(t,"x","cumsum")},a={axis:e,exclusive:n,reverse:r};return Vt.runKernel(c,i,a)}});const pn=Yt({transpose_:function(t,e){const n=Jt(t,"x","transpose");if(null==e&&(e=n.shape.map(((t,e)=>e)).reverse()),P(n.rank===e.length,(()=>`Error in transpose: rank of input ${n.rank} must match length of perm ${e}.`)),e.forEach((t=>{P(t>=0&&t<n.rank,(()=>"All entries in 'perm' must be between 0 and "+(n.rank-1)+` but got ${e}`))})),n.rank<=1)return n.clone();const r={x:n},i={perm:e};return Vt.runKernel(L,r,i)}}),dn={kernelName:c,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{axis:i,exclusive:a,reverse:s}=n;return{x:()=>{const e=function(t,e){if(function(t,e){for(let n=0;n<t.length;++n)if(t[t.length-n-1]!==e-1-n)return!1;return!0}(t,e))return null;const n=[];for(let r=0;r<e;++r)-1===t.indexOf(r)&&n.push(r);return t.forEach((t=>n.push(t))),n}([i],r.rank);let n=hn(t,i,a,!s);return null!=e&&(n=pn(n,e)),n}}}};const fn=Yt({depthwiseConv2dNativeBackpropFilter_:function(t,e,n,r,i,a=[1,1],s){let o=t;3===t.rank&&(o=fe(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let u=e;3===u.rank&&(u=fe(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const l={x:o,dy:u},c={strides:r,pad:i,dimRoundingMode:s,dilations:a,filterShape:n};return Vt.runKernel("DepthwiseConv2dNativeBackpropFilter",l,c)}});const gn=Yt({depthwiseConv2dNativeBackpropInput_:function(t,e,n,r,i,a=[1,1],s){let o=e,u=!1;3===e.rank&&(u=!0,o=fe(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const l={dy:o,filter:n},c={strides:r,pad:i,dimRoundingMode:s,dilations:a,inputShape:t},h=Vt.runKernel("DepthwiseConv2dNativeBackpropInput",l,c);return u?fe(h,[h.shape[1],h.shape[2],h.shape[3]]):h}}),mn={kernelName:"DepthwiseConv2dNative",inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const{dilations:r,strides:i,pad:a,dimRoundingMode:s}=n,o=null==r?[1,1]:r;P(Ze(o),(()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`));const[u,l]=e;return P(4===u.rank,(()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${u.rank}.`)),P(4===l.rank,(()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${l.rank}.`)),P(u.shape[3]===l.shape[2],(()=>`Error in gradient of depthwiseConv2d: number of input channels (${u.shape[3]}) must match the inChannels dimension in filter ${l.shape[2]}.`)),P(Ye(i,o),(()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${i} and dilations '${o}'.`)),null!=s&&P(j(a),(()=>`Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode ${s} but got pad ${a}.`)),{x:()=>gn(u.shape,t,l,i,a,r,s),filter:()=>fn(u,t,l.shape,i,a,r,s)}}},yn={kernelName:"Dilation2D",inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const[r,i]=e,a={x:r,filter:i,dy:t},s={x:r,filter:i,dy:t};return{x:()=>Vt.runKernel("Dilation2DBackpropInput",a,n),filter:()=>Vt.runKernel("Dilation2DBackpropFilter",s,n)}}},vn={kernelName:"Elu",outputsToSave:[!0],gradFunc:(t,e)=>{const[n]=e,r={dy:t,y:n};return{x:()=>Vt.runKernel("EluGrad",r)}}};const bn=Yt({exp_:function(t){const e={x:Jt(t,"x","exp")};return Vt.runKernel("Exp",e)}}),wn={kernelName:"Erf",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e,r=Qt(bn(ie(ue(n))),2/Math.sqrt(Math.PI));return{x:()=>Qt(t,r)}}},kn={kernelName:"Exp",outputsToSave:[!0],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Qt(t,n)}}},Sn={kernelName:p,inputsToSave:["input"],gradFunc:(t,e)=>{const[n]=e;return{input:()=>fe(t,n.shape)}}},Nn={kernelName:"Expm1",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Qt(t,bn(n))}}},xn={kernelName:d,gradFunc:t=>({x:()=>ve(t)})},zn={kernelName:f,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,i=de(n.shape,r.shape);return{a:()=>{const e=re(t,Xt(r,"float32")),a=pe(n.shape,i);return a.length>0?fe(ge(e,a),n.shape):e},b:()=>{let e=Qt(t,Xt(n,"float32"));const a=pe(r.shape,i);a.length>0&&(e=fe(ge(e,a),r.shape));const s=ue(r);return ie(re(e,Xt(s,"float32")))}}}};const In=Yt({rsqrt_:function(t){const e={x:Jt(t,"x","rsqrt")};return Vt.runKernel(x,e)}});const An=Yt({tile_:function(t,e){const n=Jt(t,"x","tile","string_or_numeric");P(n.rank===e.length,(()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${e}.`));const r={x:n},i={reps:e};return Vt.runKernel(D,r,i)}}),Cn={kernelName:"FusedBatchNorm",inputsToSave:["x","mean","variance","scale"],gradFunc:(t,e,n)=>{const{varianceEpsilon:r}=n,[i,a,s,o]=e,u=null==o?se(1):o,l=pe(a.shape,i.shape),c=[];if(1===a.rank){for(let t=0;t<i.shape.length-1;++t)c.push(i.shape[t]);c.push(1)}const h=le(i,a),p=Qt(t,u),d=In(Se(s,se(r))),f=Qt(Qt(Qt(d,d),d),se(-.5));return{x:()=>1===a.rank?fe(Qt(Qt(t,An(fe(d,[1,1,1,a.shape[0]]),c)),u),i.shape):fe(Qt(Qt(t,d),u),i.shape),mean:()=>{let t=Qt(Qt(d,se(-1)),p);return 1===a.rank&&(t=ge(t,l)),fe(t,a.shape)},variance:()=>{let t=Qt(Qt(f,h),p);return 1===a.rank&&(t=ge(t,l)),fe(t,a.shape)},scale:()=>{const e=Qt(h,d);let n=Qt(t,e);return 1===a.rank&&(n=ge(n,l)),fe(n,a.shape)},offset:()=>{let e=t;return 1===a.rank&&(e=ge(e,l)),fe(e,a.shape)}}}};const Tn=Yt({unsortedSegmentSum_:function(t,e,n){const r=Jt(t,"x","unsortedSegmentSum"),i=Jt(e,"segmentIds","unsortedSegmentSum","int32");P(j(n),(()=>"numSegments must be of dtype int"));const a={x:r,segmentIds:i},s={numSegments:n};return Vt.runKernel(R,a,s)}}),En={kernelName:g,inputsToSave:["x","indices"],gradFunc:(t,e,n)=>{const[r,i]=e,{axis:a}=n,s=K(a,r.shape)[0];return{x:()=>{const e=r.shape,n=i.size,o=e.slice(0,s),u=o.length,l=e.slice(a,e.length).slice(1),c=l.length,h=Fn(0,u),p=Fn(u+1,u+1+c),d=Dn([o,[n],l]),f=fe(t,d),g=fe(i,[n]),m=Dn([[u],h,p]),y=pn(f,m);let v=Tn(y,g,r.shape[s]);const b=cn(m);return v=pn(v,b),v},indices:()=>i}}};function Fn(t,e){const n=[];for(let r=t;r<e;++r)n.push(r);return n}function Dn(t){const e=[];for(let n=0;n<t.length;++n)for(let r=0;r<t[n].length;++r)e.push(t[n][r]);return e}const Ln={kernelName:m,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e;return{a:()=>ve(n),b:()=>ve(r)}}},_n={kernelName:y,gradFunc:t=>({x:()=>Xt(t,"float32")})},Rn={kernelName:"IsFinite",gradFunc:t=>({x:()=>ve(t)})},On={kernelName:"IsInf",gradFunc:t=>({x:()=>ve(t)})},Mn={kernelName:"IsNan",gradFunc:t=>({x:()=>ve(t)})};const Bn=Yt({greater_:function(t,e){let n=Jt(t,"a","greater","string_or_numeric"),r=Jt(e,"b","greater","string_or_numeric");[n,r]=Bt(n,r),de(n.shape,r.shape);const i={a:n,b:r};return Vt.runKernel("Greater",i)}}),Pn={kernelName:"LeakyRelu",inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{alpha:i}=n,a=Bn(r,0);return{x:()=>je(a,t,Qt(t,i))}}},$n={kernelName:"Log1p",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>re(t,Se(n,1))}}},Wn={kernelName:"Log",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>re(t,Xt(n,"float32"))}}},Un={kernelName:"LogSoftmax",inputsToSave:[],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[r]=e,{axis:i}=n;return{logits:()=>{const e=bn(r);return le(t,Qt(ge(t,i,!0),e))}}}};const jn=Yt({localResponseNormalizationBackprop_:function(t,e,n,r=5,i=1,a=1,s=.5){const o={x:t,y:e,dy:n},u={depthRadius:r,bias:i,alpha:a,beta:s};return Vt.runKernel("LRNGrad",o,u)}}),Vn={kernelName:"LRN",inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[r,i]=e,{depthRadius:a,bias:s,alpha:o,beta:u}=n;return{x:()=>jn(r,i,t,a,s,o,u)}}};const Kn=Yt({equal_:function(t,e){let n=Jt(t,"a","equal","string_or_numeric"),r=Jt(e,"b","equal","string_or_numeric");[n,r]=Bt(n,r),de(n.shape,r.shape);const i={a:n,b:r};return Vt.runKernel("Equal",i)}});function qn(t,e,n,r){return e.rank<n.rank&&(e=fe(e,ln(e.shape,r))),t.rank<n.rank&&(t=fe(t,ln(t.shape,r))),{x:()=>Qt(t,Xt(Kn(n,e),t.dtype))}}const Gn={kernelName:"Max",inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const r=n,{reductionIndices:i}=r,a=e[0],s=qn(t,e[1],a,K(i,a.shape));return{x:()=>s.x()}}};const Hn=Yt({less_:function(t,e){let n=Jt(t,"a","less","string_or_numeric"),r=Jt(e,"b","less","string_or_numeric");[n,r]=Bt(n,r),de(n.shape,r.shape);const i={a:n,b:r};return Vt.runKernel("Less",i)}}),Jn={kernelName:v,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e;return{a:()=>Qt(t,Xt(Be(n,r),"float32")),b:()=>Qt(t,Xt(Hn(n,r),"float32"))}}};const Zn=Yt({maxPool3dGrad_:function(t,e,n,r,i,a,s){const o=Jt(t,"dy","maxPool3dGrad"),u=Jt(e,"input","maxPool3dGrad"),l=Jt(n,"output","maxPool3dGrad");let c=o,h=u,p=l,d=!1;4===u.rank&&(d=!0,c=fe(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),h=fe(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]]),p=fe(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]])),P(5===c.rank,(()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${c.rank}.`)),P(5===h.rank,(()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${h.rank}.`)),P(5===p.rank,(()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${p.rank}.`)),null!=s&&P(j(a),(()=>`Error in maxPool3dGrad: pad must be an integer when using, dimRoundingMode ${s} but got pad ${a}.`));const f={dy:c,input:h,output:p},g={filterSize:r,strides:i,pad:a,dimRoundingMode:s},m=Vt.runKernel("MaxPool3DGrad",f,g);return d?fe(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}}),Yn={kernelName:"MaxPool3D",inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[r,i]=e,{filterSize:a,strides:s,pad:o,dimRoundingMode:u}=n;return{x:()=>Zn(t,r,i,a,s,o,u)}}};const Xn=Yt({maxPoolGrad_:function(t,e,n,r,i,a,s){const o=Jt(t,"dy","maxPoolGrad"),u=Jt(e,"input","maxPoolGrad"),l=Jt(n,"output","maxPoolGrad");P(u.rank===o.rank,(()=>`Rank of input (${u.rank}) does not match rank of dy (${o.rank})`)),P(4===o.rank,(()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${o.rank}.`)),P(4===u.rank,(()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${u.rank}.`)),null!=s&&P(j(a),(()=>`Error in maxPoolGrad: pad must be an integer when using, dimRoundingMode ${s} but got pad ${a}.`));const c={dy:o,input:u,output:l},h={filterSize:r,strides:i,pad:a,dimRoundingMode:s};return Vt.runKernel("MaxPoolGrad",c,h)}}),Qn={kernelName:"MaxPool",inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[r,i]=e,{filterSize:a,strides:s,pad:o}=n;return{x:()=>Xn(t,r,i,a,s,o)}}};const tr=Yt({complex_:function(t,e){const n=Jt(t,"real","complex"),r=Jt(e,"imag","complex");!function(t,e,n=""){P(U(t,e),(()=>n+` Shapes ${t} and ${e} must match`))}(n.shape,r.shape,`real and imag shapes, ${n.shape} and ${r.shape}, must match in call to tf.complex().`);const i={real:n,imag:r};return Vt.runKernel("Complex",i)}});function er(t,e="float32"){if("complex64"===e){const e=er(t,"float32"),n=er(t,"float32");return tr(e,n)}const n=et(W(t),e);return Vt.makeTensor(n,t,e)}function nr(t,e="float32"){if("complex64"===e){const e=nr(t,"float32"),n=er(t,"float32");return tr(e,n)}const n=tt(W(t),e);return Vt.makeTensor(n,t,e)}const rr={kernelName:"Mean",inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{axis:i}=n,a=K(i,r.shape),s=W(function(t,e){const n=[],r=t.length;for(let i=0;i<r;i++)-1===e.indexOf(i)&&n.push(t[i]);return[n,e.map((e=>t[e]))]}(r.shape,a)[1]);return{x:()=>{const e=r.shape.slice();a.forEach((t=>{e[t]=1}));const n=fe(t,e);return re(Qt(n,nr(r.shape,"float32")),s)}}}},ir={kernelName:"Min",inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const r=n,{axis:i}=r,[a,s]=e,o=qn(t,s,a,K(i,a.shape));return{x:()=>o.x()}}},ar={kernelName:"Minimum",inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e;return{a:()=>Qt(t,Xt(Pe(n,r),"float32")),b:()=>Qt(t,Xt(Bn(n,r),"float32"))}}};const sr=Yt({slice_:function(t,e,n){const r=Jt(t,"x","slice","string_or_numeric");if(0===r.rank)throw new Error("Slicing scalar is not possible");const i={x:r},a={begin:e,size:n};return Vt.runKernel(I,i,a)}}),or={kernelName:"MirrorPad",inputsToSave:["x"],gradFunc:(t,e,n)=>{const r=e[0],{paddings:i}=n,a=i.map((t=>t[0]));return{x:()=>sr(t,a,r.shape)}}};const ur=Yt({floor_:function(t){const e={x:Jt(t,"x","floor")};return Vt.runKernel(d,e)}}),lr={kernelName:"Mod",inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,i=de(n.shape,r.shape);return{a:()=>{const e=pe(n.shape,i);return e.length>0?fe(ge(t,e),n.shape):t},b:()=>{const e=Qt(t,ie(ur(re(n,r)))),a=pe(r.shape,i);return a.length>0?fe(ge(e,a),r.shape):e}}}},cr={kernelName:b,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,i=de(n.shape,r.shape);return{a:()=>{const e=Qt(t,Xt(r,"float32")),a=pe(n.shape,i);return a.length>0?fe(ge(e,a),n.shape):e},b:()=>{const e=Qt(t,Xt(n,"float32")),a=pe(r.shape,i);return a.length>0?fe(ge(e,a),r.shape):e}}}},hr={kernelName:"Neg",gradFunc:t=>({x:()=>ie(t)})},pr={kernelName:"OneHot",inputsToSave:["indices"],gradFunc:(t,e)=>{const n=e[0];return{indices:()=>er(n.shape,"float32")}}},dr={kernelName:"OnesLike",gradFunc:t=>({x:()=>ve(t)})};const fr=Yt({unstack_:function(t,e=0){const n=Jt(t,"x","unstack","string_or_numeric");P(e>=-n.shape.length&&e<n.shape.length,(()=>`Axis = ${e} is not in [-${n.shape.length}, ${n.shape.length})`));const r={value:n},i={axis:e};return Vt.runKernel(_,r,i)}}),gr={kernelName:w,saveAllInputs:!0,gradFunc:(t,e,n)=>{const{axis:r}=n;return fr(t,r).map((t=>()=>t))}},mr={kernelName:k,inputsToSave:["x"],gradFunc:(t,e,n)=>{const r=e[0],{paddings:i}=n,a=i.map((t=>t[0]));return{x:()=>sr(t,a,r.shape)}}};const yr=Yt({log_:function(t){const e={x:Jt(t,"x","log")};return Vt.runKernel("Log",e)}});const vr=Yt({pow_:function(t,e){let n=Jt(t,"base","pow"),r=Jt(e,"exp","pow");[n,r]=Bt(n,r);const i={a:n,b:r};return Vt.runKernel("Pow",i)}}),br={kernelName:"Pow",inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(t,e)=>{const[n,r,i]=e,a=n,s=r,o=de(a.shape,s.shape);return{a:()=>{const e=Xt(s,"float32");let n=Qt(t,Qt(e,vr(a,le(e,se(1)))));const r=pe(a.shape,o);return r.length>0&&(n=ge(n,r)),fe(n,a.shape)},b:()=>{const e=Bn(a,0),n=je(e,yr(a),ve(a));let r=Qt(t,Qt(i,n));const u=pe(s.shape,o);return u.length>0&&(r=ge(r,u)),fe(r,s.shape)}}}},wr={kernelName:"Prelu",inputsToSave:["x","alpha"],gradFunc:(t,e)=>{const[n,r]=e,i=Bn(n,0);return{x:()=>je(i,t,Qt(t,r)),alpha:()=>{let e=je(i,ve(t),Qt(t,n));const a=pe(r.shape,t.shape);return a.length>0&&(e=ge(e,a)),fe(e,r.shape)}}}},kr={kernelName:h,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,i=de(n.shape,r.shape);return{a:()=>{const e=re(t,Xt(r,"float32")),a=pe(n.shape,i);return a.length>0?fe(ge(e,a),n.shape):e},b:()=>{let e=Qt(t,Xt(n,"float32"));const a=pe(r.shape,i);a.length>0&&(e=fe(ge(e,a),r.shape));const s=ue(r);return ie(re(e,Xt(s,"float32")))}}}},Sr={kernelName:"Reciprocal",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>re(t,ie(ue(n)))}}},Nr={kernelName:"Relu6",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e,r=Qt(Pe(n,6),te(n));return{x:()=>Qt(t,Xt(r,"float32"))}}},xr={kernelName:"Relu",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Qt(t,Xt(te(n),"float32"))}}},zr={kernelName:S,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>fe(t,n.shape)}}},Ir={kernelName:"ResizeBilinear",inputsToSave:["images"],gradFunc:(t,e,n)=>{const[r]=e,i={dy:t,images:r};return{images:()=>Vt.runKernel("ResizeBilinearGrad",i,n)}}},Ar={kernelName:"ResizeNearestNeighbor",inputsToSave:["images"],gradFunc:(t,e,n)=>{const[r]=e,i={dy:t,images:r};return{images:()=>Vt.runKernel("ResizeNearestNeighborGrad",i,n)}}};const Cr=Yt({reverse_:function(t,e){const n={x:Jt(t,"x","reverse")},r={dims:e};return Vt.runKernel(N,n,r)}}),Tr={kernelName:N,gradFunc:(t,e,n)=>{const{dims:r}=n,i=K(r,t.shape);return{x:()=>Cr(t,i)}}},Er={kernelName:"Round",gradFunc:t=>({x:()=>ve(t)})},Fr={kernelName:x,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>ie(re(t,Qt(vr(n,1.5),2)))}}};const Dr=Yt({logicalNot_:function(t){const e={x:Jt(t,"x","logicalNot","bool")};return Vt.runKernel("LogicalNot",e)}}),Lr={kernelName:z,inputsToSave:["condition"],gradFunc:(t,e)=>{const[n]=e;return{condition:()=>Xt(ve(n),"float32"),t:()=>Qt(t,Xt(n,t.dtype)),e:()=>Qt(t,Xt(Dr(n),t.dtype))}}},_r={kernelName:"Selu",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>{const e=Bn(n,se(0)),r=se(1.7580993408473768),i=se(1.0507009873554805),a=Qt(t,i),s=Qt(Qt(t,r),bn(Xt(n,"float32")));return je(e,a,s)}}}},Rr={kernelName:C,outputsToSave:[!0],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Qt(t,Qt(n,le(se(1),n)))}}},Or={kernelName:"Sign",gradFunc:t=>({x:()=>ve(t)})};const Mr=Yt({cos_:function(t){const e={x:Jt(t,"x","cos")};return Vt.runKernel("Cos",e)}}),Br={kernelName:"Sin",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Qt(Mr(Xt(n,"float32")),t)}}};const Pr=Yt({cosh_:function(t){const e={x:Jt(t,"x","cosh")};return Vt.runKernel(l,e)}}),$r={kernelName:A,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Qt(Pr(Xt(n,"float32")),t)}}};const Wr=Yt({pad_:function(t,e,n=0){const r=Jt(t,"x","pad");if(0===r.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const i={paddings:e,constantValue:n},a={x:r};return Vt.runKernel(k,a,i)}});const Ur={kernelName:I,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{begin:i,size:a}=n,s=r.shape,[o,u]=function(t,e,n){let r;const i=t.shape.length;let a;return r="number"==typeof e?[e,...new Array(i-1).fill(0)]:e.length<i?e.concat(new Array(i-e.length).fill(0)):e.slice(),r.forEach((t=>{P(-1!==t,(()=>"slice() does not support negative begin indexing."))})),a=null==n?new Array(i).fill(-1):"number"==typeof n?[n,...new Array(i-1).fill(-1)]:n.length<i?n.concat(new Array(i-n.length).fill(-1)):n,a=a.map(((e,n)=>e>=0?e:(P(-1===e,(()=>`Negative size values should be exactly -1 but got ${e} for the slice() size at index ${n}.`)),t.shape[n]-r[n]))),[r,a]}(r,i,a),l=[];for(let e=0;e<t.rank;e++)l.push([o[e],s[e]-o[e]-u[e]]);return{x:()=>Wr(t,l)}}},jr={kernelName:"Softmax",outputsToSave:[!0],gradFunc:(t,e,n)=>{const[r]=e,{dim:i}=n,a=Qt(t,r);return{logits:()=>le(a,Qt(ge(a,[i],true),r))}}};const Vr=Yt({sigmoid_:function(t){const e={x:Jt(t,"x","sigmoid")};return Vt.runKernel(C,e)}}),Kr={kernelName:"Softplus",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Qt(t,Vr(n))}}};const qr=Yt({batchToSpaceND_:function(t,e,n){const r=Jt(t,"x","batchToSpaceND"),a=e.reduce(((t,e)=>t*e));P(r.rank>=1+e.length,(()=>`input rank is ${r.rank} but should be > than blockShape.length ${e.length}`)),P(n.length===e.length,(()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${e.length}`)),P(r.shape[0]%a==0,(()=>`input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${e.join(" * ")} === ${a}`));const s={x:r},o={blockShape:e,crops:n};return Vt.runKernel(i,s,o)}}),Gr={kernelName:E,gradFunc:(t,e,n)=>{const{blockShape:r,paddings:i}=n;return{x:()=>qr(t,r,i)}}};const Hr=Yt({concat_:function(t,e=0){P(t.length>=1,(()=>"Pass at least one tensor to concat"));const n=Zt(t,"tensors","concat","string_or_numeric");if("complex64"===n[0].dtype&&n.forEach((t=>{if("complex64"!==t.dtype)throw new Error(`Cannot concatenate complex64 tensors with a tensor\n          with dtype ${t.dtype}. `)})),1===n.length)return We(n[0]);const r=n,i={axis:e};return Vt.runKernel(s,r,i)}}),Jr={kernelName:F,gradFunc:(t,e,n)=>{const{axis:r}=n;return{x:()=>Hr(t,r)}}},Zr={kernelName:T,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>re(t,Qt(oe(Xt(n,"float32")),2))}}},Yr={kernelName:"Square",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Qt(t,Qt(Xt(n,"float32"),2))}}},Xr={kernelName:"SquaredDifference",inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,i=se(2);return{a:()=>Qt(t,Qt(i,le(n,r))),b:()=>Qt(t,Qt(i,le(r,n)))}}},Qr={kernelName:M,gradFunc:t=>({x:()=>ve(t)})},ti={kernelName:"Sub",inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,i=de(n.shape,r.shape);return{a:()=>{let e=t;const r=pe(n.shape,i);return r.length>0&&(e=ge(e,r)),fe(e,n.shape)},b:()=>{let e=t;const n=pe(r.shape,i);return n.length>0&&(e=ge(e,n)),fe(ie(e),r.shape)}}}},ei={kernelName:"Sum",inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,i=r.shape.slice(),{axis:a}=n;K(a,r.shape).forEach((t=>{i[t]=1}));const s=fe(t,i),o=Qt(s,nr(r.shape,"float32"));return{x:()=>o}}},ni={kernelName:"Tan",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>re(t,ue(Mr(n)))}}},ri={kernelName:"Tanh",outputsToSave:[!0],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Qt(le(se(1),ue(n)),t)}}},ii={kernelName:D,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{reps:i}=n;return{x:()=>{let e=ve(r);if(1===r.rank)for(let n=0;n<i[0];++n)e=Se(e,sr(t,[n*r.shape[0]],[r.shape[0]]));else if(2===r.rank)for(let n=0;n<i[0];++n)for(let a=0;a<i[1];++a)e=Se(e,sr(t,[n*r.shape[0],a*r.shape[1]],[r.shape[0],r.shape[1]]));else if(3===r.rank)for(let n=0;n<i[0];++n)for(let a=0;a<i[1];++a)for(let s=0;s<i[2];++s)e=Se(e,sr(t,[n*r.shape[0],a*r.shape[1],s*r.shape[2]],[r.shape[0],r.shape[1],r.shape[2]]));else{if(4!==r.rank)throw new Error(`Gradient for tile operation is not implemented for rank-${r.rank} tensors yet.`);for(let n=0;n<i[0];++n)for(let a=0;a<i[1];++a)for(let s=0;s<i[2];++s)for(let o=0;o<i[3];++o)e=Se(e,sr(t,[n*r.shape[0],a*r.shape[1],s*r.shape[2],o*r.shape[3]],[r.shape[0],r.shape[1],r.shape[2],r.shape[3]]))}return e}}}},ai={kernelName:L,gradFunc:(t,e,n)=>{const r=n,{perm:i}=r,a=cn(i);return{x:()=>pn(t,a)}}};const si=Yt({stack_:function(t,e=0){const n=Zt(t,"tensors","stack","string_or_numeric");P(n.length>=1,(()=>"Pass at least one tensor to tf.stack")),n.length>0&&P(e<=n[0].rank,(()=>"Axis must be <= rank of the tensor"));const r=n,i={axis:e};return Vt.runKernel(w,r,i)}}),oi={kernelName:_,gradFunc:(t,e,n)=>{const r=n,{axis:i}=r;return{value:()=>si(t,i)}}};const ui=Yt({expandDims_:function(t,e=0){const n=Jt(t,"x","expandDims","string_or_numeric");P(e<=n.rank,(()=>"Axis must be <= rank of the tensor"));const r={input:n},i={dim:e};return Vt.runKernel(p,r,i)}});const li=Yt({gather_:function(t,e,n=0,r=0){const i={x:Jt(t,"x","gather"),indices:Jt(e,"indices","gather","int32")},a={axis:n,batchDims:r};return Vt.runKernel(g,i,a)}});const ci=Yt({maximum_:function(t,e){let n=Jt(t,"a","maximum"),r=Jt(e,"b","maximum");[n,r]=Bt(n,r),"bool"===n.dtype&&(n=Xt(n,"int32"),r=Xt(r,"int32")),de(n.shape,r.shape);const i={a:n,b:r};return Vt.runKernel(v,i)}});const hi=[ee,ce,he,me,ye,be,we,ke,Ne,xe,ze,Ie,Ce,Ee,De,_e,Re,Oe,Me,Ve,Ke,Ge,tn,Xe,rn,sn,un,dn,mn,yn,kr,vn,wn,kn,Sn,Nn,zn,xn,Cn,En,Ln,_n,Rn,On,Mn,Pn,$n,Wn,Un,Vn,Gn,Gn,Jn,Yn,Qn,rr,ir,ar,or,lr,cr,hr,pr,dr,gr,mr,mr,br,wr,Sr,Nr,xr,zr,Ir,Ar,Tr,Er,Fr,Lr,_r,Rr,Or,Br,$r,Ur,jr,Kr,Gr,Gr,Jr,Jr,Zr,Xr,Yr,Qr,ti,ei,ni,ri,ii,ai,oi,{kernelName:R,inputsToSave:["segmentIds"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>function(t,e){const n=ci(e,ve(e)),r=li(t,n);let i=Be(e,se(0,"int32"));const a=r.rank-i.rank;for(let t=0;t<a;++t)i=ui(i,t+1);i=$e(i,nr(r.shape,"bool"));const s=ve(r);return je(i,r,s)}(t,n)}}},{kernelName:O,gradFunc:t=>({x:()=>ve(t)})}];for(const t of hi)mt(t);var pi=function(t,e){return(pi=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e}||function(t,e){for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n])})(t,e)};function di(t,e){function n(){this.constructor=t}pi(t,e),t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)}var fi,gi=function(){return(gi=Object.assign||function(t){for(var e,n=1,r=arguments.length;n<r;n++)for(var i in e=arguments[n])Object.prototype.hasOwnProperty.call(e,i)&&(t[i]=e[i]);return t}).apply(this,arguments)};function mi(t,e,n,r){return new(n||(n=Promise))((function(i,a){function s(t){try{u(r.next(t))}catch(t){a(t)}}function o(t){try{u(r.throw(t))}catch(t){a(t)}}function u(t){var e;t.done?i(t.value):(e=t.value,e instanceof n?e:new n((function(t){t(e)}))).then(s,o)}u((r=r.apply(t,e||[])).next())}))}function yi(t,e){var n,r,i,a,s={label:0,sent:function(){if(1&i[0])throw i[1];return i[1]},trys:[],ops:[]};return a={next:o(0),throw:o(1),return:o(2)},"function"==typeof Symbol&&(a[Symbol.iterator]=function(){return this}),a;function o(a){return function(o){return function(a){if(n)throw new TypeError("Generator is already executing.");for(;s;)try{if(n=1,r&&(i=2&a[0]?r.return:a[0]?r.throw||((i=r.return)&&i.call(r),0):r.next)&&!(i=i.call(r,a[1])).done)return i;switch(r=0,i&&(a=[2&a[0],i.value]),a[0]){case 0:case 1:i=a;break;case 4:return s.label++,{value:a[1],done:!1};case 5:s.label++,r=a[1],a=[0];continue;case 7:a=s.ops.pop(),s.trys.pop();continue;default:if(!(i=s.trys,(i=i.length>0&&i[i.length-1])||6!==a[0]&&2!==a[0])){s=0;continue}if(3===a[0]&&(!i||a[1]>i[0]&&a[1]<i[3])){s.label=a[1];break}if(6===a[0]&&s.label<i[1]){s.label=i[1],i=a;break}if(i&&s.label<i[2]){s.label=i[2],s.ops.push(a);break}i[2]&&s.ops.pop(),s.trys.pop();continue}a=e.call(t,s)}catch(t){a=[6,t],r=0}finally{n=i=0}if(5&a[0])throw a[1];return{value:a[0]?a[1]:void 0,done:!0}}([a,o])}}}function vi(){return null==fi&&(fi=e.backend().epsilon()),fi}var bi=function(t){function e(n){var r=t.call(this,n)||this;return Object.setPrototypeOf(r,e.prototype),r}return di(e,t),e}(Error),wi=function(t){function e(n){var r=t.call(this,n)||this;return Object.setPrototypeOf(r,e.prototype),r}return di(e,t),e}(Error),ki=function(t){function e(n){var r=t.call(this,n)||this;return Object.setPrototypeOf(r,e.prototype),r}return di(e,t),e}(Error),Si=function(t){function e(n){var r=t.call(this,n)||this;return Object.setPrototypeOf(r,e.prototype),r}return di(e,t),e}(Error),Ni=function(t){function e(n){var r=t.call(this,n)||this;return Object.setPrototypeOf(r,e.prototype),r}return di(e,t),e}(Error);!function(t){function e(n){var r=t.call(this,n)||this;return Object.setPrototypeOf(r,e.prototype),r}di(e,t)}(Error);function xi(t,e){if(Array.isArray(t)){for(var n=[],r=0;r<e;r++)n=n.concat(t);return n}return(n=new Array(e)).fill(t),n}function zi(t,e){if(!t)throw new Ni(e)}function Ii(t,e){for(var n=0,r=0,i=t;r<i.length;r++){i[r]===e&&n++}return n}function Ai(t){return 1===t.length?t[0]:t}function Ci(t){return Array.isArray(t)?t:[t]}function Ti(t){var e=t.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return"_"!==e[0]?e:"private"+e}function Ei(t){return t.length<=1||-1===t.indexOf("_")?t:t.replace(/[_]+(\w|$)/g,(function(t,e){return e.toUpperCase()}))}var Fi={};function Di(t){if(null==t)return null;var e={};return e.className=t.getClassName(),e.config=t.getConfig(),e}function Li(t){if(null!=t&&"object"==typeof t)if(Array.isArray(t))t.forEach((function(t){return Li(t)}));else for(var e=0,n=Object.keys(t);e<n.length;e++){var r=n[e],i=t[r];null!=i&&"object"==typeof i&&(Array.isArray(i)||"ndarray"!==i.type||"number"!=typeof i.value?Li(i):t[r]=i.value)}}function _i(t,e,n,r,i){var a,s,o;if(void 0===e&&(e={}),void 0===n&&(n={}),void 0===r&&(r="object"),void 0===i&&(i=!1),"string"==typeof t){var u=t,l=void 0;if(u in n)l=n[u];else if(u in Fi)l=Fi[u];else if(null==(l=e[u]))throw new ki("Unknown "+r+": "+t+". This may be due to one of the following reasons:\n1. The "+r+" is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom "+r+" is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().");return l}var c=t;if(null==c.className||null==c.config)throw new ki(r+": Improper config format: "+JSON.stringify(c)+".\n'className' and 'config' must set.");var h=c.className,p=void 0,d=void 0;if(h in n?(p=(a=n[h])[0],d=a[1]):h in Fi?(p=(s=Fi.className)[0],d=s[1]):h in e&&(p=(o=e[h])[0],d=o[1]),null==p)throw new ki("Unknown "+r+": "+h+". This may be due to one of the following reasons:\n1. The "+r+" is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom "+r+" is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().");if(null!=d){for(var f={},g=0,m=Object.keys(Fi);g<m.length;g++){f[S=m[g]]=Fi[S]}for(var y=0,v=Object.keys(n);y<v.length;y++){f[S=v[y]]=n[S]}c.config.customObjects=f;for(var b=gi({},Fi),w=0,k=Object.keys(n);w<k.length;w++){var S=k[w];Fi[S]=n[S]}Li(c.config);var N=d(p,c.config,n,i);return Fi=gi({},b),N}b=gi({},Fi);for(var x=0,z=Object.keys(n);x<z.length;x++){S=z[x];Fi[S]=n[S]}N=new p(c.config);return Fi=gi({},b),N}function Ri(t,e){return-1*function(t,e){return t<e?-1:t>e?1:0}(t,e)}function Oi(t){if(null==t)return t;for(var e=[],n=0,r=t;n<r.length;n++){var i=r[n];-1===e.indexOf(i)&&e.push(i)}return e}function Mi(t){if(null==t)throw new ki("Invalid value in obj: "+JSON.stringify(t));for(var e in t)if(t.hasOwnProperty(e))return!1;return!0}function Bi(t,e,n){if(null!=n&&t.indexOf(n)<0)throw new ki(n+" is not a valid "+e+".  Valid values are "+t+" or null/undefined.")}function Pi(t,e,n,r){return void 0===n&&(n=0),void 0===r&&(r=1/0),zi(n>=0),zi(r>=n),Array.isArray(t)&&t.length>=n&&t.length<=r&&t.every((function(t){return typeof t===e}))}function $i(t,n){Array.isArray(t)?(e.util.assert(t.length>0,(function(){return n+" is unexpectedly an empty array."})),t.forEach((function(t,e){return $i(t,"element "+(e+1)+" of "+n)}))):e.util.assert(Number.isInteger(t)&&t>0,(function(){return"Expected "+n+" to be a positive integer, but got "+Wi(t)+"."}))}function Wi(t){return null===t?"null":Array.isArray(t)?"["+t.map((function(t){return Wi(t)})).join(",")+"]":"string"==typeof t?'"'+t+'"':""+t}function Ui(t){return"relu"===t?"relu":"linear"===t?"linear":"elu"===t?"elu":null}function ji(t,n){return e.tidy((function(){return e.sqrt(e.sum(e.mul(t,t),n,!0))}))}var Vi=function(t){function e(){return null!==t&&t.apply(this,arguments)||this}return di(e,t),e.prototype.getConfig=function(){return{}},e}(e.serialization.Serializable),Ki=function(t){function n(e){var n=t.call(this)||this;return n.defaultMaxValue=2,n.defaultAxis=0,n.maxValue=null!=e.maxValue?e.maxValue:n.defaultMaxValue,n.axis=null!=e.axis?e.axis:n.defaultAxis,n}return di(n,t),n.prototype.apply=function(t){var n=this;return e.tidy((function(){var r=ji(t,n.axis),i=e.clipByValue(r,0,n.maxValue);return e.mul(t,e.div(i,e.add(vi(),r)))}))},n.prototype.getConfig=function(){return{maxValue:this.maxValue,axis:this.axis}},n.className="MaxNorm",n}(Vi);e.serialization.registerClass(Ki);var qi=function(t){function n(e){var n=t.call(this)||this;return n.defaultAxis=0,n.axis=null!=e.axis?e.axis:n.defaultAxis,n}return di(n,t),n.prototype.apply=function(t){var n=this;return e.tidy((function(){return e.div(t,e.add(vi(),ji(t,n.axis)))}))},n.prototype.getConfig=function(){return{axis:this.axis}},n.className="UnitNorm",n}(Vi);e.serialization.registerClass(qi);var Gi=function(t){function n(){return null!==t&&t.apply(this,arguments)||this}return di(n,t),n.prototype.apply=function(t){return e.relu(t)},n.className="NonNeg",n}(Vi);e.serialization.registerClass(Gi);var Hi=function(t){function n(e){var n=t.call(this)||this;return n.defaultMinValue=0,n.defaultMaxValue=1,n.defaultRate=1,n.defaultAxis=0,n.minValue=null!=e.minValue?e.minValue:n.defaultMinValue,n.maxValue=null!=e.maxValue?e.maxValue:n.defaultMaxValue,n.rate=null!=e.rate?e.rate:n.defaultRate,n.axis=null!=e.axis?e.axis:n.defaultAxis,n}return di(n,t),n.prototype.apply=function(t){var n=this;return e.tidy((function(){var r=ji(t,n.axis),i=e.add(e.mul(n.rate,e.clipByValue(r,n.minValue,n.maxValue)),e.mul(1-n.rate,r));return e.mul(t,e.div(i,e.add(vi(),r)))}))},n.prototype.getConfig=function(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}},n.className="MinMaxNorm",n}(Vi);e.serialization.registerClass(Hi);var Ji={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function Zi(t){return Di(t)}function Yi(t,n){return void 0===n&&(n={}),_i(t,e.serialization.SerializationMap.getMap().classNameMap,n,"constraint")}function Xi(t){return null==t?null:"string"==typeof t?Yi({className:t in Ji?Ji[t]:t,config:{}}):t instanceof Vi?t:Yi(t)}var Qi={__proto__:null,maxNorm:function(t){return new Ki(t)},unitNorm:function(t){return new qi(t)},nonNeg:function(){return new Gi},minMaxNorm:function(t){return new Hi(t)}},ta=["channelsFirst","channelsLast"],ea=["nearest","bilinear"],na=["valid","same","causal"],ra=["max","avg"],ia=["sum","mul","concat","ave"],aa=new Map;function sa(t){Bi(ta,"DataFormat",t)}function oa(t){Bi(na,"PaddingMode",t)}function ua(t){Bi(ra,"PoolMode",t)}var la=[];function ca(t,e){la.push(t);try{var n=e();return la.pop(),n}catch(t){throw la.pop(),t}}function ha(t){if(!fa(t))throw new Error("Not a valid tensor name: '"+t+"'");return(0===la.length?"":la.join("/")+"/")+t}function pa(t){if(!fa(t))throw new Error("Not a valid tensor name: '"+t+"'");aa.has(t)||aa.set(t,0);var e=aa.get(t);if(aa.set(t,aa.get(t)+1),e>0){var n=t+"_"+e;return aa.set(n,1),n}return t}var da=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function fa(t){return!!t.match(da)}function ga(t,e,n){null==e&&(e=0),null==n&&(n=t.length);for(var r=1,i=e;i<n;++i)r*=t[i];return r}function ma(t){if(0===t.length)return Number.NaN;for(var e=Number.POSITIVE_INFINITY,n=0;n<t.length;n++){var r=t[n];r<e&&(e=r)}return e}function ya(t){if(0===t.length)return Number.NaN;for(var e=Number.NEGATIVE_INFINITY,n=0;n<t.length;n++){var r=t[n];r>e&&(e=r)}return e}function va(t,e){if(e<t)throw new ki("end ("+e+") < begin ("+t+") is forbidden.");for(var n=[],r=t;r<e;++r)n.push(r);return n}function ba(t,n){return e.cast(t,n)}function wa(t,n){void 0===n&&(n=-1);var r=t.shape.slice();return n<0&&(n=r.length+n+1),r.splice(n,0,1),e.reshape(t,r)}function ka(t,n,r){return e.tidy((function(){switch(t.rank){case 1:return e.slice1d(t,n,r);case 2:return e.slice2d(t,[n,0],[r,t.shape[1]]);case 3:return e.slice3d(t,[n,0,0],[r,t.shape[1],t.shape[2]]);case 4:return e.slice4d(t,[n,0,0,0],[r,t.shape[1],t.shape[2],t.shape[3]]);case 5:return e.slice(t,[n,0,0,0,0],[r,t.shape[1],t.shape[2],t.shape[3],t.shape[4]]);case 6:return e.slice(t,[n,0,0,0,0,0],[r,t.shape[1],t.shape[2],t.shape[3],t.shape[4],t.shape[5]]);default:throw new ki("sliceAlongFirstAxis() received an unsupported tensor rank: "+t.rank)}}))}function Sa(t,n,r){return e.tidy((function(){switch(t.rank){case 1:return e.slice1d(t,n,r);case 2:return e.slice2d(t,[0,n],[t.shape[0],r]);case 3:return e.slice3d(t,[0,0,n],[t.shape[0],t.shape[1],r]);case 4:return e.slice4d(t,[0,0,0,n],[t.shape[0],t.shape[1],t.shape[2],r]);default:throw new ki("sliceAlongLastAxis() received an unsupported tensor rank: "+t.rank)}}))}function Na(t,n,r,i){return e.tidy((function(){switch(t.rank){case 1:return e.slice1d(t,n,r);case 2:switch(i){case 1:return ka(t,n,r);case 2:return Sa(t,n,r);default:throw new ki("The axis is not within the rank of the tensor "+i)}case 3:switch(i){case 1:return ka(t,n,r);case 2:return e.slice3d(t,[0,n,0],[t.shape[0],r,t.shape[2]]);case 3:return Sa(t,n,r);default:throw new ki("The axis is not within the rank of the tensor "+i)}case 4:switch(i){case 1:return ka(t,n,r);case 2:return e.slice4d(t,[0,n,0,0],[t.shape[0],r,t.shape[2],t.shape[3]]);case 3:return e.slice4d(t,[0,0,n,0],[t.shape[0],t.shape[1],r,t.shape[3]]);case 4:return Sa(t,n,r);default:throw new ki("The axis is not within the rank of the tensor "+i)}default:throw new ki("sliceAlongLastAxis() received an unsupported tensor rank: "+t.rank)}}))}function xa(t,n){var r;return void 0===n&&(n=-1),n<0&&(n=0!==(r=t[0].rank)?r:0),n===t[0].rank&&(n=-1),e.concat(t,n)}function za(t,n){switch(t.rank){case 1:return e.concat1d([t,n]);case 2:return e.concat2d([t,n],0);case 3:return e.concat3d([t,n],0);case 4:return e.concat4d([t,n],0);default:throw new ki("concatAlongFirstAxis() received an unsupported tensor rank: "+t.rank)}}function Ia(t,n){if(Array.isArray(n)||(n=[n]),t.rank!==n.length)throw new ki("The length of input n ("+n.length+") does not match the number of dimensions in input x ("+t.rank+")");return e.tile(t,n)}function Aa(t,n,r,i,a){return void 0===n&&(n=0),void 0===r&&(r=1),e.randomNormal(t,n,r,i,a)}function Ca(t,n,r,i){if(t.rank<2||n.rank<2)throw new Si("dot requires both inputs to be rank >= 2 but got x shape = "+t.shape+" and y shape = "+n.shape);if(n.rank>=3&&t.shape.slice(-1)[0]!==(h=n.shape.slice(-2)[0]))throw new Si("If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = "+t.shape+" and  y shape = "+n.shape);if(2===t.rank&&2===n.rank){var a=!1,s=!1;return e.fused.matMul({a:t,b:n,transposeA:a,transposeB:s,bias:i?Fa(t.rank,i,"channelsLast"):null,activation:r})}var o=t.shape.slice(),u=o.pop();t=e.reshape(t,[-1,u]);var l=n.shape.slice(),c=l.pop(),h=l.pop(),p=l.concat([c]),d=Array.from({length:n.rank},(function(t,e){return 0===e?n.rank-2:e<=n.rank-2?e-1:e}));n=e.reshape(e.transpose(n,d),[h,-1]);var f=o.concat(p);a=!1,s=!1;return e.reshape(e.fused.matMul({a:t,b:n,transposeA:a,transposeB:s,bias:i?Fa(t.rank,i,"channelsLast"):null,activation:r}),f)}function Ta(t,n,r){return e.tidy((function(){return n=Array.isArray(n)?e.tensor1d(n,"int32"):e.cast(n,"int32"),e.gather(t,n,r)}))}function Ea(t){return e.mul(t,t)}function Fa(t,n,r){var i=n.shape;if(1!==n.rank&&n.rank!==t)throw new ki("Unexpected bias dimensions: "+n.rank+"; expected it to be 1 or "+t);if(5===t){if("channelsFirst"===r)return 1===i.length?e.reshape(n,[1,i[0],1,1,1]):e.reshape(n,[1,i[3],i[0],i[1],i[2]]);if("channelsLast"===r)return 1===i.length?e.reshape(n,[1,1,1,1,i[0]]):e.reshape(n,[1].concat(i))}else if(4===t){if("channelsFirst"===r)return 1===i.length?e.reshape(n,[1,i[0],1,1]):e.reshape(n,[1,i[2],i[0],i[1]]);if("channelsLast"===r)return 1===i.length?e.reshape(n,[1,1,1,i[0]]):e.reshape(n,[1].concat(i))}else if(3===t){if("channelsFirst"===r)return 1===i.length?e.reshape(n,[1,i[0],1]):e.reshape(n,[1,i[1],i[0]]);if("channelsLast"===r)return 1===i.length?e.reshape(n,[1,1,i[0]]):e.reshape(n,[1].concat(i))}else if(t<3)return n;throw new ki("Unsupported input rank by biasAdd: "+n.rank)}function Da(t,n,r){return e.tidy((function(){return null==r&&(r="channelsLast"),sa(r),e.add(t,Fa(t.rank,n,r))}))}function La(t,n,r,i){return e.tidy((function(){return e.dropout(t,n,r,i)}))}function _a(t,e,n){return void 0===n&&(n=!1),n?t():e()}var Ra=["fanIn","fanOut","fanAvg"],Oa=["normal","uniform","truncatedNormal"];var Ma=function(t){function e(){return null!==t&&t.apply(this,arguments)||this}return di(e,t),e.prototype.fromConfigUsesCustomObjects=function(){return!1},e.prototype.getConfig=function(){return{}},e}(e.serialization.Serializable),Ba=function(t){function n(){return null!==t&&t.apply(this,arguments)||this}return di(n,t),n.prototype.apply=function(t,n){return e.zeros(t,n)},n.className="Zeros",n}(Ma);e.serialization.registerClass(Ba);var Pa=function(t){function n(){return null!==t&&t.apply(this,arguments)||this}return di(n,t),n.prototype.apply=function(t,n){return e.ones(t,n)},n.className="Ones",n}(Ma);e.serialization.registerClass(Pa);var $a=function(t){function n(e){var n=t.call(this)||this;if("object"!=typeof e)throw new ki("Expected argument of type ConstantConfig but got "+e);if(void 0===e.value)throw new ki("config must have value set but got "+e);return n.value=e.value,n}return di(n,t),n.prototype.apply=function(t,n){var r=this;return e.tidy((function(){return e.mul(e.scalar(r.value),e.ones(t,n))}))},n.prototype.getConfig=function(){return{value:this.value}},n.className="Constant",n}(Ma);e.serialization.registerClass($a);var Wa=function(t){function n(e){var n=t.call(this)||this;return n.DEFAULT_MINVAL=-.05,n.DEFAULT_MAXVAL=.05,n.minval=e.minval||n.DEFAULT_MINVAL,n.maxval=e.maxval||n.DEFAULT_MAXVAL,n.seed=e.seed,n}return di(n,t),n.prototype.apply=function(t,n){return e.randomUniform(t,this.minval,this.maxval,n)},n.prototype.getConfig=function(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}},n.className="RandomUniform",n}(Ma);e.serialization.registerClass(Wa);var Ua=function(t){function e(e){var n=t.call(this)||this;return n.DEFAULT_MEAN=0,n.DEFAULT_STDDEV=.05,n.mean=e.mean||n.DEFAULT_MEAN,n.stddev=e.stddev||n.DEFAULT_STDDEV,n.seed=e.seed,n}return di(e,t),e.prototype.apply=function(t,e){if("float32"!==(e=e||"float32")&&"int32"!==e)throw new Si("randomNormal does not support dType "+e+".");return Aa(t,this.mean,this.stddev,e,this.seed)},e.prototype.getConfig=function(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}},e.className="RandomNormal",e}(Ma);e.serialization.registerClass(Ua);var ja=function(t){function n(e){var n=t.call(this)||this;return n.DEFAULT_MEAN=0,n.DEFAULT_STDDEV=.05,n.mean=e.mean||n.DEFAULT_MEAN,n.stddev=e.stddev||n.DEFAULT_STDDEV,n.seed=e.seed,n}return di(n,t),n.prototype.apply=function(t,n){if("float32"!==(n=n||"float32")&&"int32"!==n)throw new Si("truncatedNormal does not support dType "+n+".");return e.truncatedNormal(t,this.mean,this.stddev,n,this.seed)},n.prototype.getConfig=function(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}},n.className="TruncatedNormal",n}(Ma);e.serialization.registerClass(ja);var Va=function(t){function n(e){var n=t.call(this)||this;return n.gain=null!=e.gain?e.gain:1,n}return di(n,t),n.prototype.apply=function(t,n){var r=this;return e.tidy((function(){if(2!==t.length||t[0]!==t[1])throw new ki("Identity matrix initializer can only be used for 2D square matrices.");return e.mul(r.gain,e.eye(t[0]))}))},n.prototype.getConfig=function(){return{gain:this.gain}},n.className="Identity",n}(Ma);e.serialization.registerClass(Va);var Ka=function(t){function n(e){var n,r=t.call(this)||this;if(e.scale<0)throw new ki("scale must be a positive float. Got: "+e.scale);return r.scale=null==e.scale?1:e.scale,r.mode=null==e.mode?"fanIn":e.mode,n=r.mode,Bi(Ra,"FanMode",n),r.distribution=null==e.distribution?"normal":e.distribution,function(t){Bi(Oa,"Distribution",t)}(r.distribution),r.seed=e.seed,r}return di(n,t),n.prototype.apply=function(t,n){var r=function(t,e){var n,r;if(void 0===e&&(e="channelsLast"),sa(e),2===t.length)n=t[0],r=t[1];else if(-1!==[3,4,5].indexOf(t.length))if("channelsFirst"===e){var i=ga(t,2);n=t[1]*i,r=t[0]*i}else"channelsLast"===e&&(i=ga(t,0,t.length-2),n=t[t.length-2]*i,r=t[t.length-1]*i);else{var a=ga(t);n=Math.sqrt(a),r=Math.sqrt(a)}return[n,r]}(t),i=r[0],a=r[1],s=this.scale;if("fanIn"===this.mode?s/=Math.max(1,i):"fanOut"===this.mode?s/=Math.max(1,a):s/=Math.max(1,(i+a)/2),"normal"===this.distribution){var o=Math.sqrt(s);if("float32"!==(n=n||"float32")&&"int32"!==n)throw new Si(this.getClassName()+" does not support dType "+n+".");return e.truncatedNormal(t,0,o,n,this.seed)}var u=Math.sqrt(3*s);return e.randomUniform(t,-u,u,n)},n.prototype.getConfig=function(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}},n.className="VarianceScaling",n}(Ma);e.serialization.registerClass(Ka);var qa=function(t){function e(e){return t.call(this,{scale:1,mode:"fanAvg",distribution:"uniform",seed:null==e?null:e.seed})||this}return di(e,t),e.prototype.getClassName=function(){return Ka.className},e.className="GlorotUniform",e}(Ka);e.serialization.registerClass(qa);var Ga=function(t){function e(e){return t.call(this,{scale:1,mode:"fanAvg",distribution:"normal",seed:null==e?null:e.seed})||this}return di(e,t),e.prototype.getClassName=function(){return Ka.className},e.className="GlorotNormal",e}(Ka);e.serialization.registerClass(Ga);var Ha=function(t){function e(e){return t.call(this,{scale:2,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})||this}return di(e,t),e.prototype.getClassName=function(){return Ka.className},e.className="HeNormal",e}(Ka);e.serialization.registerClass(Ha);var Ja=function(t){function e(e){return t.call(this,{scale:2,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})||this}return di(e,t),e.prototype.getClassName=function(){return Ka.className},e.className="HeUniform",e}(Ka);e.serialization.registerClass(Ja);var Za=function(t){function e(e){return t.call(this,{scale:1,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})||this}return di(e,t),e.prototype.getClassName=function(){return Ka.className},e.className="LeCunNormal",e}(Ka);e.serialization.registerClass(Za);var Ya=function(t){function e(e){return t.call(this,{scale:1,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})||this}return di(e,t),e.prototype.getClassName=function(){return Ka.className},e.className="LeCunNormal",e}(Ka);e.serialization.registerClass(Ya);var Xa=function(t){function n(e){var n=t.call(this)||this;if(n.DEFAULT_GAIN=1,n.gain=null==e.gain?n.DEFAULT_GAIN:e.gain,n.seed=e.seed,null!=n.seed)throw new Si("Random seed is not implemented for Orthogonal Initializer yet.");return n}return di(n,t),n.prototype.apply=function(t,n){var r=this;return e.tidy((function(){if(t.length<2)throw new Si("Shape must be at least 2D.");t[0]*t[1]>2e3&&console.warn("Orthogonal initializer is being called on a matrix with more than 2000 ("+t[0]*t[1]+") elements: Slowness may result.");var n=Aa(t[0]>t[1]?[t[1],t[0]]:t,0,1,"float32"),i=e.linalg.gramSchmidt(n);return t[0]>t[1]&&(i=e.transpose(i)),e.mul(r.gain,i)}))},n.prototype.getConfig=function(){return{gain:this.gain,seed:this.seed}},n.className="Orthogonal",n}(Ma);e.serialization.registerClass(Xa);var Qa={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function ts(t,n){return void 0===n&&(n={}),_i(t,e.serialization.SerializationMap.getMap().classNameMap,n,"initializer")}function es(t){return Di(t)}function ns(t){if("string"==typeof t){var e=t in Qa?Qa[t]:t;if("GlorotNormal"===e)return new Ga;if("GlorotUniform"===e)return new qa;if("HeNormal"===e)return new Ha;if("HeUniform"===e)return new Ja;if("LeCunNormal"===e)return new Za;if("LeCunUniform"===e)return new Ya;var n={};return n.className=e,n.config={},ts(n)}return t instanceof Ma?t:ts(t)}var rs={__proto__:null,zeros:function(){return new Ba},ones:function(){return new Pa},constant:function(t){return new $a(t)},randomUniform:function(t){return new Wa(t)},randomNormal:function(t){return new Ua(t)},truncatedNormal:function(t){return new ja(t)},identity:function(t){return new Va(t)},varianceScaling:function(t){return new Ka(t)},glorotUniform:function(t){return new qa(t)},glorotNormal:function(t){return new Ga(t)},heNormal:function(t){return new Ha(t)},heUniform:function(t){return new Ja(t)},leCunNormal:function(t){return new Za(t)},leCunUniform:function(t){return new Ya(t)},orthogonal:function(t){return new Xa(t)}},is=0;function as(){return is++}var ss={};function os(t){return void 0===t&&(t=""),t in ss||(ss[t]=0),ss[t]+=1,t+ss[t].toString()}function us(t){return Array.isArray(t)&&Array.isArray(t[0])}function ls(t){return 0===t.length?[]:Array.isArray(t[0])?t:[t]}function cs(t){var e;if(Array.isArray(t)){if(1!==t.length)throw new ki("Expected Tensor length to be 1; got "+t.length);e=t[0]}else e=t;return e}function hs(t){if(Array.isArray(t)&&Array.isArray(t[0])){if(1===t.length)return(t=t)[0];throw new ki("Expected exactly 1 Shape; got "+t.length)}return t}function ps(t){for(var e=0,n=0,r=t;n<r.length;n++){var i=r[n];0===i.shape.length?e+=1:e+=i.shape.reduce((function(t,e){return t*e}))}return e}var ds="Variable",fs=function(){function t(t,n,r,i,a){void 0===n&&(n="float32"),void 0===r&&(r=ds),void 0===i&&(i=!0),void 0===a&&(a=null),this.dtype=null==n?"float32":n,this.shape=t.shape,this.id=as(),r=null==r?ds:r,this.originalName=ha(r),this.name=pa(this.originalName),this.trainable_=i,this.constraint=a,this.val=e.variable(t,this.trainable_,this.name,this.dtype)}return t.prototype.read=function(){return this.assertNotDisposed(),this.val},t.prototype.write=function(t){return this.assertNotDisposed(),function(t,e){if(t.shape.toString()!==e.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(t.shape)+" vs. "+JSON.stringify(e.shape))}(this.val,t),this.val.id!==t.id&&(this.val.assign(t),null!=this.constraint&&this.val.assign(this.constraint.apply(this.val))),this},t.prototype.dispose=function(){this.assertNotDisposed(),this.val.dispose()},t.prototype.assertNotDisposed=function(){if(this.val.isDisposed)throw new Error("LayersVariable "+this.name+" is already disposed.")},Object.defineProperty(t.prototype,"trainable",{get:function(){return this.trainable_},set:function(t){this.trainable_=t,this.val.trainable=t},enumerable:!0,configurable:!0}),t}();function gs(t){return t.map((function(t){return t.read()}))}function ms(t){t.forEach((function(t){t[0].write(t[1])}))}var ys=function(t){this.dtype=t.dtype,this.shape=t.shape,null!=t.shape?this.ndim=t.shape.length:this.ndim=t.ndim,this.maxNDim=t.maxNDim,this.minNDim=t.minNDim,this.axes=t.axes||{}},vs=function(t,e,n,r,i,a,s){this.dtype=t,this.shape=e,this.sourceLayer=n,this.inputs=r,this.callArgs=i,this.outputTensorIndex=s,this.id=as(),null!=a&&(this.originalName=ha(a),this.name=pa(this.originalName)),this.rank=e.length},bs=0,ws=function(){function t(t,e){this.callArgs=e,this.id=bs++,this.outboundLayer=t.outboundLayer,this.inboundLayers=t.inboundLayers,this.nodeIndices=t.nodeIndices,this.tensorIndices=t.tensorIndices,this.inputTensors=t.inputTensors,this.outputTensors=t.outputTensors,this.inputMasks=t.inputMasks,this.outputMasks=t.outputMasks,this.inputShapes=t.inputShapes,this.outputShapes=t.outputShapes;for(var n=0,r=t.inboundLayers;n<r.length;n++){var i=r[n];null!=i&&i.outboundNodes.push(this)}t.outboundLayer.inboundNodes.push(this)}return t.prototype.getConfig=function(){for(var t=[],e=0,n=this.inboundLayers;e<n.length;e++){var r=n[e];null!=r?t.push(r.name):t.push(null)}return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:t,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}},t}(),ks=0,Ss=function(t){function n(e){void 0===e&&(e={});var n=t.call(this)||this;n._callHook=null,n._addedWeightNames=[],n._stateful=!1,n.id=ks++,n.activityRegularizer=null,n.inputSpec=null,n.supportsMasking=!1,n._trainableWeights=[],n._nonTrainableWeights=[],n._losses=[],n._updates=[],n._built=!1,n.inboundNodes=[],n.outboundNodes=[];var r=e.name;if(!r){var i=n.getClassName();r=Ti(i)+"_"+os(i)}if(n.name=r,n.trainable_=null==e.trainable||e.trainable,null!=e.inputShape||null!=e.batchInputShape){var a=void 0;if(null!=e.batchInputShape)a=e.batchInputShape;else if(null!=e.inputShape){var s=null;null!=e.batchSize&&(s=e.batchSize),a=[s].concat(e.inputShape)}n.batchInputShape=a;var o=e.dtype;null==o&&(o=e.inputDType),null==o&&(o="float32"),n.dtype=o}return null!=e.weights?n.initialWeights=e.weights:n.initialWeights=null,n._refCount=null,n.fastWeightInitDuringBuild=!1,n}return di(n,t),n.nodeKey=function(t,e){return t.name+"_ib-"+e.toString()},n.prototype.getNodeAtIndex=function(t,e){if(0===this.inboundNodes.length)throw new wi("The layer has never been called and thus has no defined "+e+".");if(this.inboundNodes.length<=t)throw new ki("Asked to get "+e+" at node "+t+", but the layer has only "+this.inboundNodes.length+" inbound nodes.");return this.inboundNodes[t]},n.prototype.getInputAt=function(t){return Ai(this.getNodeAtIndex(t,"input").inputTensors)},n.prototype.getOutputAt=function(t){return Ai(this.getNodeAtIndex(t,"output").outputTensors)},Object.defineProperty(n.prototype,"input",{get:function(){if(this.inboundNodes.length>1)throw new bi("Layer "+this.name+' has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use `getInputAt(nodeIndex)` instead.');if(0===this.inboundNodes.length)throw new bi("Layer "+this.name+" is not connected, no input to return.");return Ai(this.getNodeAtIndex(0,"input").inputTensors)},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"output",{get:function(){if(0===this.inboundNodes.length)throw new bi("Layer "+this.name+" has no inbound nodes.");if(this.inboundNodes.length>1)throw new bi("Layer "+this.name+' has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use `getOutputAt(nodeIndex)` instead.');return Ai(this.getNodeAtIndex(0,"output").outputTensors)},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"losses",{get:function(){return this._losses},enumerable:!0,configurable:!0}),n.prototype.calculateLosses=function(){return this.losses.map((function(t){return t()}))},Object.defineProperty(n.prototype,"updates",{get:function(){return this._updates},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"built",{get:function(){return this._built},set:function(t){this._built=t},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"trainable",{get:function(){return this.trainable_},set:function(t){this._trainableWeights.forEach((function(e){return e.trainable=t})),this.trainable_=t},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"trainableWeights",{get:function(){return this.trainable_?this._trainableWeights.filter((function(t){return t.trainable})):[]},set:function(t){this._trainableWeights=t},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"nonTrainableWeights",{get:function(){return this.trainable?this._trainableWeights.filter((function(t){return!t.trainable})).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)},set:function(t){this._nonTrainableWeights=t},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"weights",{get:function(){return this.trainableWeights.concat(this.nonTrainableWeights)},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"stateful",{get:function(){return this._stateful},enumerable:!0,configurable:!0}),n.prototype.resetStates=function(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")},n.prototype.assertInputCompatibility=function(t){if(t=Ci(t),null!=this.inputSpec&&0!==this.inputSpec.length){var e=Ci(this.inputSpec);if(t.length!==e.length)throw new ki("Layer "+this.name+" expects "+e.length+" inputs, but it received "+t.length+" input tensors. Input received: "+t);for(var n=0;n<t.length;n++){var r=t[n],i=e[n];if(null!=i){var a=r.rank;if(null!=i.ndim&&a!==i.ndim)throw new ki("Input "+n+" is incompatible with layer "+this.name+": expected ndim="+i.ndim+", found ndim="+a);if(null!=i.maxNDim&&a>i.maxNDim)throw new ki("Input "+n+" is incompatible with layer "+this.name+": expected max_ndim="+i.maxNDim+", found ndim="+a);if(null!=i.minNDim&&a<i.minNDim)throw new ki("Input "+n+" is incompatible with layer "+this.name+": expected min_ndim="+i.minNDim+", found ndim="+a+".");if(null!=i.dtype&&r.dtype!==i.dtype)throw new ki("Input "+n+" is incompatible with layer "+this.name+" : expected dtype="+i.dtype+", found dtype="+r.dtype+".");if(i.axes){var s=r.shape;for(var o in i.axes){var u=Number(o),l=i.axes[o],c=u>=0?s[u]:s[s.length+u];if(null!=l&&-1===[l,null].indexOf(c))throw new ki("Input "+n+" is incompatible with layer "+this.name+": expected axis "+u+" of input shape to have value "+l+" but got shape "+s+".")}}if(null!=i.shape)for(var h=0;h<i.shape.length;++h){var p=i.shape[h],d=r.shape[h];if(null!=p&&null!=d&&p!==d)throw new ki("Input "+n+" is incompatible with layer "+this.name+": expected shape="+i.shape+", found shape="+r.shape+".")}}}}},n.prototype.call=function(t,e){return t},n.prototype.invokeCallHook=function(t,e){null!=this._callHook&&this._callHook(t,e)},n.prototype.setCallHook=function(t){this._callHook=t},n.prototype.clearCallHook=function(){this._callHook=null},n.prototype.apply=function(t,e){var n=this;e=e||{},this.assertNotDisposed();for(var r=Ci(t),i=!0,a=0,s=r;a<s.length;a++){if(!(s[a]instanceof vs)){i=!1;break}}for(var o=!0,u=0,l=r;u<l.length;u++){if(l[u]instanceof vs){o=!1;break}}if(i===o)throw new ki("Arguments to apply() must be all SymbolicTensors or all Tensors");return ca(this.name,(function(){if(!n.built){n.assertInputCompatibility(t);for(var i=[],a=0,s=Ci(t);a<s.length;a++){var u=s[a];i.push(u.shape)}n.build(Ai(i)),n.built=!0,n.initialWeights&&n.setWeights(n.initialWeights),null===n._refCount&&o&&(n._refCount=1)}if(n.assertInputCompatibility(t),o){for(var l=[],c=0,h=Ci(g=n.call(t,e));c<h.length;c++){var p=h[c];-1!==r.indexOf(p)&&(p=p.clone()),l.push(p)}if(g=Ai(l),null!=n.activityRegularizer)throw new Si("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return g}var d=function(t){t=Ci(t);for(var e=[],n=0,r=t;n<r.length;n++){var i=r[n];e.push(i.shape)}return Ai(e)}(t),f=n.computeOutputShape(d),g=void 0,m="float32";if(n.warnOnIncompatibleInputShape(Array.isArray(t)?d[0]:d),g=null!=f&&f.length>0&&Array.isArray(f[0])?f.map((function(r,i){return new vs(m,r,n,Ci(t),e,n.name,i)})):new vs(m,f,n,Ci(t),e,n.name),n.addInboundNode(t,g,null,null,d,f,e),n._refCount++,null!=n.activityRegularizer)throw new Si("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return g}))},n.prototype.warnOnIncompatibleInputShape=function(t){if(null!=this.batchInputShape)if(t.length!==this.batchInputShape.length)console.warn("The rank of the input tensor provided (shape: "+JSON.stringify(t)+") does not match that of the batchInputShape ("+JSON.stringify(this.batchInputShape)+") of the layer "+this.name);else{var e=!1;this.batchInputShape.forEach((function(n,r){null!=n&&null!=t[r]&&t[r]!==n&&(e=!0)})),e&&console.warn("The shape of the input tensor ("+JSON.stringify(t)+") does not match the expectation of layer "+this.name+": "+JSON.stringify(this.batchInputShape))}},Object.defineProperty(n.prototype,"outputShape",{get:function(){if(null==this.inboundNodes||0===this.inboundNodes.length)throw new bi("The layer "+this.name+" has never been called and thus has no defined output shape.");for(var t=[],e=0,n=this.inboundNodes;e<n.length;e++){var r=n[e],i=JSON.stringify(r.outputShapes);-1===t.indexOf(i)&&t.push(i)}if(1===t.length){var a=this.inboundNodes[0].outputShapes;return Array.isArray(a)&&Array.isArray(a[0])&&1===a.length?a[0]:a}throw new bi("The layer "+this.name+' has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.')},enumerable:!0,configurable:!0}),n.prototype.countParams=function(){if(!this.built)throw new wi("You tried to call countParams() on "+this.name+", but the layer is not built yet. Build it first by calling build(batchInputShape).");return ps(this.weights)},n.prototype.build=function(t){this.built=!0},n.prototype.getWeights=function(t){return void 0===t&&(t=!1),gs(t?this.trainableWeights:this.weights)},n.prototype.setWeights=function(t){var n=this;e.tidy((function(){var r=n.weights;if(r.length!==t.length)throw new ki('You called setWeights(weights) on layer "'+n.name+'" with a weight list of length '+t.length+", but the layer was expecting "+r.length+" weights. Provided weights: "+t+"...");if(0!==r.length){for(var i=[],a=gs(r),s=0;s<a.length;++s){var o=a[s],u=r[s],l=t[s];if(!e.util.arraysEqual(o.shape,l.shape))throw new ki("Layer weight shape "+o.shape+" not compatible with provided weight shape "+l.shape);i.push([u,l])}ms(i)}}))},n.prototype.addWeight=function(t,e,n,r,i,a,s){if(-1!==this._addedWeightNames.indexOf(t))throw new ki("Duplicate weight name "+t+" for layer "+this.name);this._addedWeightNames.push(t),null==n&&(n="float32"),this.fastWeightInitDuringBuild&&(r=ns("zeros"));var o=r.apply(e,n),u=new fs(o,n,t,a,s);return o.dispose(),null!=i&&this.addLoss((function(){return i.apply(u.read())})),null==a&&(a=!0),a?this._trainableWeights.push(u):this._nonTrainableWeights.push(u),u},n.prototype.setFastWeightInitDuringBuild=function(t){this.fastWeightInitDuringBuild=t},n.prototype.addLoss=function(t){var e;null==t||Array.isArray(t)&&0===t.length||(t=Ci(t),void 0!==this._losses&&null!==this._losses&&(e=this.losses).push.apply(e,t))},n.prototype.computeOutputShape=function(t){return t},n.prototype.computeMask=function(t,e){var n=this;if(!this.supportsMasking){if(null!=e){if(!Array.isArray(e))throw new TypeError("Layer "+this.name+" does not support masking, but was passed an inputMask.");e.forEach((function(t){if(null!=t)throw new TypeError("Layer "+n.name+" does not support masking, but was passed an inputMask.")}))}return null}return e},n.prototype.addInboundNode=function(t,e,n,r,i,a,s){void 0===s&&(s=null);var o=Ci(t);e=Ci(e),n=Ci(n),r=Ci(r),i=ls(i),a=ls(a);for(var u=[],l=[],c=[],h=0,p=o;h<p.length;h++){var d=p[h];u.push(d.sourceLayer),l.push(d.nodeIndex),c.push(d.tensorIndex)}new ws({outboundLayer:this,inboundLayers:u,nodeIndices:l,tensorIndices:c,inputTensors:o,outputTensors:e,inputMasks:n,outputMasks:r,inputShapes:i,outputShapes:a},s);for(var f=0;f<e.length;f++)e[f].sourceLayer=this,e[f].nodeIndex=this.inboundNodes.length-1,e[f].tensorIndex=f},n.prototype.getConfig=function(){var t={name:this.name,trainable:this.trainable};return null!=this.batchInputShape&&(t.batchInputShape=this.batchInputShape),null!=this.dtype&&(t.dtype=this.dtype),t},n.prototype.disposeWeights=function(){return this.weights.forEach((function(t){return t.dispose()})),this.weights.length},n.prototype.assertNotDisposed=function(){if(0===this._refCount)throw new Error("Layer '"+this.name+"' is already disposed.")},n.prototype.dispose=function(){if(!this.built)throw new Error("Cannot dispose Layer "+this.name+" because it has not been built yet.");if(null===this._refCount)throw new Error("Cannot dispose Layer "+this.name+" because it has not been used yet.");this.assertNotDisposed();var t=0;return 0==--this._refCount&&(t=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:t}},n}(e.serialization.Serializable);function Ns(t,e,n){if((null==e||null!=n&&n>0)&&(e=t.sourceLayer,n=t.nodeIndex),0===e.inboundNodes.length)return[t];var r=e.inboundNodes[n];if(0===r.inboundLayers.length)return r.inputTensors;for(var i=[],a=0;a<r.inboundLayers.length;a++)for(var s=0,o=Ns(r.inputTensors[a],r.inboundLayers[a],r.nodeIndices[a]);s<o.length;s++){var u=o[s];-1===i.indexOf(u)&&i.push(u)}return i}var xs,zs=function(t){function e(e){var n=t.call(this,{dtype:e.dtype,name:null!=e.name?e.name:os("input").toString()})||this;if(null==e.batchSize&&(e.batchSize=null),null==e.sparse&&(e.sparse=!1),n.trainable=!1,n.built=!0,n.sparse=e.sparse,null!=e.inputShape&&null!=e.batchInputShape)throw new ki("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");var r=e.batchInputShape;if(null==r){if(null==e.inputShape)throw new ki("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");r=[e.batchSize].concat(e.inputShape)}else if(null!=e.batchSize)throw new ki("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");var i=e.dtype||"float32";n.batchInputShape=r,n.dtype=i,n.inputSpec=[{shape:r}];var a=new vs(n.dtype,n.batchInputShape,n,[],{},n.name);return a.nodeIndex=0,a.tensorIndex=0,new ws({outboundLayer:n,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[a],outputTensors:[a],inputMasks:[null],outputMasks:[null],inputShapes:[r],outputShapes:[r]}),n}return di(e,t),e.prototype.apply=function(t,e){throw new ki("Cannot pass any input to an InputLayer's apply() method. InputLayer name: "+this.name)},e.prototype.dispose=function(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}},e.prototype.getConfig=function(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}},e.className="InputLayer",e}(Ss);function Is(t){if(null==t.batchShape&&null==t.shape)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(null!=t.batchShape&&null!=t.shape)throw new ki("Please provide either a `shape` or `batchShape` argument to Input, but not both.");var e=t.batchShape;null!=t.shape&&null==e&&(e=[null].concat(t.shape));var n=t.dtype;return null==n&&(n="float32"),new zs({batchInputShape:e,name:t.name,dtype:n,sparse:t.sparse}).inboundNodes[0].outputTensors[0]}function As(t){return mi(this,void 0,void 0,(function(){var n,r,i,a,s,o,u,l;return yi(this,(function(c){switch(c.label){case 0:if(null==t)return[2];for(a in n=[],r=[],i=[],t)"number"!=typeof(s=t[a])&&(o=s,n.push(o.data()),r.push(a),i.push(o));return n.length>0?[4,Promise.all(n)]:[3,2];case 1:for(u=c.sent(),l=0;l<u.length;++l)t[r[l]]=u[l][0];e.dispose(i),c.label=2;case 2:return[2]}}))}))}function Cs(t){if(null!=t)for(var e in t){var n=t[e];"number"!=typeof n&&n.dispose()}}e.serialization.registerClass(zs),function(t){t[t.SILENT=0]="SILENT",t[t.VERBOSE=1]="VERBOSE"}(xs||(xs={}));var Ts=function(){function t(){this.validationData=null}return t.prototype.setParams=function(t){this.params=t},t.prototype.onEpochBegin=function(t,e){return mi(this,void 0,void 0,(function(){return yi(this,(function(t){return[2]}))}))},t.prototype.onEpochEnd=function(t,e){return mi(this,void 0,void 0,(function(){return yi(this,(function(t){return[2]}))}))},t.prototype.onBatchBegin=function(t,e){return mi(this,void 0,void 0,(function(){return yi(this,(function(t){return[2]}))}))},t.prototype.onBatchEnd=function(t,e){return mi(this,void 0,void 0,(function(){return yi(this,(function(t){return[2]}))}))},t.prototype.onTrainBegin=function(t){return mi(this,void 0,void 0,(function(){return yi(this,(function(t){return[2]}))}))},t.prototype.onTrainEnd=function(t){return mi(this,void 0,void 0,(function(){return yi(this,(function(t){return[2]}))}))},t.prototype.setModel=function(t){},t}(),Es=function(){function t(t,e){void 0===e&&(e=10),null==t&&(t=[]),this.callbacks=t,this.queueLength=e}return t.prototype.append=function(t){this.callbacks.push(t)},t.prototype.setParams=function(t){for(var e=0,n=this.callbacks;e<n.length;e++){n[e].setParams(t)}},t.prototype.setModel=function(t){for(var e=0,n=this.callbacks;e<n.length;e++){n[e].setModel(t)}},t.prototype.onEpochBegin=function(t,e){return mi(this,void 0,void 0,(function(){var n,r;return yi(this,(function(i){switch(i.label){case 0:null==e&&(e={}),n=0,r=this.callbacks,i.label=1;case 1:return n<r.length?[4,r[n].onEpochBegin(t,e)]:[3,4];case 2:i.sent(),i.label=3;case 3:return n++,[3,1];case 4:return[2]}}))}))},t.prototype.onEpochEnd=function(t,e){return mi(this,void 0,void 0,(function(){var n,r;return yi(this,(function(i){switch(i.label){case 0:null==e&&(e={}),n=0,r=this.callbacks,i.label=1;case 1:return n<r.length?[4,r[n].onEpochEnd(t,e)]:[3,4];case 2:i.sent(),i.label=3;case 3:return n++,[3,1];case 4:return[2]}}))}))},t.prototype.onBatchBegin=function(t,e){return mi(this,void 0,void 0,(function(){var n,r;return yi(this,(function(i){switch(i.label){case 0:null==e&&(e={}),n=0,r=this.callbacks,i.label=1;case 1:return n<r.length?[4,r[n].onBatchBegin(t,e)]:[3,4];case 2:i.sent(),i.label=3;case 3:return n++,[3,1];case 4:return[2]}}))}))},t.prototype.onBatchEnd=function(t,e){return mi(this,void 0,void 0,(function(){var n,r;return yi(this,(function(i){switch(i.label){case 0:null==e&&(e={}),n=0,r=this.callbacks,i.label=1;case 1:return n<r.length?[4,r[n].onBatchEnd(t,e)]:[3,4];case 2:i.sent(),i.label=3;case 3:return n++,[3,1];case 4:return[2]}}))}))},t.prototype.onTrainBegin=function(t){return mi(this,void 0,void 0,(function(){var e,n;return yi(this,(function(r){switch(r.label){case 0:null==t&&(t={}),e=0,n=this.callbacks,r.label=1;case 1:return e<n.length?[4,n[e].onTrainBegin(t)]:[3,4];case 2:r.sent(),r.label=3;case 3:return e++,[3,1];case 4:return[2]}}))}))},t.prototype.onTrainEnd=function(t){return mi(this,void 0,void 0,(function(){var e,n;return yi(this,(function(r){switch(r.label){case 0:null==t&&(t={}),e=0,n=this.callbacks,r.label=1;case 1:return e<n.length?[4,n[e].onTrainEnd(t)]:[3,4];case 2:r.sent(),r.label=3;case 3:return e++,[3,1];case 4:return[2]}}))}))},t}(),Fs=function(t){function n(){return t.call(this)||this}return di(n,t),n.prototype.onEpochBegin=function(t){return mi(this,void 0,void 0,(function(){return yi(this,(function(t){return this.seen=0,this.totals={},[2]}))}))},n.prototype.onBatchEnd=function(t,n){return mi(this,void 0,void 0,(function(){var t,r,i,a,s=this;return yi(this,(function(o){for(a in null==n&&(n={}),t=null==n.size?0:n.size,this.seen+=t,r=function(r){var a=n[r];if("number"==typeof a)i.totals.hasOwnProperty(r)||(i.totals[r]=0),i.totals[r]=i.totals[r]+a*t;else{var o=void 0;r in i.totals?o=i.totals[r]:i.totals[r]=0;var u=e.tidy((function(){return e.add(s.totals[r],e.mul(a,t))}));i.totals[r]=u,null!=o&&o.dispose()}},i=this,n)r(a);return[2]}))}))},n.prototype.onEpochEnd=function(t,n){return mi(this,void 0,void 0,(function(){var t,r,i,a,s,o=this;return yi(this,(function(u){if(null!=n)for(t=function(t){if(null==r.totals[t])return"continue";"number"==typeof r.totals[t]?n[t]=r.totals[t]/r.seen:e.tidy((function(){var r=e.mul(e.div(1,o.seen),o.totals[t]);n[t]=r,o.totals[t].dispose(),e.keep(n[t])}))},r=this,i=0,a=this.params.metrics;i<a.length;i++)s=a[i],t(s);return[2]}))}))},n}(Ts),Ds=function(t){function e(){return null!==t&&t.apply(this,arguments)||this}return di(e,t),e.prototype.onTrainBegin=function(t){return mi(this,void 0,void 0,(function(){return yi(this,(function(t){return this.epoch=[],this.history={},[2]}))}))},e.prototype.onEpochEnd=function(t,e){return mi(this,void 0,void 0,(function(){var n;return yi(this,(function(r){for(n in null==e&&(e={}),this.epoch.push(t),e)null==this.history[n]&&(this.history[n]=[]),this.history[n].push(e[n]);return[2]}))}))},e.prototype.syncData=function(){return mi(this,void 0,void 0,(function(){var t,e,n,r,i,a,s,o,u;return yi(this,(function(l){switch(l.label){case 0:for(r in t=[],e=[],n=[],this.history)for(i=this.history[r],a=0;a<i.length;++a)"number"!=typeof i[a]&&(s=i[a],t.push(s.data()),e.push(r),n.push(a));return[4,Promise.all(t)];case 1:for(o=l.sent(),u=0;u<o.length;++u)this.history[e[u]][n[u]].dispose(),this.history[e[u]][n[u]]=o[u][0];return[2]}}))}))},e}(Ts),Ls=function(t){function n(n,r){var i,a,s,o,u=t.call(this)||this;if(u.currentEpoch=0,u.yieldEvery=r||"auto","auto"===u.yieldEvery&&(u.yieldEvery=125),"never"===u.yieldEvery&&null!=n.onYield)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");return e.util.isNumber(u.yieldEvery)&&(u.maybeWait=(i=u.maybeWait.bind(u),a=u.yieldEvery,o=e.util.now(),function(){for(var t=[],n=0;n<arguments.length;n++)t[n]=arguments[n];var r=e.util.now();return r-o<a?s:(o=r,s=i.apply(void 0,t))})),u.trainBegin=n.onTrainBegin,u.trainEnd=n.onTrainEnd,u.epochBegin=n.onEpochBegin,u.epochEnd=n.onEpochEnd,u.batchBegin=n.onBatchBegin,u.batchEnd=n.onBatchEnd,u.yield=n.onYield,u}return di(n,t),n.prototype.maybeWait=function(t,n,r){return mi(this,void 0,void 0,(function(){var i;return yi(this,(function(a){switch(a.label){case 0:return i=[],null==this.yield?[3,2]:[4,As(r)];case 1:a.sent(),i.push(this.yield(t,n,r)),a.label=2;case 2:return i.push(e.nextFrame()),[4,Promise.all(i)];case 3:return a.sent(),[2]}}))}))},n.prototype.onEpochBegin=function(t,e){return mi(this,void 0,void 0,(function(){return yi(this,(function(n){switch(n.label){case 0:return this.currentEpoch=t,null==this.epochBegin?[3,3]:[4,As(e)];case 1:return n.sent(),[4,this.epochBegin(t,e)];case 2:n.sent(),n.label=3;case 3:return[2]}}))}))},n.prototype.onEpochEnd=function(t,n){return mi(this,void 0,void 0,(function(){var r;return yi(this,(function(i){switch(i.label){case 0:return r=[],null==this.epochEnd?[3,2]:[4,As(n)];case 1:i.sent(),r.push(this.epochEnd(t,n)),i.label=2;case 2:return"epoch"===this.yieldEvery&&r.push(e.nextFrame()),[4,Promise.all(r)];case 3:return i.sent(),[2]}}))}))},n.prototype.onBatchBegin=function(t,e){return mi(this,void 0,void 0,(function(){return yi(this,(function(n){switch(n.label){case 0:return null==this.batchBegin?[3,3]:[4,As(e)];case 1:return n.sent(),[4,this.batchBegin(t,e)];case 2:n.sent(),n.label=3;case 3:return[2]}}))}))},n.prototype.onBatchEnd=function(t,n){return mi(this,void 0,void 0,(function(){var r;return yi(this,(function(i){switch(i.label){case 0:return r=[],null==this.batchEnd?[3,2]:[4,As(n)];case 1:i.sent(),r.push(this.batchEnd(t,n)),i.label=2;case 2:return"batch"===this.yieldEvery?r.push(e.nextFrame()):e.util.isNumber(this.yieldEvery)&&r.push(this.maybeWait(this.currentEpoch,t,n)),[4,Promise.all(r)];case 3:return i.sent(),[2]}}))}))},n.prototype.onTrainBegin=function(t){return mi(this,void 0,void 0,(function(){return yi(this,(function(e){switch(e.label){case 0:return null==this.trainBegin?[3,3]:[4,As(t)];case 1:return e.sent(),[4,this.trainBegin(t)];case 2:e.sent(),e.label=3;case 3:return[2]}}))}))},n.prototype.onTrainEnd=function(t){return mi(this,void 0,void 0,(function(){return yi(this,(function(e){switch(e.label){case 0:return null==this.trainEnd?[3,3]:[4,As(t)];case 1:return e.sent(),[4,this.trainEnd(t)];case 2:e.sent(),e.label=3;case 3:return[2]}}))}))},n}(Ts);function _s(t,e){return null==t&&(t={}),t instanceof Ts?[t]:Array.isArray(t)&&t[0]instanceof Ts?t:Ci(t).map((function(t){return new Ls(t,e)}))}var Rs=function(){function t(){}return t.registerCallbackConstructor=function(n,r){e.util.assert(n>=0&&Number.isInteger(n),(function(){return"Verbosity level is expected to be an integer >= 0, but got "+n})),t.checkForDuplicate(r),null==t.constructors[n]&&(t.constructors[n]=[]),t.constructors[n].push(r)},t.checkForDuplicate=function(e){for(var n in t.constructors){t.constructors[+n].forEach((function(t){if(t===e)throw new ki("Duplicate callback constructor.")}))}},t.clear=function(){t.constructors={}},t.createCallbacks=function(e){var n=[];for(var r in t.constructors){var i=+r;e>=i&&n.push.apply(n,t.constructors[i])}return n.map((function(t){return new t}))},t.constructors={},t}();function Os(t,e,n,r,i,a,s,o,u){var l=new Ds,c=[new Fs].concat(Rs.createCallbacks(e));null!=t&&c.push.apply(c,t),c.push(l);var h=new Es(c);return h.setParams({epochs:n,initialEpoch:r,samples:i,steps:a,batchSize:s,verbose:e,doValidation:o,metrics:u}),{callbackList:h,history:l}}function Ms(t,n,r){return void 0===n&&(n={}),void 0===r&&(r=!1),_i(t,e.serialization.SerializationMap.getMap().classNameMap,n,"layer",r)}function Bs(t,n){return e.tidy((function(){"float32"!==t.dtype&&(t=e.cast(t,"float32"));var r=e.sum(Ea(t),n,!0),i=e.fill(r.shape,vi()),a=e.sqrt(e.maximum(r,i));return e.div(t,a)}))}function Ps(t,n){return e.tidy((function(){return e.mean(Ea(e.sub(n,t)),-1)}))}function $s(t,n){return e.tidy((function(){return e.mean(e.abs(e.sub(n,t)),-1)}))}function Ws(t,n){return e.tidy((function(){var r=e.sub(t,n),i=e.clipByValue(e.abs(t),vi(),Number.MAX_VALUE),a=e.abs(e.div(r,i));return e.mul(100,e.mean(a,-1))}))}function Us(t,n,r){return void 0===r&&(r=!1),e.tidy((function(){if(r)n=e.softmax(n);else{var i=e.sum(n,n.shape.length-1,!0);n=e.div(n,i)}return n=e.clipByValue(n,vi(),1-vi()),e.neg(e.sum(e.mul(e.cast(t,"float32"),e.log(n)),n.shape.length-1))}))}function js(t,n,r){return void 0===r&&(r=!1),e.tidy((function(){var i,a,s=e.cast(e.floor((a=[ga((i=t).shape)],e.reshape(i,a))),"int32"),o=(n=e.clipByValue(n,vi(),1-vi())).shape;return Us(e.reshape(e.oneHot(s,o[o.length-1]),o),n,r)}))}function Vs(t,n){return e.tidy((function(){var r;return r=e.clipByValue(n,vi(),1-vi()),r=e.log(e.div(r,e.sub(1,r))),e.mean(function(t,n){if(!e.util.arraysEqual(t.shape,n.shape))throw new ki("logits and labels must have the same shape, but got shapes "+JSON.stringify(t.shape)+" and "+JSON.stringify(n.shape));return e.tidy((function(){var r=e.relu(n),i=e.neg(e.abs(n));return e.add(e.sub(r,e.mul(n,t)),e.log1p(e.exp(i)))}))}(t,r),-1)}))}function Ks(t,n){return e.tidy((function(){var r=Bs(t,-1),i=Bs(n,-1),a=e.mul(r,i);return e.neg(e.sum(a,-1))}))}var qs={meanSquaredError:Ps,meanAbsoluteError:$s,meanAbsolutePercentageError:Ws,meanSquaredLogarithmicError:function(t,n){return e.tidy((function(){var r=e.clipByValue(n,vi(),Number.MAX_VALUE),i=e.log(e.add(1,r)),a=e.clipByValue(t,vi(),Number.MAX_VALUE),s=e.log(e.add(1,a));return e.mean(Ea(e.sub(i,s)),-1)}))},squaredHinge:function(t,n){return e.tidy((function(){var r=e.maximum(0,e.sub(1,e.mul(t,n)));return e.mean(Ea(r),-1)}))},hinge:function(t,n){return e.tidy((function(){var r=e.maximum(0,e.sub(1,e.mul(t,n)));return e.mean(r,-1)}))},categoricalHinge:function(t,n){return e.tidy((function(){var r=e.sum(e.mul(t,n),-1),i=e.max(e.mul(e.sub(1,t),n),-1);return e.maximum(0,e.add(1,e.sub(i,r)))}))},logcosh:function(t,n){return e.tidy((function(){var r=Math.log(2),i=e.sub(n,t),a=e.sub(e.add(i,e.softplus(e.mul(-2,i))),r);return e.mean(a,-1)}))},categoricalCrossentropy:Us,sparseCategoricalCrossentropy:js,binaryCrossentropy:Vs,kullbackLeiblerDivergence:function(t,n){return e.tidy((function(){var r=e.clipByValue(t,vi(),1),i=e.clipByValue(n,vi(),1);return e.sum(e.mul(t,e.log(e.div(r,i))),-1)}))},poisson:function(t,n){return e.tidy((function(){var r=e.log(e.add(vi(),n));return e.mean(e.sub(n,e.mul(t,r)),-1)}))},cosineProximity:Ks};function Gs(t){if("string"==typeof t){if(t in qs)return qs[t];var e="Unknown loss "+t;throw t.toLowerCase().includes("softmaxcrossentropy")&&(e="Unknown loss "+t+'. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy'),new ki(e)}return t}function Hs(t,n){return e.tidy((function(){var r=e.mul(.5,e.onesLike(n)),i=ba(e.greater(n,r),t.dtype);return e.mean(e.equal(t,i),-1)}))}function Js(t,n){return e.tidy((function(){return ba(e.equal(e.argMax(t,-1),e.argMax(n,-1)),"float32")}))}function Zs(t,n){return e.tidy((function(){return e.cast(e.sum(e.logicalAnd(e.equal(t,1),e.equal(n,1))),"float32")}))}function Ys(t,n){return e.tidy((function(){var r=Zs(t,n),i=function(t,n){return e.tidy((function(){return e.cast(e.sum(e.logicalAnd(e.equal(t,0),e.equal(n,1))),"float32")}))}(t,n),a=e.add(r,i);return e.cast(e.where(e.greater(a,0),e.div(r,a),0),"float32")}))}function Xs(t,n){return e.tidy((function(){var r=Zs(t,n),i=function(t,n){return e.tidy((function(){return e.cast(e.sum(e.logicalAnd(e.equal(t,1),e.equal(n,0))),"float32")}))}(t,n),a=e.add(r,i);return e.cast(e.where(e.greater(a,0),e.div(r,a),0),"float32")}))}function Qs(t,e){return Vs(t,e)}function to(t,n){return t.rank===n.rank&&(t=e.squeeze(t,[t.rank-1])),(n=e.argMax(n,-1)).dtype!==t.dtype&&(n=e.cast(n,t.dtype)),e.cast(e.equal(t,n),"float32")}var eo=Us,no=js,ro={binaryAccuracy:Hs,categoricalAccuracy:Js,precision:Ys,categoricalCrossentropy:eo,sparseCategoricalCrossentropy:no,mse:Ps,MSE:Ps,mae:$s,MAE:$s,mape:Ws,MAPE:Ws,cosine:Ks};function io(t){if(zi(null!==t,"Unknown LossOrMetricFn "+t),"string"==typeof t)return t;for(var e=void 0,n=0,r=Object.keys(qs);n<r.length;n++){var i=r[n];if(qs[i]===t){e=i;break}}if(void 0!==e)return e;for(var a=0,s=Object.keys(ro);a<s.length;a++){i=s[a];if(ro[i]===t){e=i;break}}return void 0!==e?e:t.name}var ao=1048576;function so(t,e,n){if(void 0===n&&(n=!1),null==t||"object"!=typeof t||Object.getPrototypeOf(t)!==Object.prototype||!oo(t))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(n){var r=JSON.stringify(t);r.length>ao&&console.warn('User-defined metadata of model "'+e+'" is too large in size (length='+r.length+" when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= 1048576.")}}function oo(t){if(null===t)return!0;if("object"==typeof t){if(Object.getPrototypeOf(t)===Object.prototype){for(var e=0,n=Object.keys(t);e<n.length;e++){var r=n[e];if("string"!=typeof r)return!1;if(!oo(t[r]))return!1}return!0}if(Array.isArray(t)){for(var i=0,a=t;i<a.length;i++){if(!oo(a[i]))return!1}return!0}return!1}var s=typeof t;return"string"===s||"number"===s||"boolean"===s}function uo(t,e,n,r){void 0===r&&(r=console.log);var i,a=function(t){var e=!0,n=[],r=[];for(var i in t.nodesByDepth)n.push(t.nodesByDepth[i]);for(var a=0,s=n;a<s.length;a++){var o=s[a];if(o.length>1||1===o.length&&o[0].inboundLayers.length>1){e=!1;break}r.push.apply(r,o)}if(e)for(var u=0,l=t.layers;u<l.length;u++){for(var c=!1,h=0,p=l[u].inboundNodes;h<p.length;h++){var d=p[h];if(-1!==r.indexOf(d)){if(c){e=!1;break}c=!0}}if(!e)break}return e}(t),s=["Layer (type)","Output shape","Param #"];if(a?(e=e||65,n=n||[.45,.85,1]):(e=e||98,n=n||[.33,.55,.67,1]),n[n.length-1]<=1&&(n=n.map((function(t){return Math.floor(e*t)}))),!a)for(var o in s.push("Receives inputs"),i=[],t.nodesByDepth)i.push.apply(i,t.nodesByDepth[o]);r("_".repeat(e)),lo(s,n,r),r("=".repeat(e));for(var u=t.layers,l=0;l<u.length;++l)a?co(u[l],n,r):ho(u[l],n,i,r),r((l===u.length-1?"=":"_").repeat(e));t.checkTrainableWeightsConsistency();var c=function(t){var e;e=null!=t.collectedTrainableWeights?ps(t.collectedTrainableWeights):ps(t.trainableWeights);return e}(t),h=ps(t.nonTrainableWeights);r("Total params: "+(c+h)),r("Trainable params: "+c),r("Non-trainable params: "+h),r("_".repeat(e))}function lo(t,e,n){void 0===n&&(n=console.log);for(var r="",i=0;i<t.length;++i)i>0&&(r=r.slice(0,r.length-1)+" "),r=(r+=t[i]).slice(0,e[i]),r+=" ".repeat(e[i]-r.length);n(r)}function co(t,e,n){var r;try{r=JSON.stringify(t.outputShape)}catch(t){r="multiple"}lo([t.name+" ("+t.getClassName()+")",r,t.countParams().toString()],e,n)}function ho(t,e,n,r){var i;try{i=JSON.stringify(t.outputShape)}catch(t){i="multiple"}for(var a=[],s=0,o=t.inboundNodes;s<o.length;s++){var u=o[s];if(!(null!=n&&n.length>0&&-1===n.indexOf(u)))for(var l=0;l<u.inboundLayers.length;++l){var c=u.inboundLayers[l].name,h=u.nodeIndices[l],p=u.tensorIndices[l];a.push(c+"["+h+"]["+p+"]")}}var d=t.name,f=t.getClassName(),g=0===a.length?"":a[0];lo([d+" ("+f+")",i,t.countParams().toString(),g],e,r);for(l=1;l<a.length;++l)lo(["","","",a[l]],e,r)}function po(t,e,n){return("inboundNodes"===t||"outputLayers"===t||"inputLayers"===t)&&0===e&&"string"==typeof n}function fo(t,e){if(null===t)return null;if("string"==typeof t)return Ei(t);if("number"==typeof t||"boolean"==typeof t)return t;if(t instanceof Array){for(var n=[],r=t.length,i=0;i<r;++i){var a=t[i];po(e,i,a)?n.push(a):n.push(fo(a,e))}return n}for(var s={},o=0,u=Object.keys(t);o<u.length;o++){var l=u[o],c=t[l];if("name"===l&&"string"==typeof c)s[l]=c;else{var h=Ei(l);s[h]=fo(c,h)}}return s}function go(t,e){if(null==t)return null;if("string"==typeof t)return Ti(t);if("number"==typeof t||"boolean"==typeof t)return t;if(t instanceof Array){for(var n=[],r=t.length,i=0;i<r;++i){var a=t[i];po(e,i,a)?n.push(a):n.push(go(a,e))}return n}for(var s={},o=0,u=Object.keys(t);o<u.length;o++){var l=u[o],c=t[l],h=Ti(l);s[h]="name"!==l&&"className"!==l||"string"!=typeof c?go(c,l):c}return s}var mo="3.8.0";var yo=function(){function t(e){if(this.id2Value={},this.id2Mask={},this.name2Id={},e instanceof t)for(var n in e.id2Value)this.id2Value[n]=e.id2Value[n],n in e.id2Mask&&(this.id2Mask[n]=e.id2Mask[n]);else{if(null==e)return;for(var r=0,i=e;r<i.length;r++){var a=i[r];this.add(a.key,a.value)}}}return t.prototype.add=function(t,n,r){if(null!=this.id2Value[t.id])throw new ki("Duplicate key: name="+t.name+", id="+t.id);return this.id2Value[t.id]=function(t,n){if(null==t.dtype||t.dtype===n.dtype)return n;try{return e.cast(n,t.dtype)}catch(e){throw new ki("The dtype of the feed ("+n.dtype+") can not be cast to the dtype of the key '"+t.name+"' ("+t.dtype+").")}}(t,n),this.name2Id[t.name]=t.id,null!=r&&(this.id2Mask[t.id]=r),this},t.prototype.addFeed=function(t){this.add(t.key,t.value)},t.prototype.hasKey=function(t){return null!=this.id2Value[t.id]},t.prototype.names=function(){return Object.keys(this.name2Id)},t.prototype.getValue=function(t){if(t instanceof vs){if(null==this.id2Value[t.id])throw new ki("Nonexistent key: "+t.name);return this.id2Value[t.id]}var e=this.name2Id[t];if(null==e)throw new ki("Feed dict has no SymbolicTensor name: "+t);return this.id2Value[e]},t.prototype.getMask=function(t){if(t instanceof vs){if(null==this.id2Value[t.id])throw new ki("Nonexistent key: "+t.name);return this.id2Mask[t.id]}var e=this.name2Id[t];if(null==e)throw new ki("Feed dict has no SymbolicTensor name: "+t);return this.id2Mask[e]},t.prototype.disposeMasks=function(){null!=this.id2Mask&&e.dispose(this.id2Mask)},t}(),vo={},bo={};function wo(t,n,r,i){for(var a=null!=r&&r.training,s=Array.isArray(t),o=s?t:[t],u=o.map((function(t){return t.name})),l=[],c=n.names(),h=0,p=u;h<p.length;h++){var d=p[h];-1!==c.indexOf(d)?l.push(n.getValue(d)):l.push(null)}null!=i&&(i.maxNumTensors=-1/0,i.minNumTensors=1/0);var f,g,m=u.join(",")+"|"+n.names().join(",");if(null==vo[m]){var y=function(t,n){e.util.assert(null!=t&&t.length>0,(function(){return"Expected at least one fetch, got none"}));var r=[],i={};if(1===t.length){var a=So(t[0],n);r=a.sorted,i=a.recipientMap}else for(var s=new Set,o=0,u=t;o<u.length;o++){for(var l=So(u[o],n),c=l.sorted,h=l.recipientMap,p=0,d=c;p<d.length;p++){var f=d[p];s.has(f.name)||(r.push(f),s.add(f.name))}var g=function(t){null==i[t]&&(i[t]=new Set),h[t].forEach((function(e){return i[t].add(e)}))};for(var m in h)g(m)}return{sorted:r,recipientCounts:ko(i)}}(o,n);f=y.sorted,g=y.recipientCounts,vo[m]=f,bo[m]=g}f=vo[m],g={},a||Object.assign(g,bo[m]);for(var v=new yo(n),b=0;b<f.length;++b){if(null!=i){var w=e.memory().numTensors;w>i.maxNumTensors&&(i.maxNumTensors=w),w<i.minNumTensors&&(i.minNumTensors=w)}var k=f[b],S=k.sourceLayer;if(!(S instanceof zs)){for(var N=[],x=[],z=[],I=!1,A=0,C=k.inputs;A<C.length;A++){var T=C[A],E=v.getValue(T),F=v.getMask(T);N.push(E),x.push(F),null!=F&&(I=!0),a||(g[T.name]--,0!==g[T.name]||n.hasKey(T)||-1!==u.indexOf(T.name)||E.isDisposed||!0===T.sourceLayer.stateful||z.push(E))}I&&((r=r||{}).mask=x[0]);var D=Ci(S.apply(N,r)),L=null;S.supportsMasking&&(L=S.computeMask(N,x));for(var _=No(k),R=Array.isArray(_)?_:[_],O=0;O<R.length;++O){v.hasKey(R[O])||v.add(R[O],D[O],Array.isArray(L)?L[0]:L);var M=u.indexOf(R[O].name);-1!==M&&(l[M]=D[O])}a||e.dispose(z)}}return v.disposeMasks(),s?l:l[0]}function ko(t){var e={};for(var n in t)e[n]=t[n].size;return e}function So(t,e){for(var n=new Set,r=[],i={},a=0,s=e.names();a<s.length;a++){var o=s[a];n.add(o)}var u=[],l=[];for(u.push(t);u.length>0;){var c=u[u.length-1];if(n.has(c.name))u.pop();else{var h=l[l.length-1]===u.length-1;if(0===c.inputs.length||h)u.pop(),r.push(c),n.add(c.name),h&&l.pop();else{l.push(u.length-1);for(var p=0,d=c.inputs;p<d.length;p++){var f=d[p];null==i[f.name]&&(i[f.name]=new Set),i[f.name].add(c.name),n.has(f.name)||u.push(f)}}}}return{sorted:r,recipientMap:i}}function No(t){var e;if(1===t.sourceLayer.inboundNodes.length)e=t.sourceLayer.output;else{for(var n=null,r=0;r<t.sourceLayer.inboundNodes.length;++r)for(var i=0,a=t.sourceLayer.inboundNodes[r].outputTensors;i<a.length;i++){if(a[i].id===t.id){n=r;break}}e=t.sourceLayer.getOutputAt(n)}return e}var xo=function(t){function n(e){var r=t.call(this,{})||this;if(r.containerNodes=new Set,r.name=e.name,null==r.name){var i=r.getClassName().toLowerCase();r.name=os(i)}if(r.supportsMasking=!1,r.trainable_=!0,Array.isArray(e.inputs)?r.inputs=e.inputs.slice():r.inputs=[e.inputs],Array.isArray(e.outputs)?r.outputs=e.outputs.slice():r.outputs=[e.outputs],Oi(r.inputs).length!==r.inputs.length)throw new ki("The list of inputs passed to the model is redundant. All inputs should only appear once. Found: "+r.inputs.map((function(t){return t.name})));Oi(r.outputs).length!==r.outputs.length&&console.warn("The list of outputs passed to the model is redundant. All outputs should only appear once. Found: "+r.outputs.map((function(t){return t.name}))),r.inputLayers=[],r.inputLayersNodeIndices=[],r.inputLayersTensorIndices=[],r.outputLayers=[],r.outputLayersNodeIndices=[],r.outputLayersTensorIndices=[],r.layers=[],r.internalContainerRefs=[];for(var a=0,s=r.outputs;a<s.length;a++){var o=(I=s[a]).sourceLayer,u=I.nodeIndex,l=I.tensorIndex;r.outputLayers.push(o),r.outputLayersNodeIndices.push(u),r.outputLayersTensorIndices.push(l)}for(var c=0,h=r.inputs;c<h.length;c++){o=(I=h[c]).sourceLayer,u=I.nodeIndex,l=I.tensorIndex;zi(0===u,"input layer has >1 nodes"),zi(0===l,"input layer has >1 tensors"),r.inputLayers.push(o),r.inputLayersNodeIndices.push(u),r.inputLayersTensorIndices.push(l)}r.inputNames=[],r.outputNames=[],r.feedInputShapes=[],r.feedInputNames=[],r.feedOutputNames=[];for(var p=0;p<r.inputLayers.length;p++){if(!((o=r.inputLayers[p])instanceof zs))throw new TypeError("Input layers to a LayersModel must be InputLayer objects. Received inputs: "+e.inputs+". Input "+p+" (0-based) originates from layer type "+o.getClassName()+".");r.inputNames.push(o.name),r.feedInputShapes.push(o.batchInputShape),r.feedInputNames.push(o.name)}for(var d=0,f=r.outputLayers;d<f.length;d++){o=f[d];r.outputNames.push(o.name)}r.internalInputShapes=r.inputs.map((function(t){return t.shape})),r.internalOutputShapes=r.outputs.map((function(t){return t.shape}));for(var g={},m={},y={},v={},b={},w=[],k=function(t,e,i,a,s,o){null!=a&&null!=s&&null!=o||(a=t.sourceLayer,s=t.nodeIndex,o=t.tensorIndex);var u=a.inboundNodes[s];if(-1!==i.indexOf(u))throw new wi("The tensor "+t.name+' at layer "'+a.name+'" is part of a cycle.');if(-1===e.indexOf(u)){r.containerNodes.add(n.nodeKey(a,s)),a.id in b||(b[a.id]=Object.keys(b).length),-1===i.indexOf(u)&&i.push(u);for(var l=u.inboundLayers.length,c=0;c<l;c++){var h=u.inputTensors[c],p=u.inboundLayers[c],d=u.nodeIndices[c],f=u.tensorIndices[c];k(h,e,i,p,d,f)}for(e.push(u);i.indexOf(u)>=0;)i.splice(i.indexOf(u),1);w.push(u)}},S=[],N=[],x=0,z=r.outputs;x<z.length;x++){var I=z[x];k(I,S,N)}for(var A=0,C=w.slice().reverse();A<C.length;A++){m[(Z=C[A]).id]=Z,Z.id in g||(g[Z.id]=0);var T=g[Z.id],E=null==y[Z.outboundLayer.id]?0:y[Z.outboundLayer.id];T=Math.max(T,E),y[Z.outboundLayer.id]=T,v[Z.outboundLayer.id]=Z.outboundLayer,g[Z.id]=T;for(p=0;p<Z.inboundLayers.length;p++){var F=Z.inboundLayers[p],D=(u=Z.nodeIndices[p],F.inboundNodes[u]),L=null==g[D.id]?0:g[D.id];g[D.id]=Math.max(T+1,L),m[D.id]=D}}var _={};for(var R in g){(T=g[R])in _||(_[T]=[]),_[T].push(m[R])}var O={};for(var M in y){(T=y[M])in O||(O[T]=[]),O[T].push(v[M])}var B=Object.keys(O).map((function(t){return parseInt(t,10)})).sort(Ri);r.layers=[];for(var P=0,$=B;P<$.length;P++){var W=O[T=$[P]];W.sort((function(t,e){var n=b[t.id],r=b[e.id];return n<r?-1:n>r?1:0}));for(var U=0,j=W;U<j.length;U++){(o=j[U])instanceof n&&r.internalContainerRefs.push(o),r.layers.push(o)}}r.layersByDepth=O,B=Object.keys(_).map((function(t){return parseInt(t,10)})).sort(Ri);for(var V=r.inputs.slice(),K=[],q=0,G=B;q<G.length;q++)for(var H=0,J=_[T=G[q]];H<J.length;H++){var Z;if(null!=(o=(Z=J[H]).outboundLayer)){for(var Y=0,X=Z.inputTensors;Y<X.length;Y++){I=X[Y];if(-1===V.indexOf(I))throw new wi("Graph disconnected: cannot obtain value for tensor "+I+' at layer "'+o.name+'". The following previous layers were accessed without issue: '+K)}for(var Q=0,tt=Z.outputTensors;Q<tt.length;Q++){I=tt[Q];V.push(I)}K.push(o.name)}}r.nodesByDepth=_;for(var et=r.layers.map((function(t){return t.name})),nt=function(t){var e=et.filter((function(e){return e===t})).length;if(1!==e)throw new wi('The name "'+t+'" is used '+e+" times in the model. All layer names should be unique. Layer names: "+JSON.stringify(et))},rt=0,it=et;rt<it.length;rt++){nt(it[rt])}return r.outboundNodes=[],r.inboundNodes=[],new ws({outboundLayer:r,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:r.inputs,outputTensors:r.outputs,inputMasks:r.inputs.map((function(t){return null})),outputMasks:r.outputs.map((function(t){return null})),inputShapes:r.inputs.map((function(t){return t.shape})),outputShapes:r.outputs.map((function(t){return t.shape}))}),r.built=!0,r._refCount=1,r}return di(n,t),n.prototype.assertNotDisposed=function(){if(0===this._refCount)throw new Error("Container '"+this.name+"' is already disposed.")},n.prototype.dispose=function(){this.assertNotDisposed();var t={refCountAfterDispose:null,numDisposedVariables:0};if(0==--this._refCount){for(var e=0,n=this.layers;e<n.length;e++){var r=n[e];t.numDisposedVariables+=r.dispose().numDisposedVariables}for(var i=0,a=this.internalContainerRefs;i<a.length;i++){var s=a[i];t.numDisposedVariables+=s.dispose().numDisposedVariables}}return t.refCountAfterDispose=this._refCount,t},Object.defineProperty(n.prototype,"trainable",{get:function(){return this.trainable_},set:function(t){this.layers.forEach((function(e){e._trainableWeights.forEach((function(e){return e.trainable=t}))})),this.trainable_=t},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"trainableWeights",{get:function(){if(this._trainableWeights.length>0)throw new ki("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];for(var t=[],e=0,n=this.layers;e<n.length;e++){var r=n[e];t=t.concat(r.trainableWeights)}return t},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"nonTrainableWeights",{get:function(){for(var t=[],e=0,n=this.layers;e<n.length;e++){var r=n[e];t.push.apply(t,r.nonTrainableWeights)}if(!this.trainable){for(var i=[],a=0,s=this.layers;a<s.length;a++){r=s[a];i.push.apply(i,r.trainableWeights)}return i.concat(t)}return t},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"weights",{get:function(){return this.trainableWeights.concat(this.nonTrainableWeights)},enumerable:!0,configurable:!0}),n.prototype.loadWeights=function(t,e){void 0===e&&(e=!0);for(var n={},r=0,i=0,a=this.layers;i<a.length;i++)for(var s=0,o=a[i].weights;s<o.length;s++){var u=o[s];if(null!=n[u.originalName])throw new ki("Duplicate weight name: "+u.originalName);n[u.originalName]=u,r++}var l=[];for(var c in t){var h=c;if(null==n[c]){var p=c.split("/");h=p.slice(0,-2).concat([p[p.length-1]]).join("/")}if(null!=n[h])l.push([n[h],t[c]]);else if(e)throw new ki("Provided weight data has no target variable: "+c);delete n[h]}if(e){var d=[];for(var f in n)d.push(f);if(d.length>0)throw new ki(d.length+" of "+r+" weights are not set: "+d)}ms(l)},n.prototype.updatedConfig=function(){var t=this.getConfig(),e={};return e.className=this.getClassName(),e.config=t,e.kerasVersion="tfjs-layers 3.8.0",e.backend="TensorFlow.js",e},n.prototype.toJSON=function(t,e){void 0===e&&(e=!0);var n=go(this.updatedConfig());return e?JSON.stringify(n):n},n.prototype.call=function(t,n){var r=this;return e.tidy((function(){t=Ci(t);for(var e=new yo,i=0;i<r.inputs.length;++i)e.add(r.inputs[i],t[i]);return wo(r.outputs,e,n)}))},n.prototype.computeMask=function(t,n){var r=this;return e.tidy((function(){var e;return t=Ci(t),e=null==n?xi(null,t.length):Ci(n),r.runInternalGraph(t,e)[1]}))},n.prototype.computeOutputShape=function(t){var e=ls(t);if(e.length!==this.inputLayers.length)throw new ki("Invalid inputShape argument "+t+": model has "+this.inputLayers.length+" tensor inputs.");for(var n={},r=0;r<e.length;r++){var i=this.inputLayers[r],a=e[r];n[N=i.name+"_0_0"]=a}var s=Object.keys(this.nodesByDepth).map((function(t){return parseInt(t,10)})).sort(Ri);if(s.length>1)for(var o=0,u=s;o<u.length;o++)for(var l=u[o],c=0,h=this.nodesByDepth[l];c<h.length;c++){var p=h[c];i=p.outboundLayer;if(-1===this.inputLayers.map((function(t){return t.id})).indexOf(i.id)){for(var d=[],f=0;f<p.inboundLayers.length;f++){var g=p.inboundLayers[f],m=p.nodeIndices[f],y=p.tensorIndices[f],v=n[N=g.name+"_"+m+"_"+y];d.push(v)}var b=ls(i.computeOutputShape(Ai(d))),w=i.inboundNodes.indexOf(p);for(f=0;f<b.length;f++){n[N=i.name+"_"+w+"_"+f]=b[f]}}}var k=[],S=[];for(r=0;r<this.outputLayers.length;r++){i=this.outputLayers[r],w=this.outputLayersNodeIndices[r],y=this.outputLayersTensorIndices[r];var N=i.name+"_"+w+"_"+y;S.push(N)}for(r=0;r<S.length;r++){var x=S[r];zi(x in n),k.push(n[x])}return Ai(k)},n.prototype.runInternalGraph=function(t,e){null==e&&(e=xi(null,t.length));for(var n={},r=0;r<this.inputs.length;++r){var i=this.inputs[r],a=t[r],s=e[r];n[i.id]=[a,s]}for(var o=0,u=Object.keys(this.nodesByDepth).map((function(t){return parseInt(t,10)})).sort(Ri);o<u.length;o++)for(var l=u[o],c=0,h=this.nodesByDepth[l];c<h.length;c++){for(var p=h[c],d=p.outboundLayer,f=p.inputTensors,g=p.outputTensors,m=new Array,y=0,v=f;y<v.length;y++){(i=v[y]).id in n&&m.push(n[i.id])}if(m.length===f.length){var b={},w=void 0,k=void 0,S=void 0,N=void 0;if(null!=p.callArgs&&(b=p.callArgs),1===m.length){var x=m[0],z=x[0],I=x[1];null==b.mask&&(b.mask=I),S=Ci(d.call(z,b)),N=Ci(d.computeMask(z,I)),w=[z],k=[I]}else w=m.map((function(t){return t[0]})),k=m.map((function(t){return t[1]})),null==b.mask&&(b.mask=k),S=Ci(d.call(w,b)),N=Ci(d.computeMask(w,k));if(d.activityRegularizer)throw new Si("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(r=0;r<g.length;++r){i=g[r],a=S[r],s=N[r];n[i.id]=[a,s]}}}for(var A=[],C=[],T=[],E=0,F=this.outputs;E<F.length;E++){zi((i=F[E]).id in n,"Could not compute output "+i.name+" : "+i.id);var D=n[i.id],L=D[0];s=D[1];T.push(L.shape),A.push(L),C.push(s)}return[A,C,T]},n.prototype.buildNodeConversionMap=function(t){for(var e,r={},i=0,a=this.layers;i<a.length;i++){var s=a[i];e=s instanceof n?1:0;for(var o=0;o<s.inboundNodes.length;o++){var u=n.nodeKey(s,o);this.containerNodes.has(u)&&(r[u]=e,e+=1)}}return r},n.prototype.getLayer=function(t,e){if(null!=e){if(this.layers.length<=e)throw new ki("Was asked to retrieve layer at index "+e+", but model only has "+this.layers.length+" layer(s).");return this.layers[e]}if(null==t)throw new ki("Provide either a layer name or layer index");for(var n=0,r=this.layers;n<r.length;n++){var i=r[n];if(i.name===t)return i}throw new ki("No such layer: "+t)},n.prototype.calculateLosses=function(){var t=this;return e.tidy((function(){for(var e=[],r=0,i=t.layers;r<i.length;r++)for(var a=i[r],s=0;s<a.inboundNodes.length;++s){var o=n.nodeKey(a,s);t.containerNodes.has(o)&&e.push.apply(e,a.calculateLosses())}return e}))},n.prototype.getConfig=function(){for(var t={name:this.name},e=this.buildNodeConversionMap(this.layers),r=[],i=0,a=this.layers;i<a.length;i++){for(var s=(w=a[i]).getClassName(),o=w.getConfig(),u=[],l=0;l<w.inboundNodes.length;l++){var c=w.inboundNodes[l],h=n.nodeKey(w,l),p={};if(this.containerNodes.has(h)){if(c.callArgs)try{JSON.stringify(c.callArgs),p=c.callArgs}catch(t){console.warn("Layer "+w.name+" was passed non-serializable keyword arguments: "+c.callArgs+". They will not be included in the serialized model (and thus will be missing at deserialization time)."),p={}}if(c.inboundLayers.length>0){for(var d=[],f=0;f<c.inboundLayers.length;f++){var g=c.inboundLayers[f],m=c.nodeIndices[f],y=c.tensorIndices[f];null==(S=e[n.nodeKey(g,m)])&&(S=0),d.push([g.name,S,y,p])}u.push(d)}}}var v={};v.name=w.name,v.className=s,v.config=o,v.inboundNodes=u,r.push(v)}t.layers=r;var b=[];for(f=0;f<this.inputLayers.length;f++){var w=this.inputLayers[f];m=this.inputLayersNodeIndices[f],h=n.nodeKey(w,m);if(this.containerNodes.has(h)){null==(S=e[h])&&(S=0);y=this.inputLayersTensorIndices[f];b.push([w.name,S,y])}}t.inputLayers=b;var k=[];for(f=0;f<this.outputLayers.length;f++){w=this.outputLayers[f],m=this.outputLayersNodeIndices[f],h=n.nodeKey(w,m);if(this.containerNodes.has(h)){var S;null==(S=e[h])&&(S=0);y=this.outputLayersTensorIndices[f];k.push([w.name,S,y])}}return t.outputLayers=k,t},n.fromConfig=function(t,e,n,r){void 0===r&&(r=!1);var i={},a={};function s(t,e){t.name in a?a[t.name].push(e):a[t.name]=[e]}function o(t,e){for(var n,r=[],a=0,o=e;a<o.length;a++){var u=o[a],l=u[0],c=u[1],h=u[2];if(n=null==u[3]?{}:u[3],!(l in i))return void s(t,e);var p=i[l];if(p.inboundNodes.length<=c)return void s(t,e);var d=p.inboundNodes[c];r.push(d.outputTensors[h])}r.length>0&&t.apply(Ai(r),n)}function u(t){var n=t.name,a=Ms(t,null!=e.customObjects?e.customObjects:{});a.setFastWeightInitDuringBuild(r),i[n]=a,t.inboundNodes.forEach((function(t){if(!(t instanceof Array))throw new ki("Corrupted configuration, expected array for nodeData: "+t);s(a,t)}))}for(var l=e.name,c=e.layers,h=0,p=c;h<p.length;h++){u(g=p[h])}for(;!Mi(a);)for(var d=0,f=c;d<f.length;d++){var g=f[d];if((T=i[g.name]).name in a){var m=a[T.name];delete a[T.name];for(var y=0,v=m;y<v.length;y++){o(T,v[y])}}}for(var b=[],w=[],k=0,S=e.inputLayers;k<S.length;k++){var N=(g=S[k])[0],x=g[1],z=g[2];zi(N in i);var I=(T=i[N]).inboundNodes[x].outputTensors;b.push(I[z])}for(var A=0,C=e.outputLayers;A<C.length;A++){N=(g=C[A])[0],x=g[1],z=g[2];zi(N in i);var T;I=(T=i[N]).inboundNodes[x].outputTensors;w.push(I[z])}return new t({inputs:b,outputs:w,name:l})},Object.defineProperty(n.prototype,"stateful",{get:function(){if(this._stateful)throw new ki("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(var t=0,e=this.layers;t<e.length;t++){if(e[t].stateful)return!0}return!1},enumerable:!0,configurable:!0}),n.prototype.resetStates=function(){var t=this;e.tidy((function(){t.layers.forEach((function(t){t.stateful&&t.resetStates()}))}))},n}(Ss);function zo(t,e){return function(t,e,n){var r=e.length;if(null==t||Array.isArray(t)&&0===t.length)return e.map((function(t){return null}));if(1===r)return Array.isArray(t)&&1===t.length?t:"object"==typeof t&&e[0]in t?[t[e[0]]]:[t];if(Array.isArray(t)){if(t.length!==r)throw new Error("Provided "+n+" is an array of "+t.length+" element(s), but the model has "+r+" outputs. Make sure a set of weights is provided for each model output.");return t}if("object"==typeof t&&Object.keys(t).length>0&&"object"==typeof t[Object.keys(t)[0]]){var i=[];return e.forEach((function(e){e in t?i.push(t[e]):i.push(null)})),i}throw new Error("The model has multiple ("+r+") outputs, so "+n+" must be either an array with "+r+" elements or an object with "+e+" keys. Provided "+n+" not understood: "+JSON.stringify(t))}(t,e,"classWeight")}function Io(t,n,r,i){return mi(this,void 0,void 0,(function(){var a,s,o,u,l;return yi(this,(function(c){switch(c.label){case 0:if(null!=n||null!=i)throw new Error("Support sampleWeight is not implemented yet");return null==r?[3,2]:(a=e.tidy((function(){if(1===t.shape.length)return e.clone(t);if(2===t.shape.length){if(t.shape[1]>1){return e.argMax(t,1)}if(1===t.shape[1])return e.reshape(t,[t.shape[0]]);throw new Error("Encountered unexpected last-dimension size ("+t.shape[1]+") during handling of class weights. The size is expected to be >= 1.")}throw new Error("Unexpected rank of target (y) tensor ("+t.rank+") during handling of class weights. The rank is expected to be 1 or 2.")})),u=(o=Array).from,[4,a.data()]);case 1:return s=u.apply(o,[c.sent()]),e.dispose(a),l=[],s.forEach((function(t){if(null==r[t])throw new Error("classWeight must contain all classes in the training data. The class "+t+" exists in the data but not in classWeight");l.push(r[t])})),[2,e.tensor1d(l,"float32")];case 2:return[2,null]}}))}))}function Ao(t,n){return e.mul(t,n)}function Co(t,n){var r,i,a=n;r=a.xs,i=a.ys,e.util.assert(null!=r&&null!=i,(function(){return"A Dataset iterator for fitDataset() is expected to generate objects of the form `{xs: xVal, ys: yVal}`, where the two values may be `tf.Tensor`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates "+n}));var s=To("input",t.inputNames,r),o=To("output",t.outputNames,i),u=s[0].shape[0];e.util.assert(s.length===t.inputs.length,(function(){return"LayersModel has "+t.inputs.length+" inputs, but the dataset provides "+s.length+" inputs.  (Expected input keys: "+JSON.stringify(t.inputNames)+")"})),e.util.assert(o.length===t.outputs.length,(function(){return"LayersModel has "+t.outputs.length+" outputs, but the dataset provides "+o.length+" outputs.  (Expected output keys: "+JSON.stringify(t.outputNames)+")"}));for(var l=function(n){e.util.assert(s[n].shape[0]===u,(function(){return"Batch size mismatch: input "+t.inputNames[n]+" has "+s[n].shape[0]+"; expected  "+u+" based on input "+t.inputNames[0]+"."}))},c=0;c<s.length;c++)l(c);for(var h=function(n){e.util.assert(o[n].shape[0]===u,(function(){return"Batch size mismatch: output "+t.outputNames[n]+" has "+o[n].shape[0]+"; expected  "+u+" based on input "+t.inputNames[0]+"."}))},p=0;p<o.length;p++)h(p);return{xs:s,ys:o}}function To(t,n,r){if(r instanceof e.Tensor)return[r];if(Array.isArray(r))return e.util.assert(r.length===n.length,(function(){return"Received an array of "+r.length+" Tensors, but expected "+n.length+" to match the "+t+" keys "+n+"."})),r;for(var i=[],a=0,s=n;a<s.length;a++){var o=s[a];if(null==r[o])throw new ki("The feature data generated by the dataset lacks the required "+t+" key '"+o+"'.");i.push(r[o])}return i}function Eo(t,n,r){return mi(this,void 0,void 0,(function(){var i,a,s,o,u,l,c,h,p,d,f,g,m,y,v,b,w,k,S,N,x,z,I,A,C,T,E,F,D,L,_,R,O,M;return yi(this,(function(B){switch(B.label){case 0:if(i=null!=r.batchesPerEpoch,e.util.assert(null!=t.optimizer,(function(){return"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."})),e.util.assert(null!=r,(function(){return"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."})),e.util.assert(null!=r.epochs&&r.epochs>0&&Number.isInteger(r.epochs),(function(){return"For fitDataset(), config.epochs is expected to be a positive integer, but got "+r.epochs})),e.util.assert(!i||r.batchesPerEpoch>0&&Number.isInteger(r.batchesPerEpoch),(function(){return"For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got "+r.batchesPerEpoch})),e.util.assert(null==r.validationSplit,(function(){return"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."})),t.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");t.isTraining=!0,B.label=1;case 1:return B.trys.push([1,,26,27]),a=null!=r.validationData,s=void 0,o=void 0,a&&(Fo(r.validationData)?e.util.assert(null==r.validationBatches||r.validationBatches>0&&Number.isInteger(r.validationBatches),(function(){return"For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got "+r.validationBatches})):(u=function(t){if(3===t.length)throw new Si("Validation with sample weights is not implemented yet.");return{xs:t[0],ys:t[1]}}(r.validationData),s=u.xs,o=u.ys)),l=t.makeTrainFunction(),c=t.getDedupedMetricsNames(),h=void 0,h=a?c.slice().concat(c.map((function(t){return"val_"+t}))):c.slice(),p=_s(r.callbacks,r.yieldEvery),d=null==r.verbose?1:r.verbose,f=Os(p,d,r.epochs,null,null,function(t,e){var n=null;null!=e.batchesPerEpoch?n=e.batchesPerEpoch:Number.isFinite(t.size)&&(n=t.size);return n}(n,r),null,a,h),g=f.callbackList,m=f.history,g.setModel(t),t.history=m,[4,g.onTrainBegin()];case 2:return B.sent(),t.stopTraining_=!1,y=null==r.initialEpoch?0:r.initialEpoch,[4,n.iterator()];case 3:v=B.sent(),B.label=4;case 4:return y<r.epochs?(b={},[4,g.onEpochBegin(y)]):[3,23];case 5:return B.sent(),w=0,k=0,i?[3,7]:[4,n.iterator()];case 6:v=B.sent(),B.label=7;case 7:return!i||w<r.batchesPerEpoch?[4,v.next()]:[3,21];case 8:return S=B.sent(),i&&S.done?(console.warn("You provided `batchesPerEpoch` as "+r.batchesPerEpoch+", but your dataset iterator ran out of data after "+w+" batches; interrupting training. Make sure that your dataset can generate at least `batchesPerEpoch * epochs` batches (in this case, "+r.batchesPerEpoch*r.epochs+" batches). You may need to use the repeat() function when building your dataset."),[3,21]):null==S.value?[3,15]:(N=Co(t,S.value),x=N.xs,z=N.ys,(I={}).batch=k,I.size=x[0].shape[0],[4,g.onBatchBegin(k,I)]);case 9:if(B.sent(),A=[],null==r.classWeight)return[3,13];C=zo(r.classWeight,t.outputNames),M=0,B.label=10;case 10:return M<C.length?(E=(T=A).push,[4,Io(z[M],null,C[M])]):[3,13];case 11:E.apply(T,[B.sent()]),B.label=12;case 12:return++M,[3,10];case 13:for(F=x.concat(z).concat(A),D=l(F),e.dispose(F),M=0;M<c.length;++M)L=c[M],_=D[M],I[L]=_,e.keep(_);return[4,g.onBatchEnd(k,I)];case 14:B.sent(),Cs(I),k++,w++,B.label=15;case 15:return(i?w>=r.batchesPerEpoch:S.done)?a?(R=void 0,Fo(r.validationData)?(O=Ci,[4,t.evaluateDataset(r.validationData,{batches:r.validationBatches})]):[3,17]):[3,19]:[3,20];case 16:return R=O.apply(void 0,[B.sent()]),[3,18];case 17:R=Ci(t.evaluate(s,o,{batchSize:null==r.validationBatchSize?32:r.validationBatchSize,verbose:0})),B.label=18;case 18:for(M=0;M<t.metricsNames.length;++M)b["val_"+t.metricsNames[M]]=R[M];B.label=19;case 19:return[3,21];case 20:return t.stopTraining_?[3,21]:[3,7];case 21:return[4,g.onEpochEnd(y,b)];case 22:return B.sent(),y++,t.stopTraining_?[3,23]:[3,4];case 23:return[4,g.onTrainEnd()];case 24:return B.sent(),[4,t.history.syncData()];case 25:return B.sent(),[2,t.history];case 26:return t.isTraining=!1,[7];case 27:return[2]}}))}))}function Fo(t){return"function"==typeof t.iterator}function Do(t,n,r){return mi(this,void 0,void 0,(function(){var i,a,s,o,u,l,c,h,p,d;return yi(this,(function(f){switch(f.label){case 0:if(i=null!=(r=r||{}).batches,a=t.testFunction,s=[],r.verbose>0)throw new Si("Verbose mode is not implemented yet.");return e.util.assert(!i||r.batches>0&&Number.isInteger(r.batches),(function(){return"Test loop expects `batches` to be a positive integer, but received "+JSON.stringify(r.batches)})),"function"!=typeof n.next?[3,1]:(u=n,[3,3]);case 1:return[4,n.iterator()];case 2:u=f.sent(),f.label=3;case 3:o=u,l=0,c=0,h=function(){var n;return yi(this,(function(u){switch(u.label){case 0:return[4,o.next()];case 1:return n=u.sent(),s=e.tidy((function(){if(n.value){var r=Co(t,n.value),i=r.xs,o=r.ys,u=i.concat(o),h=e.tidy((function(){return a(u)}));if(e.dispose(u),0===c)for(var p=0;p<h.length;++p)s.push(e.scalar(0));var d=u[0].shape[0],f=function(t){var n=h[t],r=s[t];s[t]=e.tidy((function(){return e.add(s[t],e.mul(d,n))})),c>0&&e.dispose(r)};for(p=0;p<h.length;++p)f(p);e.dispose(h),l+=d,++c}return s})),n.done?(i&&console.warn("Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least `batches` batches (in this case, "+r.batches+" batches). You may need to use the repeat() function when building your dataset."),[2,"break"]):[2]}}))},f.label=4;case 4:return!i||c<r.batches?[5,h()]:[3,6];case 5:return"break"===f.sent()?[3,6]:[3,4];case 6:for(p=0;p<s.length;++p)d=s[p],s[p]=e.div(s[p],l),e.dispose(d);return[2,Ai(s)]}}))}))}function Lo(t){e.util.assert(t>0&&Number.isInteger(t),(function(){return"batchSize is required to be a positive integer, but got "+t}))}function _o(t,e,n){return null==t?[null]:Array.isArray(t)?t.map((function(t){return ka(t,e,n-e)})):ka(t,e,n-e)}function Ro(t,n){return e.tidy((function(){return null==t?null:Array.isArray(t)?t.map((function(t){return Ro(t,n)})):Ta(t,"int32"===n.dtype?n:e.cast(n,"int32"))}))}function Oo(t,e){for(var n=[],r=0,i=null;r<t;)(i=r+e)>=t&&(i=t),n.push([r,i]),r=i;return n}function Mo(t,n,r,i,a,s,o,u,l,c,h,p,d,f,g){return mi(this,void 0,void 0,(function(){var m,y,v,b,w,k,S,N;return yi(this,(function(x){switch(x.label){case 0:if(null==a&&(a=32),null==s&&(s=1),null==h&&(h=!0),null==d&&(d=0),m=!1,null!=l&&null!=c&&(m=!0),null!=g&&(m=!0,null==f))throw new ki("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");return null!=(y=t.checkNumSamples(r,a,f,"steps_per_epoch"))&&(v=va(0,y)),null==o&&(o=1),b=Os(u,o,s,d,y,f,a,m,p),w=b.callbackList,k=b.history,w.setModel(t),t.history=k,[4,w.onTrainBegin()];case 1:x.sent(),t.stopTraining_=!1,S=function(s){var o,u,p,d,g;return yi(this,(function(b){switch(b.label){case 0:return[4,w.onEpochBegin(s)];case 1:if(b.sent(),o={},null==f)return[3,2];throw new Si("stepsPerEpoch mode is not implemented yet.");case 2:if("batch"===h)throw new Si("batch shuffling is not implemneted yet");h&&e.util.shuffle(v),u=e.tensor1d(v),p=Oo(y,a),d=function(s){var h;return yi(this,(function(d){switch(d.label){case 0:return h={},[4,w.onBatchBegin(s,h)];case 1:return d.sent(),e.tidy((function(){var d=p[s][0],f=p[s][1],g=ka(u,d,f-d);h.batch=s,h.size=f-d;for(var y=Ro(r,g),v=n(y),b=0;b<i.length;++b){var w=i[b],k=v[b];h[w]=k,e.keep(k)}if(s===p.length-1&&m){var S=t.testLoop(l,c,a);for(b=0;b<i.length;++b){w=i[b],k=S[b];e.keep(k),o["val_"+w]=k}}})),[4,w.onBatchEnd(s,h)];case 2:return d.sent(),Cs(h),t.stopTraining_?[2,"break"]:[2]}}))},g=0,b.label=3;case 3:return g<p.length?[5,d(g)]:[3,6];case 4:if("break"===b.sent())return[3,6];b.label=5;case 5:return++g,[3,3];case 6:u.dispose(),b.label=7;case 7:return[4,w.onEpochEnd(s,o)];case 8:return b.sent(),t.stopTraining_?[2,"break"]:[2]}}))},N=d,x.label=2;case 2:return N<s?[5,S(N)]:[3,5];case 3:if("break"===x.sent())return[3,5];x.label=4;case 4:return++N,[3,2];case 5:return[4,w.onTrainEnd()];case 6:return x.sent(),[4,t.history.syncData()];case 7:return x.sent(),[2,t.history]}}))}))}function Bo(t,n,r,i){return void 0===i&&(i={}),mi(this,void 0,void 0,(function(){var a,s,o,u,l,c,h,p,d,f,g,m,y,v,b,w,k,S,N,x;return yi(this,(function(z){switch(z.label){case 0:if(t.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");t.isTraining=!0,z.label=1;case 1:return z.trys.push([1,,7,8]),Lo(p=null==i.batchSize?32:i.batchSize),!1,[4,t.standardizeUserData(n,r,i.sampleWeight,i.classWeight,false,p)];case 2:if(d=z.sent(),a=d[0],s=d[1],h=d[2],f=!1,g=void 0,!(null!=i.validationData&&i.validationData.length>0))return[3,4];if(f=!0,2!==i.validationData.length)throw 3===i.validationData.length?new Si("validationData including sample weights is not supported yet."):new ki("When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; "+i.validationData+" is invalid.");return o=i.validationData[0],u=i.validationData[1],!0,[4,t.standardizeUserData(o,u,null,null,true,p)];case 3:return m=z.sent(),l=m[0],c=m[1],g=l.concat(c),[3,5];case 4:null!=i.validationSplit&&i.validationSplit>0&&i.validationSplit<1?(f=!0,y=Math.floor(a[0].shape[0]*(1-i.validationSplit)),v=a[0].shape[0],l=_o(a,y,v),a=_o(a,0,y),c=_o(s,y,v),s=_o(s,0,y),g=l.concat(c)):null!=i.validationSteps&&(f=!0),z.label=5;case 5:return b=a.concat(s).concat(h),t.checkTrainableWeightsConsistency(),w=t.makeTrainFunction(),k=t.getDedupedMetricsNames(),S=void 0,N=void 0,f?(t.makeTestFunction(),S=t.testFunction,N=k.slice().concat(k.map((function(t){return"val_"+t})))):(S=null,g=[],N=k.slice()),x=_s(i.callbacks,i.yieldEvery),[4,Mo(t,w,b,k,p,i.epochs,i.verbose,x,S,g,i.shuffle,N,i.initialEpoch,null,null)];case 6:return[2,z.sent()];case 7:return t.isTraining=!1,$o(a,n),$o(s,r),$o(l,o),$o(c,u),null!=h&&e.dispose(h),[7];case 8:return[2]}}))}))}function Po(t){var n=[];t instanceof e.Tensor&&(t=[t]);for(var r=0;r<t.length;++r){var i=t[r];if(1===i.rank)n.push(wa(i,1));else{if(0===i.rank)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");n.push(i)}}return n}function $o(t,n){if(null!=t){var r=[];if(n instanceof e.Tensor)r.push(n.id);else if(Array.isArray(n))n.forEach((function(t){return r.push(t.id)}));else if(null!=n)for(var i in n){var a=n[i];r.push(a.id)}var s=[];if(t instanceof e.Tensor)-1===r.indexOf(t.id)&&s.push(t);else if(Array.isArray(t))t.forEach((function(t){-1===r.indexOf(t.id)&&s.push(t)}));else if(null!=t)for(var o in t){var u=t[o];-1===r.indexOf(u.id)&&s.push(u)}s.forEach((function(t){t.isDisposed||t.dispose()}))}}function Wo(t){return Array.isArray(t)}function Uo(t){return!function(t){return t instanceof e.Tensor}(t)&&!Wo(t)}function jo(t,e,n,r,i){if(void 0===r&&(r=!0),void 0===i&&(i=""),null==e||0===e.length){if(null!=t){var a=!1;if(Wo(t)&&t.length>0)a=!0;else if(Uo(t)){for(var s in t)if(t.hasOwnProperty(s)){a=!0;break}}else a=!0;if(a)throw new ki("Error when checking model "+i+" expected no data, but got "+t)}return[]}if(null==t)return e.map((function(t){return null}));var o;if(Uo(t)){t=t,o=[];for(var u=0,l=e;u<l.length;u++){var c=l[u];if(null==t[c])throw new ki('No data provided for "'+c+'". Need data for each key in: '+e);o.push(t[c])}}else if(Wo(t)){if((t=t).length!==e.length)throw new ki("Error when checking model "+i+": the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see "+e.length+" Tensor(s), but instead got the following list of Tensor(s): "+t);o=t}else{if(t=t,e.length>1)throw new ki("The model "+i+" expects "+e.length+" Tensor(s), but only received one Tensor. Found: Tensor with shape "+t.shape);o=[t]}if(o=Po(o),null!=n)for(var h=0;h<e.length;++h)if(null!=n[h]){var p=o[h];if(p.shape.length!==n[h].length)throw new ki("Error when checking "+i+": expected "+e[h]+" to have "+n[h].length+" dimension(s). but got array with shape "+p.shape);for(var d=0;d<n[h].length;++d)if(0!==d||r){var f=p.shape[d],g=n[h][d];if(null!=g&&g>=0&&f!==g)throw new ki("Error when checking "+i+": expected "+e[h]+" to have shape ["+n[h]+"], but got array with shape ["+p.shape+"].")}}return o}function Vo(t,e,n,r,i){var a;if(void 0===r&&(r=!0),void 0===i&&(i=""),Array.isArray(t)){if(t.length!==e.length)throw new ki("Error when checking model "+i+": the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see "+e.length+" Tensor(s), but instead got "+t.length+" Tensors(s).");a=t}else{if(e.length>1)throw new ki("The model expects "+e.length+" "+i+" Tensors, but only received one Tensor. Found: array with shape "+JSON.stringify(t.shape)+".");a=[t]}if(null!=n)for(var s=0;s<e.length;++s)if(null!=n[s]){var o=a[s];if(o.shape.length!==n[s].length)throw new ki("Error when checking "+i+": expected "+e[s]+" to have "+n[s].length+" dimension(s), but got array with shape "+JSON.stringify(o.shape));for(var u=0;u<n[s].length;++u)if(0!==u||r){var l=o.shape[u],c=n[s][u];if(null!=c&&c!==l)throw new ki("Error when checking "+i+": expected "+e[s]+" to have shape "+JSON.stringify(n[s])+" but got array with shape "+JSON.stringify(o.shape)+".")}}}var Ko=function(t){function n(e){var n=t.call(this,e)||this;return n.isTraining=!1,n}return di(n,t),n.prototype.summary=function(t,e,n){if(void 0===n&&(n=console.log),!this.built)throw new ki("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");uo(this,t,e,n)},n.prototype.compile=function(t){var n=this;if(null==t.loss&&(t.loss=[]),this.loss=t.loss,"string"==typeof t.optimizer)this.optimizer_=function(t){var n={Adagrad:function(){return e.train.adagrad(.01)},Adadelta:function(){return e.train.adadelta(1,.95,vi())},Adam:function(){return e.train.adam(.001,.9,.999,vi())},Adamax:function(){return e.train.adamax(.002,.9,.999,vi(),0)},RMSProp:function(){return e.train.rmsprop(.001,.9,0,vi())},SGD:function(){return e.train.sgd(.01)}};if(n.adagrad=n.Adagrad,n.adadelta=n.Adadelta,n.adam=n.Adam,n.adamax=n.Adamax,n.rmsprop=n.RMSProp,n.sgd=n.SGD,t in n)return n[t]();throw new ki("Unknown Optimizer "+t)}(t.optimizer),this.isOptimizerOwned=!0;else{if(!(t.optimizer instanceof e.Optimizer))throw new ki("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=t.optimizer,this.isOptimizerOwned=!1}var r=[];if(Array.isArray(t.loss)||"string"==typeof t.loss||"function"==typeof t.loss)if(Array.isArray(t.loss)){if(t.loss.length!==this.outputs.length)throw new ki("When passing an Array as loss, it should have one entry per model output. The model has "+this.outputs.length+" output(s), but you passed loss="+t.loss+".");var i=t.loss;r=i.map((function(t){return Gs(t)}))}else{var a=Gs(t.loss);this.outputs.forEach((function(t){r.push(a)}))}else{for(var s in t.loss=t.loss,t.loss)if(-1===this.outputNames.indexOf(s))throw new ki('Unknown entry in loss dictionary: "'+s+'". Only expected the following keys: '+this.outputNames);for(var o=0,u=this.outputNames;o<u.length;o++){var l=u[o];null==t.loss[l]&&console.warn('Output "'+l+'" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to '+l+" during training"),r.push(Gs(t.loss[l]))}}this.lossFunctions=r,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(var c=0;c<this.outputs.length;++c){var h=this.internalOutputShapes[c],p=this.outputNames[c];this.feedOutputNames.push(p),this.feedOutputShapes.push(h),this.feedLossFns.push(this.lossFunctions[c])}var d=[];this.metrics=t.metrics,this.metricsNames=["loss"],this.metricsTensors=[],ca("loss",(function(){for(var t=0;t<n.outputs.length;++t)if(-1===d.indexOf(t)){var e=n.lossFunctions[t];n.outputs.length>1&&(n.metricsTensors.push([e,t]),n.metricsNames.push(n.outputNames[t]+"_loss"))}}));var f=function(t,e){if(null==t||Array.isArray(t)&&0===t.length)return e.map((function(t){return[]}));var n;if("string"==typeof t||"function"==typeof t)n=[t];else{if(!Array.isArray(t)&&"object"!=typeof t)throw new TypeError("Type of metrics argument not understood. Expected an string,function, Array, or Object, found: "+t);n=t}if(Array.isArray(n))return e.map((function(t){return n}));for(var r=[],i=0,a=e;i<a.length;i++){var s=a[i],o=n.hasOwnProperty(s)?n[s]:[];Array.isArray(o)||(o=[o]),r.push(o)}return r}(t.metrics,this.outputNames);ca("metric",(function(){for(var t=function(t){if(-1!==d.indexOf(t))return"continue";!function(e){for(var r,i,a,s=function(e){if("string"==typeof e&&-1!==["accuracy","acc","crossentropy","ce"].indexOf(e)){var s=n.internalOutputShapes[t];1===s[s.length-1]||n.lossFunctions[t]===Vs?-1!==["accuracy","acc"].indexOf(e)?i=Hs:-1!==["crossentropy","ce"].indexOf(e)&&(i=Qs):n.lossFunctions[t]===js?-1!==["accuracy","acc"].indexOf(e)?i=to:-1!==["crossentropy","ce"].indexOf(e)&&(i=no):-1!==["accuracy","acc"].indexOf(e)?i=Js:-1!==["crossentropy","ce"].indexOf(e)&&(i=eo);var o=void 0;-1!==["accuracy","acc"].indexOf(e)?o="acc":-1!==["crossentropy","ce"].indexOf(e)&&(o="ce"),a=i,r=""+o}else{var u=function(t){if("string"==typeof t&&t in ro)return ro[t];if("string"!=typeof t&&null!=t)return t;throw new ki("Unknown metric "+t)}(e);a=u,r=""+io(e)}var l;ca(r,(function(){l=a})),function(t,e,r){n.outputNames.length>1&&(e=n.outputNames[t]+"_"+e),n.metricsNames.push(e),n.metricsTensors.push([r,t])}(t,r,l)},o=0,u=e;o<u.length;o++){s(u[o])}}(f[t])},e=0;e<n.outputs.length;++e)t(e)})),this.collectedTrainableWeights=this.trainableWeights},n.prototype.checkTrainableWeightsConsistency=function(){null!=this.collectedTrainableWeights&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")},n.prototype.evaluate=function(t,e,n){void 0===n&&(n={});var r=null==n.batchSize?32:n.batchSize;Lo(r);var i=this.standardizeUserDataXY(t,e,!0,r);try{var a=i[0].concat(i[1]);this.makeTestFunction();var s=this.testFunction;return Ai(this.testLoop(s,a,r,n.verbose,n.steps))}finally{$o(i[0],t),$o(i[1],e)}},n.prototype.evaluateDataset=function(t,e){return mi(this,void 0,void 0,(function(){return yi(this,(function(n){return this.makeTestFunction(),[2,Do(this,t,e)]}))}))},n.prototype.checkNumSamples=function(t,e,n,r){var i;if(void 0===r&&(r="steps"),null!=n){if(i=null,null!=e)throw new ki("If "+r+" is set, batchSize must be null or undefined.Got batchSize = "+e)}else{if(null==t)throw new ki("Either the input data should have a defined shape, or "+r+" shoud be specified.");i=Array.isArray(t)?t[0].shape[0]:t.shape[0]}return i},n.prototype.execute=function(t,n){if(Array.isArray(n)&&0===n.length)throw new ki("`outputs` is an empty Array, which is not allowed.");var r=Array.isArray(n),i=r?n:[n],a=this.retrieveSymbolicTensors(i),s=new yo;if(t instanceof e.Tensor&&(t=[t]),Array.isArray(t)){if(t.length!==this.inputs.length)throw new ki("The number of inputs provided ("+t.length+") does not match the number of inputs of this model ("+this.inputs.length+").");for(var o=0;o<this.inputs.length;++o)s.add(this.inputs[o],t[o])}else for(var u=0,l=this.inputs;u<l.length;u++){var c=l[u],h=t[c.name];if(null==h)throw new ki("No value is provided for the model's input "+c.name);s.add(c,h)}var p=wo(a,s);return r?p:p[0]},n.prototype.retrieveSymbolicTensors=function(t){for(var e=xi(null,t.length),n=t.length,r=0,i=this.layers;r<i.length;r++){for(var a=i[r],s=Array.isArray(a.output)?a.output:[a.output],o=s.map((function(t){return t.name})),u=0;u<t.length;++u){var l=o.indexOf(t[u]);if(-1!==l&&(e[u]=s[l],n--),0===n)break}if(0===n)break}if(n>0){var c=[];throw e.forEach((function(e,n){null==e&&c.push(t[n])})),new ki("Cannot find SymbolicTensors for output name(s): "+JSON.stringify(c))}return e},n.prototype.predictLoop=function(t,n,r){var i=this;return void 0===n&&(n=32),void 0===r&&(r=!1),e.tidy((function(){var a=i.checkNumSamples(t);if(r)throw new Si("Verbose predictLoop() is not implemented yet.");for(var s=Oo(a,n),o=i.outputs.map((function(t){return[]})),u=function(n){e.tidy((function(){var e=s[n][0],r=s[n][1],a=_o(t,e,r),o=[];if(Array.isArray(a))for(var u=0;u<a.length;++u)o.push({key:i.inputs[u],value:a[u]});else o.push({key:i.inputs[0],value:a});var l=new yo(o);return wo(i.outputs,l)})).forEach((function(t,e){return o[e].push(t)}))},l=0;l<s.length;++l)u(l);return Ai(o.map((function(t){return e.concat(t,0)})))}))},n.prototype.predict=function(t,e){void 0===e&&(e={});var n=Po(t);Vo(n,this.inputNames,this.feedInputShapes,!1);try{var r=null==e.batchSize?32:e.batchSize;return Lo(r),this.predictLoop(n,r)}finally{$o(n,t)}},n.prototype.predictOnBatch=function(t){Vo(t,this.inputNames,this.feedInputShapes,!0);var e=(Array.isArray(t)?t[0]:t).shape[0];return this.predictLoop(t,e)},n.prototype.standardizeUserDataXY=function(t,n,r,i){if(null==this.optimizer_)throw new wi("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");for(var a=[],s=0;s<this.feedOutputShapes.length;++s){var o=this.feedOutputShapes[s];this.feedLossFns[s]===js?a.push(o.slice(0,o.length-1).concat([1])):a.push(o)}if(function(t,n,r){var i=Oi(t.map((function(t){return t.shape[0]})));i.sort();var a=Oi(n.map((function(t){return t.shape[0]})));if(a.sort(),i.length>1)throw new ki("All input Tensors (x) should have the same number of samples. Got array shapes: "+JSON.stringify(t.map((function(t){return t.shape}))));if(a.length>1)throw new ki("All target Tensors (y) should have the same number of samples. Got array shapes: "+JSON.stringify(n.map((function(t){return t.shape}))));if(i.length>0&&a.length>0&&!e.util.arraysEqual(i,a))throw new ki("Input Tensors should have the same number of samples as target Tensors. Found "+i[0]+" input sample(s) and "+a[0]+" target sample(s).")}(t=jo(t,this.feedInputNames,this.feedInputShapes,!1,"input"),n=jo(n,this.feedOutputNames,a,!1,"target")),function(t,e,n){for(var r=[Ps,Vs,Us],i=0;i<t.length;++i){var a=t[i],s=e[i],o=n[i];if(null!=s){if(s===Us&&1===a.shape[a.shape.length-1])throw new ki("You are passing a target array of shape "+a.shape+" while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].");if(-1!==r.indexOf(s))for(var u=a.shape.slice(1),l=o.slice(1),c=0;c<u.length;++c){var h=u[c],p=l[c];if(null!=p&&h!==p)throw new ki("A target Tensor with shape "+a.shape+" was passed for an output of shape "+o+", while using a loss function that expects targets to have the same shape as the output.")}}}}(n,this.feedLossFns,this.feedOutputShapes),this.stateful&&null!=i&&i>0&&t[0].shape[0]%i!=0)throw new ki("In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size "+i+". Found: "+t[0].shape[0]+" sample(s).");return[t,n]},n.prototype.standardizeUserData=function(t,e,n,r,i,a){return void 0===i&&(i=!0),mi(this,void 0,void 0,(function(){var s,o,u,l,c,h,p,d;return yi(this,(function(f){switch(f.label){case 0:if(s=this.standardizeUserDataXY(t,e,i,a),o=s[0],u=s[1],null!=n)throw new Error("sample weight is not supported yet.");if(l=null,null==r)return[3,4];c=zo(r,this.outputNames),l=[],h=0,f.label=1;case 1:return h<c.length?(d=(p=l).push,[4,Io(u[h],null,c[h])]):[3,4];case 2:d.apply(p,[f.sent()]),f.label=3;case 3:return++h,[3,1];case 4:return[2,[o,u,l]]}}))}))},n.prototype.testLoop=function(t,n,r,i,a){var s=this;return void 0===i&&(i=0),e.tidy((function(){var o=s.checkNumSamples(n,r,a,"steps"),u=[];if(i>0)throw new Si("Verbose mode is not implemented yet.");if(null!=a)throw new Si("steps mode in testLoop() is not implemented yet");for(var l=Oo(o,r),c=e.tensor1d(va(0,o)),h=0;h<l.length;++h){var p=l[h][0],d=l[h][1],f=ka(c,p,d-p),g=Ro(n,f),m=t(g);if(0===h)for(var y=0;y<m.length;++y)u.push(e.scalar(0));for(y=0;y<m.length;++y){var v=m[y];u[y]=e.add(u[y],e.mul(d-p,v))}}for(y=0;y<u.length;++y)u[y]=e.div(u[y],o);return u}))},n.prototype.getDedupedMetricsNames=function(){for(var t=this.metricsNames,e=[],n=0;n<t.length;++n){var r=t[n],i=r;if(Ii(t,r)>1)i+="_"+Ii(t.slice(0,n),r);e.push(i)}return e},n.prototype.makeTrainFunction=function(){var t=this;return function(n){var r=[],i=n.slice(0,t.inputs.length),a=n.slice(t.inputs.length,t.inputs.length+t.outputs.length),s=n.slice(t.inputs.length+t.outputs.length,t.inputs.length+2*t.outputs.length),o=[],u=t.collectedTrainableWeights.map((function(t){return t.read()}));return[t.optimizer_.minimize((function(){for(var n=[],u=0;u<t.inputs.length;++u)n.push({key:t.inputs[u],value:i[u]});var l,c=new yo(n),h=wo(t.outputs,c,{training:!0});for(u=0;u<t.lossFunctions.length;++u){var p=(0,t.lossFunctions[u])(a[u],h[u]);null!=s[u]&&(p=Ao(p,s[u]));var d=e.mean(p);r.push(d),l=0===u?p:e.add(l,p)}for(u=0;u<t.metricsTensors.length;++u){var f=void 0;if(t.outputs.length>1&&u<t.outputs.length)f=r[u];else{var g=t.metricsTensors[u][0],m=t.metricsTensors[u][1];f=e.mean(g(a[m],h[m]))}e.keep(f),o.push(f)}return l=e.mean(l),t.calculateLosses().forEach((function(t){l=e.add(l,t)})),l}),!0,u)].concat(o)}},n.prototype.makeTestFunction=function(){var t=this;this.testFunction=function(n){return e.tidy((function(){for(var r,i=[],a=n.slice(0,t.inputs.length),s=n.slice(t.inputs.length,t.inputs.length+t.outputs.length),o=[],u=0;u<t.inputs.length;++u)o.push({key:t.inputs[u],value:a[u]});var l=new yo(o),c=wo(t.outputs,l);for(u=0;u<t.lossFunctions.length;++u){var h=t.lossFunctions[u],p=e.mean(h(s[u],c[u]));r=0===u?p:e.add(r,p),i.push(r)}for(u=0;u<t.metricsTensors.length;++u){var d=t.metricsTensors[u][0],f=t.metricsTensors[u][1],g=e.mean(d(s[f],c[f]));i.push(g)}return i}))}},n.prototype.fit=function(t,e,n){return void 0===n&&(n={}),mi(this,void 0,void 0,(function(){return yi(this,(function(r){return[2,Bo(this,t,e,n)]}))}))},n.prototype.fitDataset=function(t,e){return mi(this,void 0,void 0,(function(){return yi(this,(function(n){return[2,Eo(this,t,e)]}))}))},n.prototype.trainOnBatch=function(t,n){return mi(this,void 0,void 0,(function(){var r,i,a,s,o,u,l,c,h;return yi(this,(function(p){switch(p.label){case 0:return[4,this.standardizeUserData(t,n)];case 1:r=p.sent(),i=r[0],a=r[1],s=this.makeTrainFunction(),o=s(i.concat(a)),u=[],l=0,c=o,p.label=2;case 2:return l<c.length?[4,c[l].data()]:[3,5];case 3:h=p.sent(),u.push(h[0]),p.label=4;case 4:return l++,[3,2];case 5:return e.dispose(o),[2,Ai(u)]}}))}))},n.prototype.getNamedWeights=function(t){for(var e=[],n=null!=t&&t.trainableOnly,r=n?this.trainableWeights:this.weights,i=this.getWeights(n),a=0;a<r.length;++a)n&&!r[a].trainable||e.push({name:r[a].originalName,tensor:i[a]});return e},Object.defineProperty(n.prototype,"stopTraining",{get:function(){return this.stopTraining_},set:function(t){this.stopTraining_=t},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"optimizer",{get:function(){return this.optimizer_},set:function(t){this.optimizer_!==t&&(this.optimizer_=t,this.isOptimizerOwned=!1)},enumerable:!0,configurable:!0}),n.prototype.dispose=function(){var n=t.prototype.dispose.call(this);if(0===n.refCountAfterDispose&&null!=this.optimizer&&this.isOptimizerOwned){var r=e.memory().numTensors;this.optimizer_.dispose(),n.numDisposedVariables+=r-e.memory().numTensors}return n},n.prototype.getLossIdentifiers=function(){var t;if("string"==typeof this.loss)t=Ti(this.loss);else if(Array.isArray(this.loss)){for(var e=0,n=this.loss;e<n.length;e++){if("string"!=typeof n[e])throw new Error("Serialization of non-string loss is not supported.")}t=this.loss.map((function(t){return Ti(t)}))}else{var r=Object.keys(this.loss);t={};for(var i=this.loss,a=0,s=r;a<s.length;a++){var o=s[a];if("string"!=typeof i[o])throw new Error("Serialization of non-string loss is not supported.");t[o]=Ti(i[o])}}return t},n.prototype.getMetricIdentifiers=function(){if("string"==typeof this.metrics||"function"==typeof this.metrics)return[Ti(io(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map((function(t){return Ti(io(t))}));var t={};for(var e in this.metrics)t[e]=Ti(io(this.metrics[e]));return t},n.prototype.getTrainingConfig=function(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}},n.prototype.loadTrainingConfig=function(t){if(null!=t.weighted_metrics)throw new Error("Loading weight_metrics is not supported yet.");if(null!=t.loss_weights)throw new Error("Loading loss_weights is not supported yet.");if(null!=t.sample_weight_mode)throw new Error("Loading sample_weight_mode is not supported yet.");var e,n,r=Ms(fo(t.optimizer_config));if("string"==typeof t.loss)e=Ei(t.loss);else if(Array.isArray(t.loss))e=t.loss.map((function(t){return Ei(t)}));else if(null!=t.loss)for(var i in e={},t.loss)e[i]=Ei(t.loss[i]);if(Array.isArray(t.metrics))n=t.metrics.map((function(t){return Ei(t)}));else if(null!=t.metrics)for(var i in n={},t.metrics)n[i]=Ei(t.metrics[i]);this.compile({loss:e,metrics:n,optimizer:r})},n.prototype.save=function(t,n){return mi(this,void 0,void 0,(function(){var r,i,a,s,o,u,l,c,h,p,d;return yi(this,(function(f){switch(f.label){case 0:if("string"==typeof t){if(0===(r=e.io.getSaveHandlers(t)).length)throw new ki("Cannot find any save handlers for URL '"+t+"'");if(r.length>1)throw new ki("Found more than one ("+r.length+") save handlers for URL '"+t+"'");t=r[0]}if(null==t.save)throw new ki("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return[4,e.io.encodeWeights(this.getNamedWeights(n))];case 1:return i=f.sent(),!1,null,a=this.toJSON(null,false),s={modelTopology:a,format:"layers-model",generatedBy:"TensorFlow.js tfjs-layers v3.8.0",convertedBy:null},null!=n&&n.includeOptimizer&&null!=this.optimizer?(s.trainingConfig=this.getTrainingConfig(),o="optimizer",p=(h=e.io).encodeWeights,[4,this.optimizer.getWeights()]):[3,4];case 2:return[4,p.apply(h,[f.sent(),o])];case 3:u=f.sent(),l=u.data,c=u.specs,(d=i.specs).push.apply(d,c),i.data=e.io.concatenateArrayBuffers([i.data,l]),f.label=4;case 4:return null!=this.userDefinedMetadata&&(!0,so(this.userDefinedMetadata,this.name,true),s.userDefinedMetadata=this.userDefinedMetadata),s.weightData=i.data,s.weightSpecs=i.specs,[2,t.save(s)]}}))}))},n.prototype.setUserDefinedMetadata=function(t){so(t,this.name),this.userDefinedMetadata=t},n.prototype.getUserDefinedMetadata=function(){return this.userDefinedMetadata},n.className="Model",n}(xo);e.serialization.registerClass(Ko);var qo=function(t){function e(){return null!==t&&t.apply(this,arguments)||this}return di(e,t),e.className="Functional",e}(Ko);function Go(t,n,r){return mi(this,void 0,void 0,(function(){var i,a,s,o,u,l,c,h,p;return yi(this,(function(d){switch(d.label){case 0:if(null==r&&(r={}),null==t.load)throw new ki("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");return[4,t.load()];case 1:if(i=d.sent(),null!=(a=i.modelTopology).model_config&&(a=a.model_config),s=null==r.strict||r.strict,o=null!=i.weightData&&null!=i.weightSpecs&&s,u=Ms(fo(a),n,o),null!=(l=i.trainingConfig)&&u.loadTrainingConfig(l),null!=i.userDefinedMetadata&&u.setUserDefinedMetadata(i.userDefinedMetadata),null==i.weightData)return[3,4];if(null==i.weightSpecs)throw new ki("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");return c=function(t,n){var r=e.io.decodeWeights(t,n),i={},a=[];return n.forEach((function(t){"optimizer"===t.group?a.push({name:t.name,tensor:r[t.name]}):i[t.name]=r[t.name]})),{modelWeights:i,optimizerWeights:a}}(i.weightData,i.weightSpecs),h=c.modelWeights,p=c.optimizerWeights,u.loadWeights(h,s),null!=u.optimizer&&p.length>0?[4,u.optimizer.setWeights(p)]:[3,3];case 2:d.sent(),d.label=3;case 3:e.dispose(h),e.dispose(p.map((function(t){return t.tensor}))),d.label=4;case 4:return[2,u]}}))}))}e.serialization.registerClass(qo);var Ho=function(t){function n(e){var n=t.call(this,{inputs:[],outputs:[]})||this;if(e=e||{},n.trainable=!0,n.built=!1,n.name=null!=e.name?e.name:os("sequential_"),null!=e.layers)for(var r=0,i=e.layers;r<i.length;r++){var a=i[r];n.add(a)}return n}return di(n,t),n.prototype.checkShape=function(t){if(t.inboundNodes[0].outputTensors[0].shape.some((function(t){return t<0})))throw new ki("Negative dimension size caused by adding layer "+t.name+" with input shape ["+t.inboundNodes[0].inputTensors[0].shape+"]")},n.prototype.add=function(t){var e,r=t instanceof n||t instanceof Ko;if(r){if(1!==(e=t).outputs.length)throw new ki("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(1!==e.inputs.length)throw new ki("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(0===this.outputs.length){if(0===t.inboundNodes.length){if(null==t.batchInputShape)throw new ki("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");var i=Is({batchShape:t.batchInputShape,dtype:t.dtype,name:t.name+"_input"});t.apply(i)}if(r)this.outputs=e.outputs,this.inputs=e.inputs;else{if(1!==t.inboundNodes.length)throw new ki("A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer "+t.name+" which has "+t.inboundNodes.length+" pre-existing inbound connections.");if(1!==t.inboundNodes[0].outputTensors.length)throw new ki("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[t.inboundNodes[0].outputTensors[0]],this.inputs=Ns(this.outputs[0])}this.inboundNodes=[],new ws({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:xi(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map((function(t){return t.shape})),outputShapes:this.outputs[0].shape})}else{var a=t.apply(this.outputs[0]);if(Array.isArray(a))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[a],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(t),this.built=!1},n.prototype.pop=function(){if(0===this.layers.length)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),0===this.layers.length)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{var t=this.layers.length-1;this.layers[t].outboundNodes=[],this.outputs=[this.layers[t].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}},n.prototype.call=function(t,e){return null==this.model&&this.build(),this.model.call(t,e)},n.prototype.build=function(t){if(hs(t),0===this.inputs.length||0===this.outputs.length)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new Ko({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0},n.prototype.countParams=function(){return this.built||this.build(),t.prototype.countParams.call(this)},n.prototype.summary=function(e,n,r){void 0===r&&(r=console.log),this.built||this.build(),t.prototype.summary.call(this,e,n,r)},n.prototype.setWeights=function(t){null==this.model&&this.build(),this.model.setWeights(t)},n.prototype.evaluate=function(t,e,n){if(void 0===n&&(n={}),!this.built)throw new wi("The model needs to be compiled before being used.");return this.model.evaluate(t,e,n)},n.prototype.evaluateDataset=function(t,e){return mi(this,void 0,void 0,(function(){return yi(this,(function(n){if(!this.built)throw new wi("The model needs to be compiled before being used.");return[2,this.model.evaluateDataset(t,e)]}))}))},n.prototype.predict=function(t,e){return void 0===e&&(e={}),null==this.model&&this.build(),this.model.predict(t,e)},n.prototype.predictOnBatch=function(t){return null==this.model&&this.build(),this.model.predictOnBatch(t)},n.prototype.compile=function(t){this.build(),this.model.compile(t),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames},Object.defineProperty(n.prototype,"optimizer",{get:function(){return null==this.model?void 0:this.model.optimizer},set:function(t){this.model.optimizer=t},enumerable:!0,configurable:!0}),n.prototype.fit=function(t,e,n){return void 0===n&&(n={}),mi(this,void 0,void 0,(function(){return yi(this,(function(r){if(!this.built)throw new wi("The model needs to be compiled before being used.");return[2,this.model.fit(t,e,n)]}))}))},n.prototype.fitDataset=function(t,e){return mi(this,void 0,void 0,(function(){return yi(this,(function(n){if(!this.built)throw new wi("The model needs to be compiled before being used.");return[2,this.model.fitDataset(t,e)]}))}))},n.prototype.trainOnBatch=function(t,e){return mi(this,void 0,void 0,(function(){return yi(this,(function(n){return[2,this.model.trainOnBatch(t,e)]}))}))},n.fromConfig=function(t,r,i,a){var s;void 0===a&&(a=!1);var o={};if(r instanceof Array){if(null==r[0].className||"Merge"===r[0].className)throw new ki("Legacy serialization format not supported yet.");s=r}else e.util.assert(null!=r.layers,(function(){return"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."})),s=r.layers,delete r.layers,o=r;var u=new t(o);if(!(u instanceof n))throw new Si("Sequential.fromConfig called on non-Sequential input: "+u);for(var l=0,c=s;l<c.length;l++){var h=Ms(c[l],undefined,a);a&&h.setFastWeightInitDuringBuild(!0),u.add(h)}return u},Object.defineProperty(n.prototype,"stopTraining",{get:function(){if(null==this.model)throw new ki("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining},set:function(t){if(null==this.model)throw new ki("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=t},enumerable:!0,configurable:!0}),n.prototype.getConfig=function(){for(var t=[],e=0,n=this.layers;e<n.length;e++){var r=n[e],i={};i.className=r.getClassName(),i.config=r.getConfig(),t.push(i)}return{name:this.name,layers:t}},n.className="Sequential",n}(Ko);function Jo(t){return Is(t)}e.serialization.registerClass(Ho);var Zo=function(t){function e(){return null!==t&&t.apply(this,arguments)||this}return di(e,t),e.prototype.getConfig=function(){return{}},e}(e.serialization.Serializable),Yo=function(t){function n(){return null!==t&&t.apply(this,arguments)||this}return di(n,t),n.prototype.apply=function(t,n){return void 0===n&&(n=1),function(t,n){if(void 0===n&&(n=1),1!==n)throw new Si("Support for alpha values other than 1 ("+n+") is not implemented yet.");return e.elu(t)}(t,n)},n.className="elu",n}(Zo);e.serialization.registerClass(Yo);var Xo=function(t){function n(){return null!==t&&t.apply(this,arguments)||this}return di(n,t),n.prototype.apply=function(t){return e.selu(t)},n.className="selu",n}(Zo);e.serialization.registerClass(Xo);var Qo=function(t){function n(){return null!==t&&t.apply(this,arguments)||this}return di(n,t),n.prototype.apply=function(t){return e.relu(t)},n.className="relu",n}(Zo);e.serialization.registerClass(Qo);var tu=function(t){function n(){return null!==t&&t.apply(this,arguments)||this}return di(n,t),n.prototype.apply=function(t){return e.tidy((function(){return e.minimum(6,e.relu(t))}))},n.className="relu6",n}(Zo);e.serialization.registerClass(tu);var eu=function(t){function e(){return null!==t&&t.apply(this,arguments)||this}return di(e,t),e.prototype.apply=function(t){return t},e.className="linear",e}(Zo);e.serialization.registerClass(eu);var nu=function(t){function n(){return null!==t&&t.apply(this,arguments)||this}return di(n,t),n.prototype.apply=function(t){return e.sigmoid(t)},n.className="sigmoid",n}(Zo);e.serialization.registerClass(nu);var ru=function(t){function n(){return null!==t&&t.apply(this,arguments)||this}return di(n,t),n.prototype.apply=function(t){return function(t){return e.tidy((function(){var n=e.add(.5,e.mul(.2,t));return e.clipByValue(n,0,1)}))}(t)},n.className="hardSigmoid",n}(Zo);e.serialization.registerClass(ru);var iu=function(t){function n(){return null!==t&&t.apply(this,arguments)||this}return di(n,t),n.prototype.apply=function(t){return e.softplus(t)},n.className="softplus",n}(Zo);e.serialization.registerClass(iu);var au=function(t){function n(){return null!==t&&t.apply(this,arguments)||this}return di(n,t),n.prototype.apply=function(t){return function(t){return e.tidy((function(){return e.div(t,e.add(e.abs(t),1))}))}(t)},n.className="softsign",n}(Zo);e.serialization.registerClass(au);var su=function(t){function n(){return null!==t&&t.apply(this,arguments)||this}return di(n,t),n.prototype.apply=function(t){return e.tanh(t)},n.className="tanh",n}(Zo);e.serialization.registerClass(su);var ou=function(t){function n(){return null!==t&&t.apply(this,arguments)||this}return di(n,t),n.prototype.apply=function(t,n){return void 0===n&&(n=-1),e.softmax(t,n)},n.className="softmax",n}(Zo);e.serialization.registerClass(ou);var uu=function(t){function n(){return null!==t&&t.apply(this,arguments)||this}return di(n,t),n.prototype.apply=function(t,n){return void 0===n&&(n=-1),e.logSoftmax(t,n)},n.className="logSoftmax",n}(Zo);e.serialization.registerClass(uu);var lu=function(t){function n(){return null!==t&&t.apply(this,arguments)||this}return di(n,t),n.prototype.apply=function(t,n){return void 0===n&&(n=1),e.tidy((function(){return e.mul(e.sigmoid(e.mul(t,n)),t)}))},n.className="swish",n}(Zo);e.serialization.registerClass(lu);var cu=function(t){function n(){return null!==t&&t.apply(this,arguments)||this}return di(n,t),n.prototype.apply=function(t){return e.tidy((function(){return e.mul(t,e.tanh(e.softplus(t)))}))},n.className="mish",n}(Zo);function hu(t){return t.getClassName()}function pu(t,n){return void 0===n&&(n={}),_i(t,e.serialization.SerializationMap.getMap().classNameMap,n,"activation")}function du(t){var e;return null==t?pu(e={className:"linear",config:{}}):"string"==typeof t?((e={}).className=t,e.config={},pu(e)):t instanceof Zo?t:pu(t)}function fu(t){if(null!=t&&"object"!=typeof t)throw new Error("Argument to L1L2 regularizer's constructor is expected to be an object, but received: "+t)}e.serialization.registerClass(cu);var gu=function(t){function e(){return null!==t&&t.apply(this,arguments)||this}return di(e,t),e}(e.serialization.Serializable),mu=function(t){function n(e){var n=t.call(this)||this;return fu(e),n.l1=null==e||null==e.l1?.01:e.l1,n.l2=null==e||null==e.l2?.01:e.l2,n.hasL1=0!==n.l1,n.hasL2=0!==n.l2,n}return di(n,t),n.prototype.apply=function(t){var n=this;return e.tidy((function(){var r=e.zeros([1]);return n.hasL1&&(r=e.add(r,e.sum(e.mul(n.l1,e.abs(t))))),n.hasL2&&(r=e.add(r,e.sum(e.mul(n.l2,Ea(t))))),e.reshape(r,[])}))},n.prototype.getConfig=function(){return{l1:this.l1,l2:this.l2}},n.fromConfig=function(t,e){return new t({l1:e.l1,l2:e.l2})},n.className="L1L2",n}(gu);e.serialization.registerClass(mu);var yu={l1l2:"L1L2"};function vu(t){return Di(t)}function bu(t,n){return void 0===n&&(n={}),_i(t,e.serialization.SerializationMap.getMap().classNameMap,n,"regularizer")}function wu(t){return null==t?null:"string"==typeof t?bu({className:t in yu?yu[t]:t,config:{}}):t instanceof gu?t:bu(t)}var ku=function(t){function n(e){var n=t.call(this,null==e?{}:e)||this;return n.supportsMasking=!0,null!=e&&(n.maxValue=e.maxValue),n}return di(n,t),n.prototype.call=function(t,n){t=cs(t);var r=e.relu(t);return null!=this.maxValue&&(r=e.clipByValue(r,0,this.maxValue)),r},n.prototype.computeOutputShape=function(t){return t},n.prototype.getConfig=function(){var e={maxValue:this.maxValue},n=t.prototype.getConfig.call(this);return Object.assign(e,n),e},n.className="ReLU",n}(Ss);e.serialization.registerClass(ku);var Su=function(t){function n(e){var n=t.call(this,null==e?{}:e)||this;return n.DEFAULT_ALPHA=.3,null==e&&(e={}),n.alpha=null==e.alpha?n.DEFAULT_ALPHA:e.alpha,n}return di(n,t),n.prototype.call=function(t,n){var r=cs(t);return e.leakyRelu(r,this.alpha)},n.prototype.computeOutputShape=function(t){return t},n.prototype.getConfig=function(){var e={alpha:this.alpha},n=t.prototype.getConfig.call(this);return Object.assign(e,n),e},n.className="LeakyReLU",n}(Ss);e.serialization.registerClass(Su);var Nu=function(t){function n(e){var n=t.call(this,null==e?{}:e)||this;if(n.DEFAULT_ALPHA_INITIALIZER="zeros",null==e&&(e={}),n.supportsMasking=!0,n.alphaInitializer=ns(e.alphaInitializer||n.DEFAULT_ALPHA_INITIALIZER),n.alphaRegularizer=wu(e.alphaRegularizer),n.alphaConstraint=Xi(e.alphaConstraint),null==e.sharedAxes)n.sharedAxes=null;else if(Array.isArray(e.sharedAxes))n.sharedAxes=e.sharedAxes;else{if("number"!=typeof e.sharedAxes)throw new ki("Expected sharedAxes to be a number or an array of numbers, but got "+e.sharedAxes);n.sharedAxes=[e.sharedAxes]}return n}return di(n,t),n.prototype.build=function(t){var e=(t=hs(t)).slice(1);if(null!=this.sharedAxes)for(var n=0,r=this.sharedAxes;n<r.length;n++){e[(a=r[n])-1]=1}this.alpha=this.addWeight("alpha",e,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);var i={};if(null!=this.sharedAxes)for(var a=1;a<t.length;++a)i[a]=t[a];this.inputSpec=[new ys({ndim:t.length,axes:i})],this.built=!0},n.prototype.call=function(t,n){return t=cs(t),e.prelu(t,this.alpha.read())},n.prototype.getConfig=function(){var e={alphaInitializer:es(this.alphaInitializer),alphaRegularizer:vu(this.alphaRegularizer),alphaConstraint:Zi(this.alphaConstraint),sharedAxes:this.sharedAxes},n=t.prototype.getConfig.call(this);return Object.assign(e,n),e},n.className="PReLU",n}(Ss);e.serialization.registerClass(Nu);var xu=function(t){function n(e){var n=t.call(this,null==e?{}:e)||this;if(n.DEFAULT_ALPHA=1,null==e&&(e={}),null!=e.alpha&&e.alpha!==n.DEFAULT_ALPHA)throw new Si("Non-default alpha value ("+e.alpha+") is not supported by the ELU layer yet.");return n.alpha=null==e.alpha?n.DEFAULT_ALPHA:e.alpha,n}return di(n,t),n.prototype.call=function(t,n){var r=cs(t);return e.elu(r)},n.prototype.computeOutputShape=function(t){return t},n.prototype.getConfig=function(){var e={alpha:this.alpha},n=t.prototype.getConfig.call(this);return Object.assign(e,n),e},n.className="ELU",n}(Ss);e.serialization.registerClass(xu);var zu=function(t){function n(e){var n=t.call(this,null==e?{}:e)||this;return n.DEFAULT_THETA=1,null==e&&(e={}),n.theta=null==e.theta?n.DEFAULT_THETA:e.theta,n}return di(n,t),n.prototype.call=function(t,n){var r=cs(t);return e.mul(r,e.cast(e.greater(r,this.theta),"float32"))},n.prototype.computeOutputShape=function(t){return t},n.prototype.getConfig=function(){var e={theta:this.theta},n=t.prototype.getConfig.call(this);return Object.assign(e,n),e},n.className="ThresholdedReLU",n}(Ss);e.serialization.registerClass(zu);var Iu=function(t){function e(e){var n=t.call(this,null==e?{}:e)||this;return n.DEFAULT_AXIS=1,null==e&&(e={}),n.softmax=(new ou).apply,n.axis=null==e.axis?n.DEFAULT_AXIS:e.axis,n}return di(e,t),e.prototype.call=function(t,e){var n=cs(t);return this.softmax(n,this.axis)},e.prototype.computeOutputShape=function(t){return t},e.prototype.getConfig=function(){var e={axis:this.axis},n=t.prototype.getConfig.call(this);return Object.assign(e,n),e},e.className="Softmax",e}(Ss);function Au(t,e,n){if("number"==typeof t)return xi(t,e);if(t.length!==e)throw new ki("The "+n+" argument must be an integer or tuple of "+e+" integers. Received: "+t.length+" elements.");for(var r=0;r<e;++r){var i=t[r];if((a=i)!==parseInt(a.toString(),10))throw new ki("The "+n+" argument must be an integer or tuple of "+e+" integers. Received: "+JSON.stringify(t)+" including a non-integer number "+i)}return t;var a}function Cu(t,e,n,r,i){return void 0===i&&(i=1),null==t?t:(a="same"===n?t:t-(e+(e-1)*(i-1))+1,Math.floor((a+r-1)/r));var a}function Tu(t,e,n,r){if(null==t)return null;if("valid"===r)t=t*e+ya([n-e,0]);else{if("same"!==r)throw new ki("Unsupport padding mode: "+r+".");t*=e}return t}function Eu(t,n){return e.tidy((function(){return sa(n),"channelsFirst"===n?e.transpose(t,[0,2,3,1]):t}))}function Fu(t,n){return e.tidy((function(){return sa(n),"channelsFirst"===n?e.transpose(t,[0,2,3,4,1]):t}))}function Du(t,n,r,i,a,s,o,u){return void 0===i&&(i=[1,1]),void 0===a&&(a="valid"),void 0===u&&(u=null),e.tidy((function(){if(null==s&&(s="channelsLast"),sa(s),3!==t.rank&&4!==t.rank)throw new ki("conv2dWithBiasActivation expects input to be of rank 3 or 4, but received "+t.rank+".");if(3!==n.rank&&4!==n.rank)throw new ki("conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received "+t.rank+".");var l=Eu(t,s);if("causal"===a)throw new Si("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=e.fused.conv2d({x:l,filter:n,strides:i,pad:"same"===a?"same":"valid",dilations:o,dataFormat:"NHWC",bias:r,activation:u}),"channelsFirst"===s&&(l=e.transpose(l,[0,3,1,2])),l}))}e.serialization.registerClass(Iu);var Lu=function(t){function e(n,r){var i=t.call(this,r)||this;if(i.bias=null,i.DEFAULT_KERNEL_INITIALIZER="glorotNormal",i.DEFAULT_BIAS_INITIALIZER="zeros",e.verifyArgs(r),i.rank=n,$i(i.rank,"rank"),1!==i.rank&&2!==i.rank&&3!==i.rank)throw new Si("Convolution layer for rank other than 1, 2, or 3 ("+i.rank+") is not implemented yet.");if(i.kernelSize=Au(r.kernelSize,n,"kernelSize"),i.strides=Au(null==r.strides?1:r.strides,n,"strides"),i.padding=null==r.padding?"valid":r.padding,oa(i.padding),i.dataFormat=null==r.dataFormat?"channelsLast":r.dataFormat,sa(i.dataFormat),i.activation=du(r.activation),i.useBias=null==r.useBias||r.useBias,i.biasInitializer=ns(r.biasInitializer||i.DEFAULT_BIAS_INITIALIZER),i.biasConstraint=Xi(r.biasConstraint),i.biasRegularizer=wu(r.biasRegularizer),i.activityRegularizer=wu(r.activityRegularizer),i.dilationRate=Au(null==r.dilationRate?1:r.dilationRate,n,"dilationRate"),1===i.rank&&Array.isArray(i.dilationRate)&&1!==i.dilationRate.length)throw new ki("dilationRate must be a number or an array of a single number for 1D convolution, but received "+JSON.stringify(i.dilationRate));if(2===i.rank){if("number"==typeof i.dilationRate)i.dilationRate=[i.dilationRate,i.dilationRate];else if(2!==i.dilationRate.length)throw new ki("dilationRate must be a number or array of two numbers for 2D convolution, but received "+JSON.stringify(i.dilationRate))}else if(3===i.rank)if("number"==typeof i.dilationRate)i.dilationRate=[i.dilationRate,i.dilationRate,i.dilationRate];else if(3!==i.dilationRate.length)throw new ki("dilationRate must be a number or array of three numbers for 3D convolution, but received "+JSON.stringify(i.dilationRate));return i}return di(e,t),e.verifyArgs=function(t){if(zi("kernelSize"in t,"required key 'kernelSize' not in config"),"number"!=typeof t.kernelSize&&!Pi(t.kernelSize,"number",1,3))throw new ki("BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received "+JSON.stringify(t.kernelSize)+".")},e.prototype.getConfig=function(){var e={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:hu(this.activation),useBias:this.useBias,biasInitializer:es(this.biasInitializer),biasRegularizer:vu(this.biasRegularizer),activityRegularizer:vu(this.activityRegularizer),biasConstraint:Zi(this.biasConstraint)},n=t.prototype.getConfig.call(this);return Object.assign(e,n),e},e}(Ss),_u=function(t){function n(e,r){var i=t.call(this,e,r)||this;return i.kernel=null,n.verifyArgs(r),i.filters=r.filters,$i(i.filters,"filters"),i.kernelInitializer=ns(r.kernelInitializer||i.DEFAULT_KERNEL_INITIALIZER),i.kernelConstraint=Xi(r.kernelConstraint),i.kernelRegularizer=wu(r.kernelRegularizer),i}return di(n,t),n.prototype.build=function(t){var e;t=hs(t);var n="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[n])throw new ki("The channel dimension of the input should be defined. Found "+t[n]);var r=t[n],i=this.kernelSize.concat([r,this.filters]);this.kernel=this.addWeight("kernel",i,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:(e={},e[n]=r,e)}],this.built=!0},n.prototype.call=function(t,n){var r=this;return e.tidy((function(){var n;t=cs(t);var i,a,s,o,u,l,c,h=null==r.bias?null:r.bias.read(),p=Ui(r.activation.getClassName());if(null!=p&&2===r.rank)n=Du(t,r.kernel.read(),h,r.strides,r.padding,r.dataFormat,r.dilationRate,p);else{if(1===r.rank)i=t,a=r.kernel.read(),s=h,o=r.strides[0],u=r.padding,l=r.dataFormat,c=r.dilationRate[0],void 0===o&&(o=1),void 0===u&&(u="valid"),void 0===c&&(c=1),n=e.tidy((function(){if(null==l&&(l="channelsLast"),sa(l),3!==i.shape.length)throw new ki("The input of a conv1dWithBias operation should be 3, but is "+i.shape.length+" instead.");if(3!==a.shape.length)throw new ki("The kernel for a conv1dWithBias operation should be 3, but is "+a.shape.length+" instead");if(null!=s&&1!==s.shape.length)throw new ki("The bias for a conv1dWithBias operation should be 1, but is "+a.shape.length+" instead");if("channelsFirst"===l&&(i=e.transpose(i,[0,2,1])),"causal"===u)throw new Si("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");var t=e.conv1d(i,a,o,"same"===u?"same":"valid","NWC",c);return null!=s&&(t=Da(t,s)),t}));else if(2===r.rank)n=Du(t,r.kernel.read(),h,r.strides,r.padding,r.dataFormat,r.dilationRate);else{if(3!==r.rank)throw new Si("convolutions greater than 3D are not implemented yet.");n=function(t,n,r,i,a,s,o){return void 0===i&&(i=[1,1,1]),void 0===a&&(a="valid"),e.tidy((function(){if(null==s&&(s="channelsLast"),sa(s),4!==t.rank&&5!==t.rank)throw new ki("conv3dWithBias expects input to be of rank 4 or 5, but received "+t.rank+".");if(4!==n.rank&&5!==n.rank)throw new ki("conv3dWithBias expects kernel to be of rank 4 or 5, but received "+t.rank+".");var u=Fu(t,s);if("causal"===a)throw new Si("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return u=e.conv3d(u,n,i,"same"===a?"same":"valid","NDHWC",o),null!=r&&(u=Da(u,r)),"channelsFirst"===s&&(u=e.transpose(u,[0,4,1,2,3])),u}))}(t,r.kernel.read(),h,r.strides,r.padding,r.dataFormat,r.dilationRate)}null!=r.activation&&(n=r.activation.apply(n))}return n}))},n.prototype.computeOutputShape=function(t){t=hs(t);for(var e=[],n="channelsLast"===this.dataFormat?t.slice(1,t.length-1):t.slice(2),r=0;r<n.length;++r){var i=Cu(n[r],this.kernelSize[r],this.padding,this.strides[r],"number"==typeof this.dilationRate?this.dilationRate:this.dilationRate[r]);e.push(i)}var a=[t[0]];return"channelsLast"===this.dataFormat?(a=a.concat(e)).push(this.filters):(a.push(this.filters),a=a.concat(e)),a},n.prototype.getConfig=function(){var e={filters:this.filters,kernelInitializer:es(this.kernelInitializer),kernelRegularizer:vu(this.kernelRegularizer),kernelConstraint:Zi(this.kernelConstraint)},n=t.prototype.getConfig.call(this);return Object.assign(e,n),e},n.verifyArgs=function(t){if(!("filters"in t)||"number"!=typeof t.filters||t.filters<1)throw new ki("Convolution layer expected config.filters to be a 'number' > 0 but got "+JSON.stringify(t.filters))},n}(Lu),Ru=function(t){function e(n){var r=t.call(this,2,n)||this;return e.verifyArgs(n),r}return di(e,t),e.prototype.getConfig=function(){var e=t.prototype.getConfig.call(this);return delete e.rank,e},e.verifyArgs=function(t){if("number"!=typeof t.kernelSize&&!Pi(t.kernelSize,"number",1,2))throw new ki("Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received "+JSON.stringify(t.kernelSize)+".")},e.className="Conv2D",e}(_u);e.serialization.registerClass(Ru);var Ou=function(t){function e(n){var r=t.call(this,3,n)||this;return e.verifyArgs(n),r}return di(e,t),e.prototype.getConfig=function(){var e=t.prototype.getConfig.call(this);return delete e.rank,e},e.verifyArgs=function(t){if("number"!=typeof t.kernelSize&&(!Array.isArray(t.kernelSize)||1!==t.kernelSize.length&&3!==t.kernelSize.length))throw new ki("Conv3D expects config.kernelSize to be number or [number, number, number], but received "+JSON.stringify(t.kernelSize)+".")},e.className="Conv3D",e}(_u);e.serialization.registerClass(Ou);var Mu=function(t){function n(e){var n=t.call(this,e)||this;if(n.inputSpec=[new ys({ndim:4})],"same"!==n.padding&&"valid"!==n.padding)throw new ki("Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode "+n.padding);return n}return di(n,t),n.prototype.build=function(t){var e;if(4!==(t=hs(t)).length)throw new ki("Input should have rank 4; Received input shape: "+JSON.stringify(t));var n="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[n])throw new ki("The channel dimension of the inputs should be defined. Found `None`.");var r=t[n],i=this.kernelSize.concat([this.filters,r]);this.kernel=this.addWeight("kernel",i,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new ys({ndim:4,axes:(e={},e[n]=r,e)})],this.built=!0},n.prototype.call=function(t,n){var r=this;return e.tidy((function(){var n=cs(t);if(4!==n.shape.length)throw new ki("Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-"+n.shape.length);var i,a,s=n.shape,o=s[0];"channelsFirst"===r.dataFormat?(i=2,a=3):(i=1,a=2);var u=s[i],l=s[a],c=r.kernelSize[0],h=r.kernelSize[1],p=r.strides[0],d=r.strides[1],f=[o,Tu(u,p,c,r.padding),Tu(l,d,h,r.padding),r.filters];"channelsLast"!==r.dataFormat&&(n=e.transpose(n,[0,2,3,1]));var g=e.conv2dTranspose(n,r.kernel.read(),f,r.strides,r.padding);return"channelsLast"!==r.dataFormat&&(g=e.transpose(g,[0,3,1,2])),null!=r.bias&&(g=Da(g,r.bias.read(),r.dataFormat)),null!=r.activation&&(g=r.activation.apply(g)),g}))},n.prototype.computeOutputShape=function(t){var e,n,r,i=(t=hs(t)).slice();"channelsFirst"===this.dataFormat?(e=1,n=2,r=3):(e=3,n=1,r=2);var a=this.kernelSize[0],s=this.kernelSize[1],o=this.strides[0],u=this.strides[1];return i[e]=this.filters,i[n]=Tu(i[n],o,a,this.padding),i[r]=Tu(i[r],u,s,this.padding),i},n.prototype.getConfig=function(){var e=t.prototype.getConfig.call(this);return delete e.dilationRate,e},n.className="Conv2DTranspose",n}(Ru);e.serialization.registerClass(Mu);var Bu=function(t){function n(e){var n=t.call(this,e)||this;if(n.inputSpec=[new ys({ndim:5})],"same"!==n.padding&&"valid"!==n.padding)throw new ki("Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode "+n.padding);return n}return di(n,t),n.prototype.build=function(t){var e;if(5!==(t=hs(t)).length)throw new ki("Input should have rank 5; Received input shape: "+JSON.stringify(t));var n="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[n])throw new ki("The channel dimension of the inputs should be defined. Found `None`.");var r=t[n],i=this.kernelSize.concat([this.filters,r]);this.kernel=this.addWeight("kernel",i,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new ys({ndim:5,axes:(e={},e[n]=r,e)})],this.built=!0},n.prototype.call=function(t,n){var r=this;return e.tidy((function(){var n=cs(t);if(5!==n.shape.length)throw new ki("Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-"+n.shape.length);var i,a,s,o=n.shape,u=o[0];"channelsFirst"===r.dataFormat?(s=2,i=3,a=4):(s=1,i=2,a=3);var l=o[s],c=o[i],h=o[a],p=r.kernelSize[0],d=r.kernelSize[1],f=r.kernelSize[2],g=r.strides[0],m=r.strides[1],y=r.strides[2],v=[u,Tu(l,g,p,r.padding),Tu(c,m,d,r.padding),Tu(h,y,f,r.padding),r.filters];"channelsLast"!==r.dataFormat&&(n=e.transpose(n,[0,2,3,4,1]));var b=e.conv3dTranspose(n,r.kernel.read(),v,r.strides,r.padding);return"channelsLast"!==r.dataFormat&&(b=e.transpose(b,[0,4,1,2,3])),null!==r.bias&&(b=Da(b,r.bias.read(),r.dataFormat)),null!==r.activation&&(b=r.activation.apply(b)),b}))},n.prototype.computeOutputShape=function(t){var e,n,r,i,a=(t=hs(t)).slice();"channelsFirst"===this.dataFormat?(e=1,n=2,r=3,i=4):(e=4,n=1,r=2,i=3);var s=this.kernelSize[0],o=this.kernelSize[1],u=this.kernelSize[2],l=this.strides[0],c=this.strides[1],h=this.strides[2];return a[e]=this.filters,a[n]=Tu(a[n],l,s,this.padding),a[r]=Tu(a[r],c,o,this.padding),a[i]=Tu(a[i],h,u,this.padding),a},n.prototype.getConfig=function(){var e=t.prototype.getConfig.call(this);return delete e.dilationRate,e},n.className="Conv3DTranspose",n}(Ou);e.serialization.registerClass(Bu);var Pu=function(t){function e(e){return t.call(this,2,e)||this}return di(e,t),e.className="SeparableConv2D",e}(function(t){function n(e,n){var r=t.call(this,e,n)||this;if(r.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",r.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",r.depthwiseKernel=null,r.pointwiseKernel=null,null==n.filters)throw new ki("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(null!=n.kernelInitializer||null!=n.kernelRegularizer||null!=n.kernelConstraint)throw new ki("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(null!=n.padding&&"same"!==n.padding&&"valid"!==n.padding)throw new ki("SeparableConv"+r.rank+"D supports only padding modes: 'same' and 'valid', but received "+JSON.stringify(n.padding));return r.depthMultiplier=null==n.depthMultiplier?1:n.depthMultiplier,r.depthwiseInitializer=ns(n.depthwiseInitializer||r.DEFAULT_DEPTHWISE_INITIALIZER),r.depthwiseRegularizer=wu(n.depthwiseRegularizer),r.depthwiseConstraint=Xi(n.depthwiseConstraint),r.pointwiseInitializer=ns(n.depthwiseInitializer||r.DEFAULT_POINTWISE_INITIALIZER),r.pointwiseRegularizer=wu(n.pointwiseRegularizer),r.pointwiseConstraint=Xi(n.pointwiseConstraint),r}return di(n,t),n.prototype.build=function(t){var e;if((t=hs(t)).length<this.rank+2)throw new ki("Inputs to SeparableConv"+this.rank+"D should have rank "+(this.rank+2)+", but received input shape: "+JSON.stringify(t));var n="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[n]||t[n]<0)throw new ki("The channel dimension of the inputs should be defined, but found "+JSON.stringify(t[n]));for(var r=t[n],i=this.kernelSize.concat([r,this.depthMultiplier]),a=[],s=0;s<this.rank;++s)a.push(1);a.push(r*this.depthMultiplier,this.filters);var o=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",i,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,o,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",a,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,o,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,o,this.biasConstraint):this.bias=null,this.inputSpec=[new ys({ndim:this.rank+2,axes:(e={},e[n]=r,e)})],this.built=!0},n.prototype.call=function(t,n){var r=this;return e.tidy((function(){var n;if(t=cs(t),1===r.rank)throw new Si("1D separable convolution is not implemented yet.");return 2===r.rank&&("channelsFirst"===r.dataFormat&&(t=e.transpose(t,[0,2,3,1])),n=e.separableConv2d(t,r.depthwiseKernel.read(),r.pointwiseKernel.read(),r.strides,r.padding,r.dilationRate,"NHWC")),r.useBias&&(n=Da(n,r.bias.read(),r.dataFormat)),null!=r.activation&&(n=r.activation.apply(n)),"channelsFirst"===r.dataFormat&&(n=e.transpose(n,[0,3,1,2])),n}))},n.prototype.getConfig=function(){var e=t.prototype.getConfig.call(this);return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=es(this.depthwiseInitializer),e.pointwiseInitializer=es(this.pointwiseInitializer),e.depthwiseRegularizer=vu(this.depthwiseRegularizer),e.pointwiseRegularizer=vu(this.pointwiseRegularizer),e.depthwiseConstraint=Zi(this.depthwiseConstraint),e.pointwiseConstraint=Zi(this.pointwiseConstraint),e},n.className="SeparableConv",n}(_u));e.serialization.registerClass(Pu);var $u=function(t){function e(n){var r=t.call(this,1,n)||this;return e.verifyArgs(n),r.inputSpec=[{ndim:3}],r}return di(e,t),e.prototype.getConfig=function(){var e=t.prototype.getConfig.call(this);return delete e.rank,delete e.dataFormat,e},e.verifyArgs=function(t){if("number"!=typeof t.kernelSize&&!Pi(t.kernelSize,"number",1,1))throw new ki("Conv1D expects config.kernelSize to be number or number[] with length 1, but received "+JSON.stringify(t.kernelSize)+".")},e.className="Conv1D",e}(_u);e.serialization.registerClass($u);var Wu=function(t){function n(e){var n=t.call(this,e)||this;return"number"==typeof e.cropping?n.cropping=[[e.cropping,e.cropping],[e.cropping,e.cropping]]:"number"==typeof e.cropping[0]?n.cropping=[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:n.cropping=e.cropping,n.dataFormat=void 0===e.dataFormat?"channelsLast":e.dataFormat,n.inputSpec=[{ndim:4}],n}return di(n,t),n.prototype.computeOutputShape=function(t){return"channelsFirst"===this.dataFormat?[t[0],t[1],t[2]-this.cropping[0][0]-this.cropping[0][1],t[3]-this.cropping[1][0]-this.cropping[1][1]]:[t[0],t[1]-this.cropping[0][0]-this.cropping[0][1],t[2]-this.cropping[1][0]-this.cropping[1][1],t[3]]},n.prototype.call=function(t,n){var r=this;return e.tidy((function(){if(t=cs(t),"channelsLast"===r.dataFormat){var e=Na(t,r.cropping[0][0],t.shape[1]-r.cropping[0][0]-r.cropping[0][1],2);return Na(e,r.cropping[1][0],t.shape[2]-r.cropping[1][1]-r.cropping[1][0],3)}e=Na(t,r.cropping[0][0],t.shape[2]-r.cropping[0][0]-r.cropping[0][1],3);return Na(e,r.cropping[1][0],t.shape[3]-r.cropping[1][1]-r.cropping[1][0],4)}))},n.prototype.getConfig=function(){var e={cropping:this.cropping,dataFormat:this.dataFormat},n=t.prototype.getConfig.call(this);return Object.assign(e,n),e},n.className="Cropping2D",n}(Ss);e.serialization.registerClass(Wu);var Uu=function(t){function n(e){var n,r=t.call(this,e)||this;return r.DEFAULT_SIZE=[2,2],r.inputSpec=[{ndim:4}],r.size=null==e.size?r.DEFAULT_SIZE:e.size,r.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,sa(r.dataFormat),r.interpolation=null==e.interpolation?"nearest":e.interpolation,n=r.interpolation,Bi(ea,"InterpolationFormat",n),r}return di(n,t),n.prototype.computeOutputShape=function(t){if("channelsFirst"===this.dataFormat){var e=null==t[2]?null:this.size[0]*t[2],n=null==t[3]?null:this.size[1]*t[3];return[t[0],t[1],e,n]}e=null==t[1]?null:this.size[0]*t[1],n=null==t[2]?null:this.size[1]*t[2];return[t[0],e,n,t[3]]},n.prototype.call=function(t,n){var r=this;return e.tidy((function(){var n=cs(t),i=n.shape;if("channelsFirst"===r.dataFormat){n=e.transpose(n,[0,2,3,1]);var a=r.size[0]*i[2],s=r.size[1]*i[3],o="nearest"===r.interpolation?e.image.resizeNearestNeighbor(n,[a,s]):e.image.resizeBilinear(n,[a,s]);return e.transpose(o,[0,3,1,2])}a=r.size[0]*i[1],s=r.size[1]*i[2];return"nearest"===r.interpolation?e.image.resizeNearestNeighbor(n,[a,s]):e.image.resizeBilinear(n,[a,s])}))},n.prototype.getConfig=function(){var e={size:this.size,dataFormat:this.dataFormat},n=t.prototype.getConfig.call(this);return Object.assign(e,n),e},n.className="UpSampling2D",n}(Ss);e.serialization.registerClass(Uu);var ju=function(t){function n(e){var n=t.call(this,2,e)||this;return n.depthwiseKernel=null,n.depthMultiplier=null==e.depthMultiplier?1:e.depthMultiplier,n.depthwiseInitializer=ns(e.depthwiseInitializer||n.DEFAULT_KERNEL_INITIALIZER),n.depthwiseConstraint=Xi(e.depthwiseConstraint),n.depthwiseRegularizer=wu(e.depthwiseRegularizer),n}return di(n,t),n.prototype.build=function(t){if((t=hs(t)).length<4)throw new ki("Inputs to DepthwiseConv2D should have rank 4. Received input shape: "+JSON.stringify(t)+".");var e="channelsFirst"===this.dataFormat?1:3;if(null==t[e]||t[e]<0)throw new ki("The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not ("+t[e]+").");var n=t[e],r=[this.kernelSize[0],this.kernelSize[1],n,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",r,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[n*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0},n.prototype.call=function(t,n){var r=this;return e.tidy((function(){t=cs(t);var n,i,a,s,o,u,l=(n=t,i=r.depthwiseKernel.read(),a=r.strides,s=r.padding,o=r.dataFormat,u=null,void 0===a&&(a=[1,1]),void 0===s&&(s="valid"),e.tidy((function(){null==o&&(o="channelsLast"),sa(o);var t=Eu(n,o);if(4!==n.rank)throw new ki("Input for depthwiseConv2d is required to be 4-D, but is instead "+n.rank+"-D");if(4!==i.rank)throw new ki("depthwiseKernel is required to be 4-D, but is instead "+i.rank+"-D");return t=e.depthwiseConv2d(t,i,a,"same"===s?"same":"valid","NHWC",u),"channelsFirst"===o&&(t=e.transpose(t,[0,3,1,2])),t})));return r.useBias&&(l=Da(l,r.bias.read(),r.dataFormat)),null!=r.activation&&(l=r.activation.apply(l)),l}))},n.prototype.computeOutputShape=function(t){t=hs(t);var e="channelsFirst"===this.dataFormat?t[2]:t[1],n="channelsFirst"===this.dataFormat?t[3]:t[2],r="channelsFirst"===this.dataFormat?t[1]*this.depthMultiplier:t[3]*this.depthMultiplier,i=Cu(e,this.kernelSize[0],this.padding,this.strides[0]),a=Cu(n,this.kernelSize[1],this.padding,this.strides[1]);return"channelsFirst"===this.dataFormat?[t[0],r,i,a]:[t[0],i,a,r]},n.prototype.getConfig=function(){var e=t.prototype.getConfig.call(this);return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=es(this.depthwiseInitializer),e.depthwiseRegularizer=vu(this.depthwiseRegularizer),e.depthwiseConstraint=Zi(this.depthwiseRegularizer),e},n.className="DepthwiseConv2D",n}(Lu);function Vu(t,e,n,r){if(Array.isArray(t)){if(null!=e||null!=n)throw new ki("When inputs is an array, neither initialState or constants should be provided");null!=r&&(n=t.slice(t.length-r,t.length),t=t.slice(0,t.length-r)),t.length>1&&(e=t.slice(1,t.length)),t=t[0]}function i(t){return null==t||Array.isArray(t)?t:[t]}return{inputs:t,initialState:e=i(e),constants:n=i(n)}}function Ku(t,n,r,i,a,s,o,u){return void 0===i&&(i=!1),void 0===o&&(o=!1),void 0===u&&(u=!1),e.tidy((function(){var l=n.shape.length;if(l<3)throw new ki("Input should be at least 3D, but is "+l+"D.");var c=[1,0].concat(va(2,l));if(n=e.transpose(n,c),null!=s)throw new Si("The rnn() functoin of the deeplearn.js backend does not support constants yet.");o&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),null!=a&&((a=e.cast(e.cast(a,"bool"),"float32")).rank===l-1&&(a=e.expandDims(a,-1)),a=e.transpose(a,c)),i&&(n=e.reverse(n,0),null!=a&&(a=e.reverse(a,0)));var h,p,d=[],f=r,g=n.shape[0],m=e.unstack(n);null!=a&&(p=e.unstack(a));for(var y,v=function(n){var r=m[n],i=e.tidy((function(){return t(r,f)}));if(null==a)h=i[0],f=i[1];else{var s=e.tidy((function(){var t=p[n],r=e.sub(e.onesLike(t),t);return{output:e.add(e.mul(i[0],t),e.mul(f[0],r)),newStates:f.map((function(n,a){return e.add(e.mul(i[1][a],t),e.mul(n,r))}))}}));h=s.output,f=s.newStates}u&&d.push(h)},b=0;b<g;++b)v(b);if(u){y=e.stack(d,1)}return[h,y,f]}))}e.serialization.registerClass(ju);var qu=function(t){function n(e){var n,r=t.call(this,e)||this;if(null==e.cell)throw new ki("cell property is missing for the constructor of RNN.");if(null==(n=Array.isArray(e.cell)?new tl({cells:e.cell}):e.cell).stateSize)throw new ki("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");return r.cell=n,r.returnSequences=null!=e.returnSequences&&e.returnSequences,r.returnState=null!=e.returnState&&e.returnState,r.goBackwards=null!=e.goBackwards&&e.goBackwards,r._stateful=null!=e.stateful&&e.stateful,r.unroll=null!=e.unroll&&e.unroll,r.supportsMasking=!0,r.inputSpec=[new ys({ndim:3})],r.stateSpec=null,r.states_=null,r.numConstants=null,r.keptStates=[],r}return di(n,t),n.prototype.getStates=function(){return null==this.states_?va(0,Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1).map((function(t){return null})):this.states_},n.prototype.setStates=function(t){this.states_=t},n.prototype.computeOutputShape=function(t){us(t)&&(t=t[0]),t=t;var e=this.cell.stateSize;Array.isArray(e)||(e=[e]);var n,r=e[0];if(n=this.returnSequences?[t[0],t[1],r]:[t[0],r],this.returnState){for(var i=[],a=0,s=e;a<s.length;a++){var o=s[a];i.push([t[0],o])}return[n].concat(i)}return n},n.prototype.computeMask=function(t,n){var r=this;return e.tidy((function(){Array.isArray(n)&&(n=n[0]);var t=r.returnSequences?n:null;if(r.returnState){var e=r.states.map((function(t){return null}));return[t].concat(e)}return t}))},Object.defineProperty(n.prototype,"states",{get:function(){if(null==this.states_){for(var t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,e=[],n=0;n<t;++n)e.push(null);return e}return this.states_},set:function(t){this.states_=t},enumerable:!0,configurable:!0}),n.prototype.build=function(t){if(null!=this.numConstants)throw new Si("Constants support is not implemented in RNN yet.");us(t)&&(t=t[0]),t=t;var n=this.stateful?t[0]:null,r=t.slice(2);this.inputSpec[0]=new ys({shape:[n,null].concat(r)});var i,a=[t[0]].concat(t.slice(2));if(this.cell.build(a),i=Array.isArray(this.cell.stateSize)?this.cell.stateSize:[this.cell.stateSize],null!=this.stateSpec){if(!e.util.arraysEqual(this.stateSpec.map((function(t){return t.shape[t.shape.length-1]})),i))throw new ki("An initialState was passed that is not compatible with cell.stateSize. Received stateSpec="+this.stateSpec+"; However cell.stateSize is "+this.cell.stateSize)}else this.stateSpec=i.map((function(t){return new ys({shape:[null,t]})}));this.stateful&&this.resetStates()},n.prototype.resetStates=function(t,n){var r=this;void 0===n&&(n=!1),e.tidy((function(){if(!r.stateful)throw new bi("Cannot call resetStates() on an RNN Layer that is not stateful.");var i=r.inputSpec[0].shape[0];if(null==i)throw new ki("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==r.states_)Array.isArray(r.cell.stateSize)?r.states_=r.cell.stateSize.map((function(t){return e.zeros([i,t])})):r.states_=[e.zeros([i,r.cell.stateSize])];else if(null==t)e.dispose(r.states_),null!=r.keptStates&&(e.dispose(r.keptStates),r.keptStates=[]),Array.isArray(r.cell.stateSize)?r.states_=r.cell.stateSize.map((function(t){return e.zeros([i,t])})):r.states_[0]=e.zeros([i,r.cell.stateSize]);else{if(Array.isArray(t)||(t=[t]),t.length!==r.states_.length)throw new ki("Layer "+r.name+" expects "+r.states_.length+" state(s), but it received "+t.length+" state value(s). Input received: "+t);!0===n?r.keptStates.push(r.states_.slice()):e.dispose(r.states_);for(var a=0;a<r.states_.length;++a){var s=t[a],o=Array.isArray(r.cell.stateSize)?r.cell.stateSize[a]:r.cell.stateSize,u=[i,o];if(!e.util.arraysEqual(s.shape,u))throw new ki("State "+a+" is incompatible with layer "+r.name+": expected shape="+u+", received shape="+s.shape);r.states_[a]=s}}r.states_=r.states_.map((function(t){return e.keep(t.clone())}))}))},n.prototype.apply=function(e,n){var r=null==n?null:n.initialState,i=null==n?null:n.constants;null==n&&(n={});var a=Vu(e,r,i,this.numConstants);e=a.inputs,r=a.initialState,i=a.constants;var s=[],o=[];if(null!=r){n.initialState=r,s=s.concat(r),this.stateSpec=[];for(var u=0,l=r;u<l.length;u++){var c=l[u];this.stateSpec.push(new ys({shape:c.shape}))}o=o.concat(this.stateSpec)}if(null!=i&&(n.constants=i,s=s.concat(i),this.numConstants=i.length),s[0]instanceof vs){var h=[e].concat(s),p=this.inputSpec.concat(o),d=this.inputSpec;this.inputSpec=p;var f=t.prototype.apply.call(this,h,n);return this.inputSpec=d,f}return t.prototype.apply.call(this,e,n)},n.prototype.call=function(t,n){var r=this;return e.tidy((function(){var e=null==n?null:n.mask,i=null==n?null:n.training,a=null==n?null:n.initialState;t=cs(t),null==a&&(a=r.stateful?r.states_:r.getInitialState(t));var s=Array.isArray(r.cell.stateSize)?r.cell.stateSize.length:1;if(a.length!==s)throw new ki("RNN Layer has "+s+" state(s) but was passed "+a.length+" initial state(s).");r.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");var o={training:i},u=Ku((function(t,e){var n=r.cell.call([t].concat(e),o);return[n[0],n.slice(1)]}),t,a,r.goBackwards,e,null,r.unroll,r.returnSequences),l=u[0],c=u[1],h=u[2];r.stateful&&r.resetStates(h,i);var p=r.returnSequences?c:l;return r.returnState?[p].concat(h):p}))},n.prototype.getInitialState=function(t){var n=this;return e.tidy((function(){var r=e.zeros(t.shape);return r=wa(r=e.sum(r,[1,2])),Array.isArray(n.cell.stateSize)?n.cell.stateSize.map((function(t){return t>1?Ia(r,[1,t]):r})):n.cell.stateSize>1?[Ia(r,[1,n.cell.stateSize])]:[r]}))},Object.defineProperty(n.prototype,"trainableWeights",{get:function(){return this.trainable?this.cell.trainableWeights:[]},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"nonTrainableWeights",{get:function(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights},enumerable:!0,configurable:!0}),n.prototype.setFastWeightInitDuringBuild=function(e){t.prototype.setFastWeightInitDuringBuild.call(this,e),null!=this.cell&&this.cell.setFastWeightInitDuringBuild(e)},n.prototype.getConfig=function(){var e=t.prototype.getConfig.call(this),r={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};null!=this.numConstants&&(r.numConstants=this.numConstants);var i=this.cell.getConfig();return this.getClassName()===n.className&&(r.cell={className:this.cell.getClassName(),config:i}),gi({},i,e,r)},n.fromConfig=function(t,e,n){void 0===n&&(n={});var r=Ms(e.cell,n);return new t(Object.assign(e,{cell:r}))},n.className="RNN",n}(Ss);e.serialization.registerClass(qu);var Gu=function(t){function e(){return null!==t&&t.apply(this,arguments)||this}return di(e,t),e}(Ss),Hu=function(t){function n(e){var n=t.call(this,e)||this;return n.DEFAULT_ACTIVATION="tanh",n.DEFAULT_KERNEL_INITIALIZER="glorotNormal",n.DEFAULT_RECURRENT_INITIALIZER="orthogonal",n.DEFAULT_BIAS_INITIALIZER="zeros",n.units=e.units,$i(n.units,"units"),n.activation=du(null==e.activation?n.DEFAULT_ACTIVATION:e.activation),n.useBias=null==e.useBias||e.useBias,n.kernelInitializer=ns(e.kernelInitializer||n.DEFAULT_KERNEL_INITIALIZER),n.recurrentInitializer=ns(e.recurrentInitializer||n.DEFAULT_RECURRENT_INITIALIZER),n.biasInitializer=ns(e.biasInitializer||n.DEFAULT_BIAS_INITIALIZER),n.kernelRegularizer=wu(e.kernelRegularizer),n.recurrentRegularizer=wu(e.recurrentRegularizer),n.biasRegularizer=wu(e.biasRegularizer),n.kernelConstraint=Xi(e.kernelConstraint),n.recurrentConstraint=Xi(e.recurrentConstraint),n.biasConstraint=Xi(e.biasConstraint),n.dropout=ma([1,ya([0,null==e.dropout?0:e.dropout])]),n.recurrentDropout=ma([1,ya([0,null==e.recurrentDropout?0:e.recurrentDropout])]),n.stateSize=n.units,n.dropoutMask=null,n.recurrentDropoutMask=null,n}return di(n,t),n.prototype.build=function(t){t=hs(t),this.kernel=this.addWeight("kernel",[t[t.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0},n.prototype.call=function(t,n){var r=this;return e.tidy((function(){if(2!==(t=t).length)throw new ki("SimpleRNNCell expects 2 input Tensors, got "+t.length+".");var i=t[1];t=t[0];var a,s=null!=n.training&&n.training;0<r.dropout&&r.dropout<1&&null==r.dropoutMask&&(r.dropoutMask=el({ones:function(){return e.onesLike(t)},rate:r.dropout,training:s})),0<r.recurrentDropout&&r.recurrentDropout<1&&null==r.recurrentDropoutMask&&(r.recurrentDropoutMask=el({ones:function(){return e.onesLike(i)},rate:r.recurrentDropout,training:s}));var o=r.dropoutMask,u=r.recurrentDropoutMask;a=Ca(null!=o?e.mul(t,o):t,r.kernel.read()),null!=r.bias&&(a=Da(a,r.bias.read())),null!=u&&(i=e.mul(i,u));var l=e.add(a,Ca(i,r.recurrentKernel.read()));return null!=r.activation&&(l=r.activation.apply(l)),[l,l]}))},n.prototype.getConfig=function(){var e=t.prototype.getConfig.call(this),n={units:this.units,activation:hu(this.activation),useBias:this.useBias,kernelInitializer:es(this.kernelInitializer),recurrentInitializer:es(this.recurrentInitializer),biasInitializer:es(this.biasInitializer),kernelRegularizer:vu(this.kernelRegularizer),recurrentRegularizer:vu(this.recurrentRegularizer),biasRegularizer:vu(this.biasRegularizer),activityRegularizer:vu(this.activityRegularizer),kernelConstraint:Zi(this.kernelConstraint),recurrentConstraint:Zi(this.recurrentConstraint),biasConstraint:Zi(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return gi({},e,n)},n.className="SimpleRNNCell",n}(Gu);e.serialization.registerClass(Hu);var Ju=function(t){function n(e){return e.cell=new Hu(e),t.call(this,e)||this}return di(n,t),n.prototype.call=function(n,r){var i=this;return e.tidy((function(){null!=i.cell.dropoutMask&&(e.dispose(i.cell.dropoutMask),i.cell.dropoutMask=null),null!=i.cell.recurrentDropoutMask&&(e.dispose(i.cell.recurrentDropoutMask),i.cell.recurrentDropoutMask=null);var a=null==r?null:r.mask,s=null==r?null:r.training,o=null==r?null:r.initialState;return t.prototype.call.call(i,n,{mask:a,training:s,initialState:o})}))},n.fromConfig=function(t,e){return new t(e)},n.className="SimpleRNN",n}(qu);e.serialization.registerClass(Ju);var Zu=function(t){function n(e){var n=t.call(this,e)||this;if(n.DEFAULT_ACTIVATION="tanh",n.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",n.DEFAULT_KERNEL_INITIALIZER="glorotNormal",n.DEFAULT_RECURRENT_INITIALIZER="orthogonal",n.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new ki("GRUCell does not support reset_after parameter set to true.");return n.units=e.units,$i(n.units,"units"),n.activation=du(void 0===e.activation?n.DEFAULT_ACTIVATION:e.activation),n.recurrentActivation=du(void 0===e.recurrentActivation?n.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),n.useBias=null==e.useBias||e.useBias,n.kernelInitializer=ns(e.kernelInitializer||n.DEFAULT_KERNEL_INITIALIZER),n.recurrentInitializer=ns(e.recurrentInitializer||n.DEFAULT_RECURRENT_INITIALIZER),n.biasInitializer=ns(e.biasInitializer||n.DEFAULT_BIAS_INITIALIZER),n.kernelRegularizer=wu(e.kernelRegularizer),n.recurrentRegularizer=wu(e.recurrentRegularizer),n.biasRegularizer=wu(e.biasRegularizer),n.kernelConstraint=Xi(e.kernelConstraint),n.recurrentConstraint=Xi(e.recurrentConstraint),n.biasConstraint=Xi(e.biasConstraint),n.dropout=ma([1,ya([0,null==e.dropout?0:e.dropout])]),n.recurrentDropout=ma([1,ya([0,null==e.recurrentDropout?0:e.recurrentDropout])]),n.implementation=e.implementation,n.stateSize=n.units,n.dropoutMask=null,n.recurrentDropoutMask=null,n}return di(n,t),n.prototype.build=function(t){var e=(t=hs(t))[t.length-1];this.kernel=this.addWeight("kernel",[e,3*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,3*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[3*this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0},n.prototype.call=function(t,n){var r=this;return e.tidy((function(){if(2!==(t=t).length)throw new ki("GRUCell expects 2 input Tensors (inputs, h, c), got "+t.length+".");var i=null!=n.training&&n.training,a=t[1];t=t[0],0<r.dropout&&r.dropout<1&&null==r.dropoutMask&&(r.dropoutMask=el({ones:function(){return e.onesLike(t)},rate:r.dropout,training:i,count:3})),0<r.recurrentDropout&&r.recurrentDropout<1&&null==r.recurrentDropoutMask&&(r.recurrentDropoutMask=el({ones:function(){return e.onesLike(a)},rate:r.recurrentDropout,training:i,count:3}));var s,o,u,l=r.dropoutMask,c=r.recurrentDropoutMask;0<r.dropout&&r.dropout<1&&(t=e.mul(t,l[0]));var h=Ca(t,r.kernel.read());r.useBias&&(h=Da(h,r.bias.read())),0<r.recurrentDropout&&r.recurrentDropout<1&&(a=e.mul(a,c[0]));var p=r.recurrentKernel.read(),d=e.split(p,[2*r.units,r.units],p.rank-1),f=d[0],g=d[1],m=Ca(a,f),y=e.split(h,3,h.rank-1),v=y[0],b=y[1],w=y[2],k=e.split(m,2,m.rank-1),S=k[0],N=k[1];s=r.recurrentActivation.apply(e.add(v,S)),o=r.recurrentActivation.apply(e.add(b,N));var x=Ca(e.mul(o,a),g);u=r.activation.apply(e.add(w,x));var z=e.add(e.mul(s,a),e.mul(e.add(1,e.neg(s)),u));return[z,z]}))},n.prototype.getConfig=function(){var e=t.prototype.getConfig.call(this),n={units:this.units,activation:hu(this.activation),recurrentActivation:hu(this.recurrentActivation),useBias:this.useBias,kernelInitializer:es(this.kernelInitializer),recurrentInitializer:es(this.recurrentInitializer),biasInitializer:es(this.biasInitializer),kernelRegularizer:vu(this.kernelRegularizer),recurrentRegularizer:vu(this.recurrentRegularizer),biasRegularizer:vu(this.biasRegularizer),activityRegularizer:vu(this.activityRegularizer),kernelConstraint:Zi(this.kernelConstraint),recurrentConstraint:Zi(this.recurrentConstraint),biasConstraint:Zi(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return gi({},e,n)},n.className="GRUCell",n}(Gu);e.serialization.registerClass(Zu);var Yu=function(t){function n(e){return 0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new Zu(e),t.call(this,e)||this}return di(n,t),n.prototype.call=function(n,r){var i=this;return e.tidy((function(){null!=i.cell.dropoutMask&&(e.dispose(i.cell.dropoutMask),i.cell.dropoutMask=null),null!=i.cell.recurrentDropoutMask&&(e.dispose(i.cell.recurrentDropoutMask),i.cell.recurrentDropoutMask=null);var a=null==r?null:r.mask,s=null==r?null:r.training,o=null==r?null:r.initialState;return t.prototype.call.call(i,n,{mask:a,training:s,initialState:o})}))},n.fromConfig=function(t,e){return 0===e.implmentation&&(e.implementation=1),new t(e)},n.className="GRU",n}(qu);e.serialization.registerClass(Yu);var Xu=function(t){function n(e){var n=t.call(this,e)||this;return n.DEFAULT_ACTIVATION="tanh",n.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",n.DEFAULT_KERNEL_INITIALIZER="glorotNormal",n.DEFAULT_RECURRENT_INITIALIZER="orthogonal",n.DEFAULT_BIAS_INITIALIZER="zeros",n.units=e.units,$i(n.units,"units"),n.activation=du(void 0===e.activation?n.DEFAULT_ACTIVATION:e.activation),n.recurrentActivation=du(void 0===e.recurrentActivation?n.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),n.useBias=null==e.useBias||e.useBias,n.kernelInitializer=ns(e.kernelInitializer||n.DEFAULT_KERNEL_INITIALIZER),n.recurrentInitializer=ns(e.recurrentInitializer||n.DEFAULT_RECURRENT_INITIALIZER),n.biasInitializer=ns(e.biasInitializer||n.DEFAULT_BIAS_INITIALIZER),n.unitForgetBias=e.unitForgetBias,n.kernelRegularizer=wu(e.kernelRegularizer),n.recurrentRegularizer=wu(e.recurrentRegularizer),n.biasRegularizer=wu(e.biasRegularizer),n.kernelConstraint=Xi(e.kernelConstraint),n.recurrentConstraint=Xi(e.recurrentConstraint),n.biasConstraint=Xi(e.biasConstraint),n.dropout=ma([1,ya([0,null==e.dropout?0:e.dropout])]),n.recurrentDropout=ma([1,ya([0,null==e.recurrentDropout?0:e.recurrentDropout])]),n.implementation=e.implementation,n.stateSize=[n.units,n.units],n.dropoutMask=null,n.recurrentDropoutMask=null,n}return di(n,t),n.prototype.build=function(t){var e,n,r=(t=hs(t))[t.length-1];if(this.kernel=this.addWeight("kernel",[r,4*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,4*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){if(this.unitForgetBias){var i=this.biasInitializer,a=this.units;n=new((e=function(t){function e(){return null!==t&&t.apply(this,arguments)||this}return di(e,t),e.prototype.apply=function(t,e){var n=i.apply([a]),r=(new Pa).apply([a]),s=i.apply([2*a]);return za(za(n,r),s)},e}(Ma)).className="CustomInit",e)}else n=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.units],null,n,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0},n.prototype.call=function(t,n){var r=this;return e.tidy((function(){var i=null!=n.training&&n.training;if(3!==(t=t).length)throw new ki("LSTMCell expects 3 input Tensors (inputs, h, c), got "+t.length+".");var a=t[1],s=t[2];t=t[0],0<r.dropout&&r.dropout<1&&null==r.dropoutMask&&(r.dropoutMask=el({ones:function(){return e.onesLike(t)},rate:r.dropout,training:i,count:4})),0<r.recurrentDropout&&r.recurrentDropout<1&&null==r.recurrentDropoutMask&&(r.recurrentDropoutMask=el({ones:function(){return e.onesLike(a)},rate:r.recurrentDropout,training:i,count:4}));var o,u,l,c,h=r.dropoutMask,p=r.recurrentDropoutMask;0<r.dropout&&r.dropout<1&&(t=e.mul(t,h[0]));var d=Ca(t,r.kernel.read());0<r.recurrentDropout&&r.recurrentDropout<1&&(a=e.mul(a,p[0])),d=e.add(d,Ca(a,r.recurrentKernel.read())),r.useBias&&(d=Da(d,r.bias.read()));var f=e.split(d,4,d.rank-1),g=f[0],m=f[1],y=f[2],v=f[3];o=r.recurrentActivation.apply(g),u=r.recurrentActivation.apply(m),l=e.add(e.mul(u,s),e.mul(o,r.activation.apply(y))),c=r.recurrentActivation.apply(v);var b=e.mul(c,r.activation.apply(l));return[b,b,l]}))},n.prototype.getConfig=function(){var e=t.prototype.getConfig.call(this),n={units:this.units,activation:hu(this.activation),recurrentActivation:hu(this.recurrentActivation),useBias:this.useBias,kernelInitializer:es(this.kernelInitializer),recurrentInitializer:es(this.recurrentInitializer),biasInitializer:es(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:vu(this.kernelRegularizer),recurrentRegularizer:vu(this.recurrentRegularizer),biasRegularizer:vu(this.biasRegularizer),activityRegularizer:vu(this.activityRegularizer),kernelConstraint:Zi(this.kernelConstraint),recurrentConstraint:Zi(this.recurrentConstraint),biasConstraint:Zi(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return gi({},e,n)},n.className="LSTMCell",n}(Gu);e.serialization.registerClass(Xu);var Qu=function(t){function n(e){return 0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new Xu(e),t.call(this,e)||this}return di(n,t),n.prototype.call=function(n,r){var i=this;return e.tidy((function(){null!=i.cell.dropoutMask&&(e.dispose(i.cell.dropoutMask),i.cell.dropoutMask=null),null!=i.cell.recurrentDropoutMask&&(e.dispose(i.cell.recurrentDropoutMask),i.cell.recurrentDropoutMask=null);var a=null==r?null:r.mask,s=null==r?null:r.training,o=null==r?null:r.initialState;return t.prototype.call.call(i,n,{mask:a,training:s,initialState:o})}))},n.fromConfig=function(t,e){return 0===e.implmentation&&(e.implementation=1),new t(e)},n.className="LSTM",n}(qu);e.serialization.registerClass(Qu);var tl=function(t){function n(e){var n=t.call(this,e)||this;return n.cells=e.cells,n}return di(n,t),Object.defineProperty(n.prototype,"stateSize",{get:function(){for(var t=[],e=0,n=this.cells.slice().reverse();e<n.length;e++){var r=n[e];Array.isArray(r.stateSize)?t.push.apply(t,r.stateSize):t.push(r.stateSize)}return t},enumerable:!0,configurable:!0}),n.prototype.call=function(t,n){var r=this;return e.tidy((function(){for(var e=(t=t).slice(1),i=[],a=0,s=r.cells.slice().reverse();a<s.length;a++){var o=s[a];Array.isArray(o.stateSize)?i.push(e.splice(0,o.stateSize.length)):i.push(e.splice(0,1))}i.reverse();for(var u,l=[],c=0;c<r.cells.length;++c){o=r.cells[c];e=i[c],u=0===c?[t[0]].concat(e):[u[0]].concat(e),u=o.call(u,n),l.push(u.slice(1))}e=[];for(var h=0,p=l.slice().reverse();h<p.length;h++){var d=p[h];e.push.apply(e,d)}return[u[0]].concat(e)}))},n.prototype.build=function(t){var e;us(t)&&(t=t[0]),t=t,this.cells.forEach((function(n,r){ca("RNNCell_"+r,(function(){n.build(t),e=Array.isArray(n.stateSize)?n.stateSize[0]:n.stateSize,t=[t[0],e]}))})),this.built=!0},n.prototype.getConfig=function(){var e=t.prototype.getConfig.call(this),n=this.cells.map((function(t){return{className:t.getClassName(),config:t.getConfig()}}));return gi({},e,{cells:n})},n.fromConfig=function(t,e,n){void 0===n&&(n={});for(var r=[],i=0,a=e.cells;i<a.length;i++){var s=a[i];r.push(Ms(s,n))}return new t({cells:r})},Object.defineProperty(n.prototype,"trainableWeights",{get:function(){if(!this.trainable)return[];for(var t=[],e=0,n=this.cells;e<n.length;e++){var r=n[e];t.push.apply(t,r.trainableWeights)}return t},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"nonTrainableWeights",{get:function(){for(var t=[],e=0,n=this.cells;e<n.length;e++){var r=n[e];t.push.apply(t,r.nonTrainableWeights)}if(!this.trainable){for(var i=[],a=0,s=this.cells;a<s.length;a++){r=s[a];i.push.apply(i,r.trainableWeights)}return i.concat(t)}return t},enumerable:!0,configurable:!0}),n.prototype.getWeights=function(){for(var t=[],e=0,n=this.cells;e<n.length;e++){var r=n[e];t.push.apply(t,r.weights)}return gs(t)},n.prototype.setWeights=function(t){for(var e=[],n=0,r=this.cells;n<r.length;n++)for(var i=r[n],a=i.weights.length,s=t.splice(a),o=0;o<i.weights.length;++o)e.push([i.weights[o],s[o]]);ms(e)},n.className="StackedRNNCells",n}(Gu);function el(t){var n=t.ones,r=t.rate,i=t.training,a=void 0!==i&&i,s=t.count,o=void 0===s?1:s,u=function(){return La(n(),r)},l=function(){return _a(u,n,a)};return!o||o<=1?e.keep(l().clone()):Array(o).fill(void 0).map(l).map((function(t){return e.keep(t.clone())}))}e.serialization.registerClass(tl);!function(t){function e(){return null!==t&&t.apply(this,arguments)||this}di(e,t)}(Gu);var nl=function(t){function n(e){var n=this;if(e.unroll)throw new Si("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new Si("It is not possible at the moment to stack convolutional cells.");return(n=t.call(this,e)||this).inputSpec=[new ys({ndim:5})],n}return di(n,t),n.prototype.call=function(n,r){var i=this;return e.tidy((function(){if(null!=i.cell.dropoutMask&&(e.dispose(i.cell.dropoutMask),i.cell.dropoutMask=null),null!=i.cell.recurrentDropoutMask&&(e.dispose(i.cell.recurrentDropoutMask),i.cell.recurrentDropoutMask=null),r&&r.constants)throw new ki("ConvRNN2D cell does not support constants");var a=null==r?null:r.mask,s=null==r?null:r.training,o=null==r?null:r.initialState;return t.prototype.call.call(i,n,{mask:a,training:s,initialState:o})}))},n.prototype.computeOutputShape=function(t){var e=this.computeSingleOutputShape(t);return this.returnSequences||(e=[e[0]].concat(e.slice(2))),this.returnState&&(e=[e].concat(Array(2).fill([t[0]].concat(e.slice(-3))))),e},n.prototype.getInitialState=function(t){var n=this;return e.tidy((function(){var r=n.cell.stateSize,i=t.shape,a=n.computeSingleOutputShape(i),s=[a[0]].concat(a.slice(2)),o=e.zeros(s);return Array.isArray(r)?Array(r.length).fill(o):[o]}))},n.prototype.resetStates=function(t,n){var r=this;void 0===n&&(n=!1),e.tidy((function(){if(!r.stateful)throw new bi("Cannot call resetStates() on an RNN Layer that is not stateful.");var i=r.inputSpec[0].shape,a=r.computeSingleOutputShape(i),s=[a[0]].concat(a.slice(2));if(null==i[0])throw new ki("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==r.getStates())Array.isArray(r.cell.stateSize)?r.states_=r.cell.stateSize.map((function(){return e.zeros(s)})):r.states_=[e.zeros(s)];else if(null==t)e.dispose(r.states_),null!=r.keptStates&&(e.dispose(r.keptStates),r.keptStates=[]),Array.isArray(r.cell.stateSize)?r.states_=r.cell.stateSize.map((function(){return e.zeros(s)})):r.states_[0]=e.zeros(s);else{if(Array.isArray(t)||(t=[t]),t.length!==r.states_.length)throw new ki("Layer "+r.name+" expects "+r.states_.length+" state(s), but it received "+t.length+" state value(s). Input received: "+t);n?r.keptStates.push(r.states_.slice()):e.dispose(r.states_);for(var o=0;o<r.states_.length;++o){var u=t[o],l=s;if(!e.util.arraysEqual(u.shape,l))throw new ki("State "+o+" is incompatible with layer "+r.name+": expected shape="+l+", received shape="+u.shape);r.states_[o]=u}}r.states_=r.states_.map((function(t){return e.keep(t.clone())}))}))},n.prototype.computeSingleOutputShape=function(t){var e=this.cell,n=e.dataFormat,r=e.filters,i=e.kernelSize,a=e.padding,s=e.strides,o=e.dilationRate,u="channelsFirst"===n,l=t[u?3:2],c=t[u?4:3],h=Cu(l,i[0],a,s[0],o[0]),p=Cu(c,i[1],a,s[1],o[1]);return t.slice(0,2).concat(u?[r,h,p]:[h,p,r])},n.className="ConvRNN2D",n}(qu),rl=function(t){function n(e){var n=this,r=e.filters,i=e.kernelSize,a=e.strides,s=e.padding,o=e.dataFormat,u=e.dilationRate;return(n=t.call(this,gi({},e,{units:r}))||this).filters=r,$i(n.filters,"filters"),n.kernelSize=Au(i,2,"kernelSize"),n.kernelSize.forEach((function(t){return $i(t,"kernelSize")})),n.strides=Au(a||1,2,"strides"),n.strides.forEach((function(t){return $i(t,"strides")})),n.padding=s||"valid",oa(n.padding),n.dataFormat=o||"channelsLast",sa(n.dataFormat),n.dilationRate=Au(u||1,2,"dilationRate"),n.dilationRate.forEach((function(t){return $i(t,"dilationRate")})),n}return di(n,t),n.prototype.build=function(t){var n;t=hs(t);var r="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[r])throw new ki("The channel dimension of the input should be defined. Found "+t[r]);var i=t[r],a=this.kernelSize.concat([i,4*this.filters]);this.kernel=this.addWeight("kernel",a,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);var s=this.kernelSize.concat([this.filters,4*this.filters]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",s,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){var o=void 0;if(this.unitForgetBias){var u=this.biasInitializer,l=this.filters;o=new((n=function(t){function n(){return null!==t&&t.apply(this,arguments)||this}return di(n,t),n.prototype.apply=function(t,n){return xa([u.apply([l]),e.ones([l]),u.apply([2*l])])},n}(Ma)).className="CustomInit",n)}else o=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.filters],null,o,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0},n.prototype.call=function(t,n){var r=this;return e.tidy((function(){if(3!==t.length)throw new ki("ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got "+t.length+".");var i=n.training||!1,a=t[0],s=t[1],o=t[2];0<r.dropout&&r.dropout<1&&null==r.dropoutMask&&(r.dropoutMask=el({ones:function(){return e.onesLike(a)},rate:r.dropout,training:i,count:4}));var u=r.dropoutMask,l=function(t,n,r){return n&&n[r]?e.mul(n[r],t):t},c=l(a,u,0),h=l(a,u,1),p=l(a,u,2),d=l(a,u,3);0<r.recurrentDropout&&r.recurrentDropout<1&&null==r.recurrentDropoutMask&&(r.recurrentDropoutMask=el({ones:function(){return e.onesLike(s)},rate:r.recurrentDropout,training:i,count:4}));var f=r.recurrentDropoutMask,g=l(s,f,0),m=l(s,f,1),y=l(s,f,2),v=l(s,f,3),b=e.split(r.kernel.read(),4,3),w=b[0],k=b[1],S=b[2],N=b[3],x=r.useBias?e.split(r.bias.read(),4):[null,null,null,null],z=x[0],I=x[1],A=x[2],C=x[3];c=r.inputConv(c,w,z,r.padding),h=r.inputConv(h,k,I,r.padding),p=r.inputConv(p,S,A,r.padding),d=r.inputConv(d,N,C,r.padding);var T=e.split(r.recurrentKernel.read(),4,3),E=T[0],F=T[1],D=T[2],L=T[3];g=r.recurrentConv(g,E),m=r.recurrentConv(m,F),y=r.recurrentConv(y,D),v=r.recurrentConv(v,L);var _=r.recurrentActivation.apply(e.add(c,g)),R=r.recurrentActivation.apply(e.add(h,m)),O=e.add(e.mul(R,o),e.mul(_,r.activation.apply(e.add(p,y)))),M=e.mul(r.recurrentActivation.apply(e.add(d,v)),r.activation.apply(O));return[M,M,O]}))},n.prototype.getConfig=function(){var e=t.prototype.getConfig.call(this),n=(e.units,function(t,e){var n={};for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&e.indexOf(r)<0&&(n[r]=t[r]);if(null!=t&&"function"==typeof Object.getOwnPropertySymbols){var i=0;for(r=Object.getOwnPropertySymbols(t);i<r.length;i++)e.indexOf(r[i])<0&&Object.prototype.propertyIsEnumerable.call(t,r[i])&&(n[r[i]]=t[r[i]])}return n}(e,["units"])),r={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return gi({},n,r)},n.prototype.inputConv=function(t,n,r,i){var a=e.conv2d(t,n,this.strides,i||"valid","channelsFirst"===this.dataFormat?"NCHW":"NHWC",this.dilationRate);return r?Da(a,r,this.dataFormat):a},n.prototype.recurrentConv=function(t,n){return e.conv2d(t,n,1,"same","channelsFirst"===this.dataFormat?"NCHW":"NHWC")},n.className="ConvLSTM2DCell",n}(Xu);e.serialization.registerClass(rl);var il=function(t){function e(e){var n=new rl(e);return t.call(this,gi({},e,{cell:n}))||this}return di(e,t),e.fromConfig=function(t,e){return new t(e)},e.className="ConvLSTM2D",e}(nl);e.serialization.registerClass(il);var al=function(t){function n(e){var n=t.call(this,e)||this;return n.rate=Math.max(Math.min(e.rate,1),0),n.noiseShape=e.noiseShape,n.seed=e.seed,n.supportsMasking=!0,n}return di(n,t),n.prototype.getNoiseShape=function(t){if(null==this.noiseShape)return this.noiseShape;for(var e=t.shape,n=[],r=0;r<this.noiseShape.length;++r)n.push(null==this.noiseShape[r]?e[r]:this.noiseShape[r]);return n},n.prototype.call=function(t,n){var r=this;return e.tidy((function(){r.invokeCallHook(t,n);var e=cs(t);if(0<r.rate&&r.rate<1){var i=null!=n.training&&n.training,a=r.getNoiseShape(e);return _a((function(){return La(e,r.rate,a,r.seed)}),(function(){return e}),i)}return t}))},n.prototype.getConfig=function(){var e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},n=t.prototype.getConfig.call(this);return Object.assign(e,n),e},n.prototype.dispose=function(){return t.prototype.dispose.call(this)},n.className="Dropout",n}(Ss);e.serialization.registerClass(al);var sl=function(t){function e(e){var n=t.call(this,e)||this;return n.inputSpec=[{ndim:3}],n}return di(e,t),e.prototype.getNoiseShape=function(t){var e=t.shape;return[e[0],1,e[2]]},e.className="SpatialDropout1D",e}(al);e.serialization.registerClass(sl);var ol=function(t){function n(e){var n=t.call(this,e)||this;if(n.activation=null,n.useBias=!0,n.kernel=null,n.bias=null,n.DEFAULT_KERNEL_INITIALIZER="glorotNormal",n.DEFAULT_BIAS_INITIALIZER="zeros",null==e.batchInputShape&&null==e.inputShape&&null!=e.inputDim){var r=null;null!=e.batchSize&&(r=e.batchSize),n.batchInputShape=[r,e.inputDim]}return n.units=e.units,$i(n.units,"units"),n.activation=du(e.activation),null!=e.useBias&&(n.useBias=e.useBias),n.kernelInitializer=ns(e.kernelInitializer||n.DEFAULT_KERNEL_INITIALIZER),n.biasInitializer=ns(e.biasInitializer||n.DEFAULT_BIAS_INITIALIZER),n.kernelConstraint=Xi(e.kernelConstraint),n.biasConstraint=Xi(e.biasConstraint),n.kernelRegularizer=wu(e.kernelRegularizer),n.biasRegularizer=wu(e.biasRegularizer),n.activityRegularizer=wu(e.activityRegularizer),n.supportsMasking=!0,n.inputSpec=[{minNDim:2}],n}return di(n,t),n.prototype.build=function(t){var e,n=(t=hs(t))[t.length-1];null==this.kernel&&(this.kernel=this.addWeight("kernel",[n,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:(e={},e[-1]=n,e)}],this.built=!0},n.prototype.computeOutputShape=function(t){var e=(t=hs(t)).slice();return e[e.length-1]=this.units,e},n.prototype.call=function(t,n){var r=this;return e.tidy((function(){r.invokeCallHook(t,n);var e,i=cs(t),a=Ui(r.activation.getClassName());return null!=a?e=Ca(i,r.kernel.read(),a,r.bias?r.bias.read():null):(e=Ca(i,r.kernel.read()),null!=r.bias&&(e=Da(e,r.bias.read())),null!=r.activation&&(e=r.activation.apply(e))),e}))},n.prototype.getConfig=function(){var e={units:this.units,activation:hu(this.activation),useBias:this.useBias,kernelInitializer:es(this.kernelInitializer),biasInitializer:es(this.biasInitializer),kernelRegularizer:vu(this.kernelRegularizer),biasRegularizer:vu(this.biasRegularizer),activityRegularizer:vu(this.activityRegularizer),kernelConstraint:Zi(this.kernelConstraint),biasConstraint:Zi(this.biasConstraint)},n=t.prototype.getConfig.call(this);return Object.assign(e,n),e},n.className="Dense",n}(Ss);e.serialization.registerClass(ol);var ul=function(t){function n(e){var n=this;return e=e||{},(n=t.call(this,e)||this).inputSpec=[{minNDim:3}],n.dataFormat=e.dataFormat,n}return di(n,t),n.prototype.computeOutputShape=function(t){for(var e=0,n=(t=hs(t)).slice(1);e<n.length;e++){if(null==n[e])throw new ki('The shape of the input to "Flatten" is not fully defined (got '+t.slice(1)+'). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.')}return[t[0],ga(t,1)]},n.prototype.call=function(t,n){var r=this;return e.tidy((function(){r.invokeCallHook(t,n);var i=cs(t);if("channelsFirst"===r.dataFormat&&i.rank>1){for(var a=[0],s=2;s<i.rank;++s)a.push(s);a.push(1),i=e.transpose(i,a)}return function(t){if(t.rank<=1)throw new ki("batchFlatten requires a minimum rank of 2. Got rank: "+t.rank+".");var n=[t.shape[0],ga(t.shape,1)];return e.reshape(t,n)}(i)}))},n.prototype.getConfig=function(){var e={};null!=this.dataFormat&&(e.dataFormat=this.dataFormat);var n=t.prototype.getConfig.call(this);return Object.assign(e,n),e},n.className="Flatten",n}(Ss);e.serialization.registerClass(ul);var ll=function(t){function n(e){var n=t.call(this,e)||this;return n.supportsMasking=!0,n.activation=du(e.activation),n}return di(n,t),n.prototype.call=function(t,n){var r=this;return e.tidy((function(){r.invokeCallHook(t,n);var e=cs(t);return r.activation.apply(e)}))},n.prototype.getConfig=function(){var e={activation:hu(this.activation)},n=t.prototype.getConfig.call(this);return Object.assign(e,n),e},n.className="Activation",n}(Ss);e.serialization.registerClass(ll);var cl=function(t){function n(e){var n=t.call(this,e)||this;return n.n=e.n,n.inputSpec=[{ndim:2}],n}return di(n,t),n.prototype.computeOutputShape=function(t){return[t[0],this.n,t[1]]},n.prototype.call=function(t,n){var r=this;return e.tidy((function(){return t=cs(t),n=t,i=r.n,e.tidy((function(){if(2!==n.shape.length)throw new ki("repeat() expects a rank-2 tensor, but received a rank-"+n.shape.length+" tensor.");return Ia(wa(n,1),[1,i,1])}));var n,i}))},n.prototype.getConfig=function(){var e={n:this.n},n=t.prototype.getConfig.call(this);return Object.assign(e,n),e},n.className="RepeatVector",n}(Ss);e.serialization.registerClass(cl);var hl=function(t){function n(e){var n=t.call(this,e)||this;n.targetShape=e.targetShape;for(var r=0;r<n.targetShape.length;++r)n.isUnknown(n.targetShape[r])&&(n.targetShape[r]=null);return n}return di(n,t),n.prototype.isUnknown=function(t){return t<0||null==t},n.prototype.fixUnknownDimension=function(t,e){for(var n="Total size of new array must be unchanged.",r=e.slice(),i=1,a=null,s=0;s<r.length;++s){var o=r[s];if(this.isUnknown(o)){if(null!==a)throw new ki("Can only specifiy one unknown dimension.");a=s}else i*=o}var u=ga(t);if(null!==a){if(0===i||u%i!=0)throw new ki(n);r[a]=u/i}else if(u!==i)throw new ki(n);return r},n.prototype.computeOutputShape=function(t){for(var e=!1,n=0;n<t.length;++n)if(this.isUnknown(t[n])){e=!0;break}return e?t.slice(0,1).concat(this.targetShape):t.slice(0,1).concat(this.fixUnknownDimension(t.slice(1),this.targetShape))},n.prototype.call=function(t,n){var r=this;return e.tidy((function(){r.invokeCallHook(t,n);var i=cs(t),a=i.shape,s=a.slice(0,1).concat(r.fixUnknownDimension(a.slice(1),r.targetShape));return e.reshape(i,s)}))},n.prototype.getConfig=function(){var e={targetShape:this.targetShape},n=t.prototype.getConfig.call(this);return Object.assign(e,n),e},n.className="Reshape",n}(Ss);e.serialization.registerClass(hl);var pl=function(t){function n(n){var r=t.call(this,n)||this;if(null==n.dims)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(n.dims))throw new Error("Permute constructor requires `dims` to be an Array, but received "+n.dims+" instead.");var i=va(1,n.dims.length+1);if(!e.util.arraysEqual(n.dims.slice().sort(),i))throw new Error("Invalid permutation `dims`: "+JSON.stringify(n.dims)+" `dims` must contain consecutive integers starting from 1.");return r.dims=n.dims,r.dimsIncludingBatch=[0].concat(r.dims),r.inputSpec=[new ys({ndim:r.dims.length+1})],r}return di(n,t),n.prototype.computeOutputShape=function(t){var e=(t=hs(t)).slice();return this.dims.forEach((function(n,r){e[r+1]=t[n]})),e},n.prototype.call=function(t,n){return e.transpose(cs(t),this.dimsIncludingBatch)},n.prototype.getConfig=function(){var e={dims:this.dims},n=t.prototype.getConfig.call(this);return Object.assign(e,n),e},n.className="Permute",n}(Ss);e.serialization.registerClass(pl);var dl=function(t){function n(e){var n=t.call(this,null==e?{}:e)||this;return n.supportsMasking=!0,n.maskValue=null!=e?null==e.maskValue?0:e.maskValue:0,n}return di(n,t),n.prototype.computeOutputShape=function(t){return t},n.prototype.getConfig=function(){var e=t.prototype.getConfig.call(this),n={maskValue:this.maskValue};return Object.assign(n,e),n},n.prototype.computeMask=function(t,n){var r=cs(t);return e.any(e.notEqual(r,this.maskValue),-1)},n.prototype.call=function(t,n){var r=this;return e.tidy((function(){r.invokeCallHook(t,n);var i=cs(t),a=e.any(e.notEqual(i,r.maskValue),-1,!0);return e.mul(i,e.cast(a,i.dtype))}))},n.className="Masking",n}(Ss);e.serialization.registerClass(dl);var fl=function(t){function n(e){var n=t.call(this,e)||this;if(n.embeddings=null,n.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",null==e.batchInputShape&&null==e.inputShape){var r=null;null!=e.batchSize&&(r=e.batchSize),null==e.inputLength?n.batchInputShape=[r,null]:n.batchInputShape=[r].concat(Ci(e.inputLength))}return n.inputDim=e.inputDim,$i(n.inputDim,"inputDim"),n.outputDim=e.outputDim,$i(n.outputDim,"outputDim"),n.embeddingsInitializer=ns(e.embeddingsInitializer||n.DEFAULT_EMBEDDINGS_INITIALIZER),n.embeddingsRegularizer=wu(e.embeddingsRegularizer),n.activityRegularizer=wu(e.activityRegularizer),n.embeddingsConstraint=Xi(e.embeddingsConstraint),n.maskZero=e.maskZero,n.supportsMasking=e.maskZero,n.inputLength=e.inputLength,n}return di(n,t),n.prototype.build=function(t){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0},n.prototype.warnOnIncompatibleInputShape=function(t){},n.prototype.computeMask=function(t,n){var r=this;return e.tidy((function(){return r.maskZero?(t=cs(t),e.notEqual(t,e.zerosLike(t))):null}))},n.prototype.computeOutputShape=function(t){if(t=hs(t),null==this.inputLength)return t.concat([this.outputDim]);var e=Ci(this.inputLength);if(e.length!==t.length-1)throw new ki('"inputLength" is '+this.inputLength+", but received input shape has shape "+t);for(var n=0,r=0;r<e.length;++r){var i=e[r],a=t[r+1];if(null!=i&&null!=a&&i!==a)throw new ki('"inputLength" is '+this.inputLength+", but received input shape has shape "+t);null==i&&(e[n]=a),n++}return[t[0]].concat(e,[this.outputDim])},n.prototype.call=function(t,n){var r=this;return e.tidy((function(){r.invokeCallHook(t,n);var i=cs(t);"int32"!==i.dtype&&(i=ba(i,"int32"));var a=Ta(r.embeddings.read(),e.reshape(i,[i.size]));return e.reshape(a,hs(r.computeOutputShape(i.shape)))}))},n.prototype.getConfig=function(){var e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:es(this.embeddingsInitializer),embeddingsRegularizer:vu(this.embeddingsRegularizer),activityRegularizer:vu(this.activityRegularizer),embeddingsConstraint:Zi(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},n=t.prototype.getConfig.call(this);return Object.assign(e,n),e},n.className="Embedding",n}(Ss);e.serialization.registerClass(fl);var gl=function(t){function n(e){var n=t.call(this,e||{})||this;return n.supportsMasking=!0,n}return di(n,t),n.prototype.mergeFunction=function(t){throw new Si},n.prototype.computeElementwiseOpOutputShape=function(t,e){if(null==t||null==e)return null;if(t.length<e.length)return this.computeElementwiseOpOutputShape(e,t);if(0===e.length)return t;for(var n=t.slice(0,t.length-e.length),r=0;r<e.length;++r){var i=t[t.length-e.length+r],a=e[r];if(null==i||null==a||i<0||a<0)n.push(null);else if(1===i)n.push(a);else if(1===a)n.push(i);else{if(i!==a)throw new ki("Operands could not be broadcast together with shapes "+JSON.stringify(t)+" "+JSON.stringify(e));n.push(i)}}return n},n.prototype.build=function(t){if(Array.isArray(t)&&!Array.isArray(t[0])&&(t=[hs(t)]),(t=t).length<2)throw new ki("A merge layer should be called on an Array of at least 2 inputs. Got "+t.length+" input(s).");for(var e=[],n=0,r=t;n<r.length;n++){null!=(s=r[n])&&null!==s[0]&&e.push(s[0])}if((e=Oi(e)).length>1)throw new ki("Can not merge tensors with different batch sizes. Got tensors with shapes: "+JSON.stringify(t)+".");for(var i=null==t[0]?null:t[0].slice(1),a=1;a<t.length;++a){var s=null==t[a]?null:t[a].slice(1);i=this.computeElementwiseOpOutputShape(i,s)}var o=t.map((function(t){return t.length}));-1===t.indexOf(null)&&1===Oi(o).length?this.reshapeRequired=!1:this.reshapeRequired=!0},n.prototype.call=function(t,n){var r=this;return e.tidy((function(){if(t=t,r.reshapeRequired){var n=[],i=t.map((function(t){return t.rank}));if(-1===i.indexOf(null)){for(var a=ya(i),s=0,o=t;s<o.length;s++){for(var u=(d=o[s]).rank,l=0;l<a-u;++l)d=wa(d,1);n.push(d)}return r.mergeFunction(n)}for(var c=!1,h=0,p=t;h<p.length;h++){var d;if(null==(u=(d=p[h]).rank)){var f=d.shape,g=f[0],m=f.slice(1).concat([g]),y=e.reshape(d,[g].concat(ga(f.slice(1))));y=e.transpose(y,[1,0]),y=e.reshape(y,m),n.push(y),c=!0}else if(u>1){var v=va(1,u).concat([0]);n.push(e.transpose(d,v)),c=!0}else n.push(d)}var b=r.mergeFunction(n),w=b.rank;if(c)if(null==w){var k=b.shape;m=[g=k[k.length-1]].concat(k.slice(0,k.length-1));b=e.reshape(e.transpose(e.reshape(b,[-1,g]),[1,0]),m)}else if(w>1){v=[w-1].concat(va(0,w-1));b=e.transpose(b,v)}return b}return r.mergeFunction(t)}))},n.prototype.computeOutputShape=function(t){var e;e=null==(t=t)[0]?null:t[0].slice(1);for(var n=1;n<t.length;++n){var r=null==t[n]?null:t[n].slice(1);e=this.computeElementwiseOpOutputShape(e,r)}for(var i=[],a=0,s=t;a<s.length;a++){null!=(r=s[a])&&null!==r[0]&&i.push(r[0])}return e=1===(i=Oi(i)).length?i.concat(e):[null].concat(e)},n.prototype.computeMask=function(t,n){return e.tidy((function(){if(null==n)return null;if(!Array.isArray(n))throw new ki("`mask` should be an Array");if(!Array.isArray(t))throw new ki("`inputs` should be an Array");if(n.length!==t.length)throw new ki("The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths ("+t.length+" vs "+n.length+")");if(n.every((function(t){return null==t})))return null;for(var r=(n=n.map((function(t){return null==t?t:e.expandDims(t,0)})))[0],i=1;i<n.length-1;++i)r=e.logicalAnd(r,n[i]);return r}))},n}(Ss),ml=function(t){function n(e){return t.call(this,e)||this}return di(n,t),n.prototype.mergeFunction=function(t){return e.tidy((function(){for(var n=t[0].clone(),r=1;r<t.length;++r)n=e.add(n,t[r]);return n}))},n.className="Add",n}(gl);e.serialization.registerClass(ml);var yl=function(t){function n(e){return t.call(this,e)||this}return di(n,t),n.prototype.mergeFunction=function(t){return e.tidy((function(){for(var n=t[0].clone(),r=1;r<t.length;++r)n=e.mul(n,t[r]);return n}))},n.className="Multiply",n}(gl);e.serialization.registerClass(yl);var vl=function(t){function n(e){return t.call(this,e)||this}return di(n,t),n.prototype.mergeFunction=function(t){return e.tidy((function(){for(var n=t[0].clone(),r=1;r<t.length;++r)n=e.add(n,t[r]);return e.mul(1/t.length,n)}))},n.className="Average",n}(gl);e.serialization.registerClass(vl);var bl=function(t){function n(e){return t.call(this,e)||this}return di(n,t),n.prototype.mergeFunction=function(t){return e.tidy((function(){for(var n=t[0],r=1;r<t.length;++r)n=e.maximum(n,t[r]);return n}))},n.className="Maximum",n}(gl);e.serialization.registerClass(bl);var wl=function(t){function n(e){return t.call(this,e)||this}return di(n,t),n.prototype.mergeFunction=function(t){return e.tidy((function(){for(var n=t[0],r=1;r<t.length;++r)n=e.minimum(n,t[r]);return n}))},n.className="Minimum",n}(gl);e.serialization.registerClass(wl);var kl=function(t){function n(e){var n=t.call(this,e)||this;return n.DEFAULT_AXIS=-1,null==e&&(e={}),n.axis=null==e.axis?n.DEFAULT_AXIS:e.axis,n.supportsMasking=!0,n.reshapeRequired=!1,n}return di(n,t),n.prototype.build=function(t){if(!Array.isArray(t)||!Array.isArray(t[0])||1===t.length)throw new ki("A `Concatenate` layer should be called on a list of at least 2 inputs");for(var n=!0,r=0,i=t=t;r<i.length;r++){if(null!=(h=i[r])){n=!1;break}}if(!n){for(var a=[],s=0;s<t.length;++s){var o=t[s].slice();o.splice(this.axis,1);for(var u=!1,l=0,c=a;l<c.length;l++){var h=c[l];if(e.util.arraysEqual(h,o)){u=!0;break}}u||a.push(o)}if(a.length>1)throw new ki("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(t))}},n.prototype.mergeFunction=function(t){var n=this;return e.tidy((function(){return xa(t,n.axis)}))},n.prototype.computeOutputShape=function(t){if(!Array.isArray(t)||!Array.isArray(t[0]))throw new ki("A `Concatenate` layer should be called on a list of inputs.");for(var e=t,n=e[0].slice(),r=this.axis<0?n.length+this.axis:this.axis,i=0,a=e.slice(1);i<a.length;i++){var s=a[i];if(null==n[r]||null==s[r]){n[r]=null;break}n[r]+=s[r]}return n},n.prototype.computeMask=function(t,n){var r=this;if(null==n)return null;if(!Array.isArray(n))throw new ki("`mask` should be an array for Concatenate");if(!Array.isArray(t))throw new ki("`inputs` should be an array for Concatenate");if(n.length!==t.length)throw new ki("Mismatch in the length of mask ("+n.length+") and the legnth of inputs ("+t.length+")");return e.tidy((function(){var i=!0;if(n.forEach((function(t){null==t||(i=!1)})),i)return null;for(var a=[],s=0;s<t.length;++s)null==n[s]?a.push(e.cast(e.onesLike(t[s]),"bool")):n[s].rank<t[s].rank?a.push(e.expandDims(n[s],-1)):a.push(n[s]);var o=e.concat(a,r.axis);return e.all(o,-1,!1)}))},n.prototype.getConfig=function(){var e={axis:this.axis},n=t.prototype.getConfig.call(this);return Object.assign(e,n),e},n.className="Concatenate",n}(gl);function Sl(t,e){for(;t<0;)t+=e;return t}e.serialization.registerClass(kl);var Nl=function(t){function n(e){var n=t.call(this,e)||this;return n.axes=e.axes,n.normalize=null!=e.normalize&&e.normalize,n.supportsMasking=!0,n.reshapeRequired=!1,n}return di(n,t),n.prototype.build=function(t){e.util.assert(Array.isArray(t)&&2===t.length&&Array.isArray(t[0])&&Array.isArray(t[1]),(function(){return"A `Dot` layer should be called on a list of exactly 2 inputs."}));var n=t[0],r=t[1];if(n.length>3||r.length>3)throw new Si("Dot layer does not support tensors of 4D or higher rank yet.");var i=this.interpretAxes(n,r);if(n[i[0]]!==r[i[1]])throw new ki("Dimension incompatibility: "+n[i[0]]+" !== "+r[i[1]])},n.prototype.mergeFunction=function(t){if(2!==t.length)throw new ki("A `Dot` layer must be called on exactly 2 inputs, but received "+t.length+" input(s).");var n,r=t[0],i=t[1];return n=Array.isArray(this.axes)?this.axes.map((function(e,n){return Sl(e,t[n].shape.length)})):[Sl(this.axes,r.shape.length),Sl(this.axes,i.shape.length)],this.normalize&&(r=Bs(r,n[0]),i=Bs(i,n[1])),function(t,n,r){if(t.shape.length>3||n.shape.length>3)throw new Si("batchDot is not implemented for tensors of 4D or higher rank yet");if(e.util.assert(t.shape.length>=2,(function(){return"batchDot requires the rank of x to be >= 2, but got "+t.shape.length})),e.util.assert(t.shape.length>=2,(function(){return"batchDot requires the rank of y to be >= 2, but got "+n.shape.length})),"number"==typeof r&&(r=[r,r]),"complex64"===t.dtype||"complex64"===n.dtype)throw new Si("batchDot is not implemented for complex64-type Tensors yet.");var i=t.shape.length,a=n.shape.length;null==r&&(r=[i-1,a-2]);var s=r;return e.tidy((function(){var r,o;if(i>a){r=i-a;for(var u=[],l=0;l<r;++l)u.push(1);n=e.reshape(n,n.shape.concat(u))}else if(a>i){for(r=a-i,u=[],l=0;l<r;++l)u.push(1);t=e.reshape(t,t.shape.concat(u))}else r=0;if(2===t.shape.length&&2===n.shape.length)o=s[0]===s[1]?e.sum(e.mul(t,n),s[0]):e.sum(e.mul(e.transpose(t,[1,0]),n),s[1]);else{var c=s[0]!==t.shape.length-1,h=s[1]===n.shape.length-1;o=e.matMul(t,n,c,h)}if(r>0){var p=void 0,d=[];for(l=p=i>a?i+a-3:i-1;l<p+r;++l)d.push(l);o=e.squeeze(o,d)}return 1===o.shape.length&&(o=e.expandDims(o,1)),o}))}(r,i,n)},n.prototype.interpretAxes=function(t,e){return Array.isArray(this.axes)?this.axes:[Sl(this.axes,t.length),Sl(this.axes,e.length)]},n.prototype.computeOutputShape=function(t){e.util.assert(Array.isArray(t)&&2===t.length&&Array.isArray(t[0])&&Array.isArray(t[1]),(function(){return"A `Dot` layer should be called on a list of exactly 2 inputs."}));var n=t[0].slice(),r=t[1].slice();if(n.length>3||r.length>3)throw new Si("Dot layer does not support tensors of 4D or higher rank yet.");var i=this.interpretAxes(n,r);n.splice(i[0],1),r.splice(i[1],1),r.splice(0,1);var a=n.concat(r);return 1===a.length&&a.push(1),a},n.prototype.computeMask=function(t,e){return null},n.prototype.getConfig=function(){var e={axes:this.axes,normalize:this.normalize},n=t.prototype.getConfig.call(this);return Object.assign(e,n),e},n.className="Dot",n}(gl);e.serialization.registerClass(Nl);var xl=function(t){function n(e){var n=t.call(this,e)||this;return n.supportsMasking=!0,n.stddev=e.stddev,n}return di(n,t),n.prototype.computeOutputShape=function(t){return t},n.prototype.getConfig=function(){var e=t.prototype.getConfig.call(this),n={stddev:this.stddev};return Object.assign(n,e),n},n.prototype.call=function(t,n){var r=this;return e.tidy((function(){r.invokeCallHook(t,n);var i=cs(t);return _a((function(){return e.add(Aa(i.shape,0,r.stddev),i)}),(function(){return i}),n.training||!1)}))},n.className="GaussianNoise",n}(Ss);e.serialization.registerClass(xl);var zl=function(t){function n(e){var n=t.call(this,e)||this;return n.supportsMasking=!0,n.rate=e.rate,n}return di(n,t),n.prototype.computeOutputShape=function(t){return t},n.prototype.getConfig=function(){var e=t.prototype.getConfig.call(this),n={rate:this.rate};return Object.assign(n,e),n},n.prototype.call=function(t,n){var r=this;return e.tidy((function(){r.invokeCallHook(t,n);var i=cs(t);if(r.rate>0&&r.rate<1){return _a((function(){var t=Math.sqrt(r.rate/(1-r.rate));return e.mul(i,Aa(i.shape,1,t))}),(function(){return i}),n.training||!1)}return i}))},n.className="GaussianDropout",n}(Ss);e.serialization.registerClass(zl);var Il=function(t){function n(e){var n=t.call(this,e)||this;return n.supportsMasking=!0,n.rate=e.rate,n.noiseShape=e.noiseShape,n}return di(n,t),n.prototype._getNoiseShape=function(t){return this.noiseShape||cs(t).shape},n.prototype.computeOutputShape=function(t){return t},n.prototype.getConfig=function(){var e=t.prototype.getConfig.call(this),n={rate:this.rate};return Object.assign(n,e),n},n.prototype.call=function(t,n){var r=this;return e.tidy((function(){if(r.rate<1&&r.rate>0){var i=r._getNoiseShape(t);return _a((function(){var n=cs(t),a=-1.7580993408473766,s=e.greaterEqual(e.randomUniform(i),r.rate);s=ba(s,"float32");var o=Math.pow((1-r.rate)*(1+r.rate*Math.pow(a,2)),-.5),u=-o*a*r.rate,l=e.add(e.mul(n,s),e.mul(e.add(s,-1),a));return e.add(e.mul(l,o),u)}),(function(){return cs(t)}),n.training||!1)}return t}))},n.className="AlphaDropout",n}(Ss);function Al(t,n,r,i,a,s){var o;if(void 0===s&&(s=.001),2===t.rank)o=e.batchNorm2d(t,n,r,i,a,s);else if(3===t.rank)o=e.batchNorm3d(t,n,r,i,a,s);else{if(4!==t.rank)throw new Si("batchNormalization is not implemented for array of rank "+t.rank+" yet");o=e.batchNorm4d(t,n,r,i,a,s)}return o}function Cl(t,n,r,i,a){return void 0===a&&(a=.001),e.util.arraysEqual(i.slice().sort(),va(0,t.rank-1))?function(t,n,r,i,a){return void 0===a&&(a=.001),e.tidy((function(){var s=e.moments(t,i),o=s.mean,u=s.variance;return[Al(t,o,u,r,n,a),o,u]}))}(t,n,r,i,a):function(t,n,r,i,a){return void 0===a&&(a=.001),e.tidy((function(){for(var s=e.moments(t,i),o=s.mean,u=s.variance,l=[],c=0,h=va(0,t.rank);c<h.length;c++){var p=h[c];-1!==i.indexOf(p)?l.push(1):l.push(t.shape[p])}var d=e.reshape(o,l),f=e.reshape(u,l),g=null==n?null:e.reshape(n,l),m=null==r?null:e.reshape(r,l);return[Al(t,d,f,m,g,a),o,u]}))}(t,n,r,i,a)}e.serialization.registerClass(Il);var Tl=function(t){function n(e){var n=this;return null==e&&(e={}),(n=t.call(this,e)||this).supportsMasking=!0,n.axis=null==e.axis?-1:e.axis,n.momentum=null==e.momentum?.99:e.momentum,n.epsilon=null==e.epsilon?.001:e.epsilon,n.center=null==e.center||e.center,n.scale=null==e.scale||e.scale,n.betaInitializer=ns(e.betaInitializer||"zeros"),n.gammaInitializer=ns(e.gammaInitializer||"ones"),n.movingMeanInitializer=ns(e.movingMeanInitializer||"zeros"),n.movingVarianceInitializer=ns(e.movingVarianceInitializer||"ones"),n.betaConstraint=Xi(e.betaConstraint),n.gammaConstraint=Xi(e.gammaConstraint),n.betaRegularizer=wu(e.betaRegularizer),n.gammaRegularizer=wu(e.gammaRegularizer),n}return di(n,t),n.prototype.build=function(t){var e;t=hs(t);var n=this.axis>=0?this.axis:this.axis+t.length,r=t[n];if(null==r)throw new ki("Axis "+n+" of input tensor should have a defined dimension but the layer received an input with shape "+JSON.stringify(t)+".");this.inputSpec=[new ys({ndim:t.length,axes:(e={},e[n]=r,e)})];var i=[r];this.scale&&(this.gamma=this.addWeight("gamma",i,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",i,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",i,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",i,null,this.movingVarianceInitializer,null,!1),this.built=!0},n.prototype.call=function(t,n){var r=this;return e.tidy((function(){var i=null!=n.training&&n.training,a=cs(t),s=a.shape,o=s.length,u=va(0,o),l=r.axis>=0?r.axis:r.axis+o;u.splice(l,1);var c=xi(1,o);c[l]=s[l];var h=u.slice();h.sort();var p=!e.util.arraysEqual(h,va(0,o).slice(0,o-1));if(!i)return function(){if(p){var t=e.reshape(r.movingMean.read(),c),n=e.reshape(r.movingVariance.read(),c),i=r.center?e.reshape(r.beta.read(),c):null,s=r.scale?e.reshape(r.gamma.read(),c):null;return Al(a,t,n,i,s,r.epsilon)}return Al(a,r.movingMean.read(),r.movingVariance.read(),null==r.beta?null:r.beta.read(),null==r.gamma?null:r.gamma.read(),r.epsilon)}();var d=Cl(a,r.gamma.read(),r.beta.read(),u,r.epsilon),f=d[0],g=d[1],m=d[2],y=function(t,n,r){e.tidy((function(){var i=1-r,a=t.read(),s=e.mul(e.sub(a,n),i);t.write(e.sub(a,s))}))};return y(r.movingMean,g,r.momentum),y(r.movingVariance,m,r.momentum),f}))},n.prototype.getConfig=function(){var e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:es(this.betaInitializer),gammaInitializer:es(this.gammaInitializer),movingMeanInitializer:es(this.movingMeanInitializer),movingVarianceInitializer:es(this.movingVarianceInitializer),betaRegularizer:vu(this.betaRegularizer),gammaRegularizer:vu(this.gammaRegularizer),betaConstraint:Zi(this.betaConstraint),gammaConstraint:Zi(this.gammaConstraint)},n=t.prototype.getConfig.call(this);return Object.assign(e,n),e},n.className="BatchNormalization",n}(Ss);e.serialization.registerClass(Tl);var El=function(t){function n(e){var n=this;if(null==e&&(e={}),(n=t.call(this,e)||this).axis=null==e.axis?-1:e.axis,"number"==typeof n.axis){if(!Number.isInteger(n.axis))throw new Error("Expected axis to be an integer, but received "+n.axis)}else{if(!Array.isArray(n.axis))throw new Error("Expected axis to be an integer or an array of integers, but received "+JSON.stringify(n.axis));for(var r=0,i=n.axis;r<i.length;r++){var a=i[r];if(!Number.isInteger(a))throw new Error("Expected axis to be an array of integers, but received "+JSON.stringify(n.axis))}}return n.epsilon=null==e.epsilon?.001:e.epsilon,n.center=null==e.center||e.center,n.scale=null==e.scale||e.scale,n.betaInitializer=ns(e.betaInitializer||"zeros"),n.gammaInitializer=ns(e.gammaInitializer||"ones"),n.betaRegularizer=wu(e.betaRegularizer),n.gammaRegularizer=wu(e.gammaRegularizer),n.supportsMasking=!0,n}return di(n,t),n.prototype.build=function(t){var e=(t=hs(t)).length;"number"==typeof this.axis&&(this.axis=[this.axis]);for(var n=0;n<this.axis.length;++n)this.axis[n]<0&&(this.axis[n]+=e);for(var r=0,i=this.axis;r<i.length;r++){var a=i[r];if(a<0||a>=e)throw new Error("Invalid axis: "+a)}if(this.axis.length!==Oi(this.axis).length)throw new Error("Found duplicate axes in: "+this.axis);var s=this.axis.map((function(e){return t[e]}));this.scale?this.gamma=this.addWeight("gamma",s,"float32",this.gammaInitializer,this.gammaRegularizer,true):this.gamma=null,this.center?this.beta=this.addWeight("beta",s,"float32",this.betaInitializer,this.betaRegularizer,true):this.beta=null,this.built=!0},n.prototype.call=function(t,n){var r=this,i=cs(t),a=i.shape,s=a.length;return e.tidy((function(){for(var t=e.moments(i,r.axis,!0),n=t.mean,o=t.variance,u=xi(1,s),l=0,c=r.axis;l<c.length;l++){var h=c[l];u[h]=a[h]}for(var p=function(t){return null!=t&&t.shape.length!==s&&r.axis!==[s-1]?e.reshape(t,u):t},d=p(r.gamma.read()),f=p(r.beta.read()),g=[],m=[],y=0;y<s;++y)-1!==r.axis.indexOf(y)?(g.push(a[y]),m.push(1)):(g.push(1),m.push(a[y]));return n=e.tile(n,g),o=e.tile(o,g),d=e.tile(d,m),f=e.tile(f,m),Al(i,n,o,f,d,r.epsilon)}))},n.prototype.getConfig=function(){var e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:es(this.betaInitializer),gammaInitializer:es(this.gammaInitializer),betaRegularizer:vu(this.betaRegularizer),gammaRegularizer:vu(this.gammaRegularizer)},n=t.prototype.getConfig.call(this);return Object.assign(e,n),e},n.className="LayerNormalization",n}(Ss);e.serialization.registerClass(El);var Fl=function(t){function n(e){var n=this;if(null==e&&(e={}),(n=t.call(this,e)||this).dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,null==e.padding)n.padding=[[1,1],[1,1]];else if("number"==typeof e.padding)n.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,2!==e.padding.length)throw new ki("ZeroPadding2D expects padding to be a length-2 array, but received a length-"+e.padding.length+" array.");var r=void 0,i=void 0;if("number"==typeof e.padding[0])r=[e.padding[0],e.padding[0]],i=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,2!==e.padding[0].length)throw new ki("ZeroPadding2D expects height padding to be a length-2 array, but received a length-"+e.padding[0].length+" array.");if(r=e.padding[0],2!==e.padding[1].length)throw new ki("ZeroPadding2D expects width padding to be a length-2 array, but received a length-"+e.padding[1].length+" array.");i=e.padding[1]}n.padding=[r,i]}return n.inputSpec=[new ys({ndim:4})],n}return di(n,t),n.prototype.computeOutputShape=function(t){var e,n;return t=hs(t),"channelsFirst"===this.dataFormat?(e=null!=t[2]&&t[2]>=0?t[2]+this.padding[0][0]+this.padding[0][1]:null,n=null!=t[3]&&t[3]>=0?t[3]+this.padding[1][0]+this.padding[1][1]:null,[t[0],t[1],e,n]):(e=null!=t[1]&&t[1]>=0?t[1]+this.padding[0][0]+this.padding[0][1]:null,n=null!=t[2]&&t[2]>=0?t[2]+this.padding[1][0]+this.padding[1][1]:null,[t[0],e,n,t[3]])},n.prototype.call=function(t,n){var r=this;return e.tidy((function(){return n=cs(t),i=r.padding,a=r.dataFormat,e.tidy((function(){if(4!==n.rank)throw new ki("temporalPadding expects input tensor to be 4-D, but received a "+n.rank+"-D tensor.");if(null==i&&(i=[[1,1],[1,1]]),2!==i.length||2!==i[0].length||2!==i[1].length)throw new ki("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(null==a&&(a="channelsLast"),"channelsLast"!==a&&"channelsFirst"!==a)throw new ki("Unknown data format: "+a+". Supported data formats are 'channelsLast' and 'channelsFirst.");var t;return t="channelsFirst"===a?[[0,0],[0,0],i[0],i[1]]:[[0,0],i[0],i[1],[0,0]],e.pad(n,t)}));var n,i,a}))},n.prototype.getConfig=function(){var e={padding:this.padding,dataFormat:this.dataFormat},n=t.prototype.getConfig.call(this);return Object.assign(e,n),e},n.className="ZeroPadding2D",n}(Ss);function Dl(t,n,r,i,a,s){return e.tidy((function(){var o;sa(a),ua(s),oa(i),null==r&&(r=[1,1]),null==i&&(i="valid"),null==a&&(a="channelsLast"),null==s&&(s="max"),t=Eu(t,a);var u="same"===i?"same":"valid";return o="max"===s?e.maxPool(t,n,r,u):e.avgPool(t,n,r,u),"channelsFirst"===a&&(o=e.transpose(o,[0,3,1,2])),o}))}function Ll(t,n,r,i,a,s){return e.tidy((function(){var o;sa(a),ua(s),oa(i),null==r&&(r=[1,1,1]),null==i&&(i="valid"),null==a&&(a="channelsLast"),null==s&&(s="max"),t=Fu(t,a);var u="same"===i?"same":"valid";return o="max"===s?e.maxPool3d(t,n,r,u):e.avgPool3d(t,n,r,u),"channelsFirst"===a&&(o=e.transpose(o,[0,4,1,2,3])),o}))}e.serialization.registerClass(Fl);var _l=function(t){function n(e){var n=this;if(null==e.poolSize&&(e.poolSize=2),n=t.call(this,e)||this,"number"==typeof e.poolSize)n.poolSize=[e.poolSize];else{if(!Array.isArray(e.poolSize)||1!==e.poolSize.length||"number"!=typeof e.poolSize[0])throw new ki("poolSize for 1D convolutional layer must be a number or an Array of a single number, but received "+JSON.stringify(e.poolSize));n.poolSize=e.poolSize}if($i(n.poolSize,"poolSize"),null==e.strides)n.strides=n.poolSize;else if("number"==typeof e.strides)n.strides=[e.strides];else{if(!Array.isArray(e.strides)||1!==e.strides.length||"number"!=typeof e.strides[0])throw new ki("strides for 1D convolutional layer must be a number or an Array of a single number, but received "+JSON.stringify(e.strides));n.strides=e.strides}return $i(n.strides,"strides"),n.padding=null==e.padding?"valid":e.padding,oa(n.padding),n.inputSpec=[new ys({ndim:3})],n}return di(n,t),n.prototype.computeOutputShape=function(t){var e=Cu((t=hs(t))[1],this.poolSize[0],this.padding,this.strides[0]);return[t[0],e,t[2]]},n.prototype.call=function(t,n){var r=this;return e.tidy((function(){r.invokeCallHook(t,n),t=wa(cs(t),2);var i=r.poolingFunction(cs(t),[r.poolSize[0],1],[r.strides[0],1],r.padding,"channelsLast");return e.squeeze(i,[2])}))},n.prototype.getConfig=function(){var e={poolSize:this.poolSize,padding:this.padding,strides:this.strides},n=t.prototype.getConfig.call(this);return Object.assign(e,n),e},n}(Ss),Rl=function(t){function e(e){return t.call(this,e)||this}return di(e,t),e.prototype.poolingFunction=function(t,e,n,r,i){return sa(i),oa(r),Dl(t,e,n,r,i,"max")},e.className="MaxPooling1D",e}(_l);e.serialization.registerClass(Rl);var Ol=function(t){function e(e){return t.call(this,e)||this}return di(e,t),e.prototype.poolingFunction=function(t,e,n,r,i){return sa(i),oa(r),Dl(t,e,n,r,i,"avg")},e.className="AveragePooling1D",e}(_l);e.serialization.registerClass(Ol);var Ml=function(t){function n(e){var n=this;if(null==e.poolSize&&(e.poolSize=[2,2]),(n=t.call(this,e)||this).poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],null==e.strides)n.strides=n.poolSize;else if(Array.isArray(e.strides)){if(2!==e.strides.length)throw new ki("If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length "+e.strides.length+".");n.strides=e.strides}else n.strides=[e.strides,e.strides];return $i(n.poolSize,"poolSize"),$i(n.strides,"strides"),n.padding=null==e.padding?"valid":e.padding,n.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,sa(n.dataFormat),oa(n.padding),n.inputSpec=[new ys({ndim:4})],n}return di(n,t),n.prototype.computeOutputShape=function(t){t=hs(t);var e="channelsFirst"===this.dataFormat?t[2]:t[1],n="channelsFirst"===this.dataFormat?t[3]:t[2];return e=Cu(e,this.poolSize[0],this.padding,this.strides[0]),n=Cu(n,this.poolSize[1],this.padding,this.strides[1]),"channelsFirst"===this.dataFormat?[t[0],t[1],e,n]:[t[0],e,n,t[3]]},n.prototype.call=function(t,n){var r=this;return e.tidy((function(){return r.invokeCallHook(t,n),r.poolingFunction(cs(t),r.poolSize,r.strides,r.padding,r.dataFormat)}))},n.prototype.getConfig=function(){var e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},n=t.prototype.getConfig.call(this);return Object.assign(e,n),e},n}(Ss),Bl=function(t){function e(e){return t.call(this,e)||this}return di(e,t),e.prototype.poolingFunction=function(t,e,n,r,i){return sa(i),oa(r),Dl(t,e,n,r,i,"max")},e.className="MaxPooling2D",e}(Ml);e.serialization.registerClass(Bl);var Pl=function(t){function e(e){return t.call(this,e)||this}return di(e,t),e.prototype.poolingFunction=function(t,e,n,r,i){return sa(i),oa(r),Dl(t,e,n,r,i,"avg")},e.className="AveragePooling2D",e}(Ml);e.serialization.registerClass(Pl);var $l=function(t){function n(e){var n=this;if(null==e.poolSize&&(e.poolSize=[2,2,2]),(n=t.call(this,e)||this).poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],null==e.strides)n.strides=n.poolSize;else if(Array.isArray(e.strides)){if(3!==e.strides.length)throw new ki("If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length "+e.strides.length+".");n.strides=e.strides}else n.strides=[e.strides,e.strides,e.strides];return $i(n.poolSize,"poolSize"),$i(n.strides,"strides"),n.padding=null==e.padding?"valid":e.padding,n.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,sa(n.dataFormat),oa(n.padding),n.inputSpec=[new ys({ndim:5})],n}return di(n,t),n.prototype.computeOutputShape=function(t){t=hs(t);var e="channelsFirst"===this.dataFormat?t[2]:t[1],n="channelsFirst"===this.dataFormat?t[3]:t[2],r="channelsFirst"===this.dataFormat?t[4]:t[3];return e=Cu(e,this.poolSize[0],this.padding,this.strides[0]),n=Cu(n,this.poolSize[1],this.padding,this.strides[1]),r=Cu(r,this.poolSize[2],this.padding,this.strides[2]),"channelsFirst"===this.dataFormat?[t[0],t[1],e,n,r]:[t[0],e,n,r,t[4]]},n.prototype.call=function(t,n){var r=this;return e.tidy((function(){return r.invokeCallHook(t,n),r.poolingFunction(cs(t),r.poolSize,r.strides,r.padding,r.dataFormat)}))},n.prototype.getConfig=function(){var e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},n=t.prototype.getConfig.call(this);return Object.assign(e,n),e},n}(Ss),Wl=function(t){function e(e){return t.call(this,e)||this}return di(e,t),e.prototype.poolingFunction=function(t,e,n,r,i){return sa(i),oa(r),Ll(t,e,n,r,i,"max")},e.className="MaxPooling3D",e}($l);e.serialization.registerClass(Wl);var Ul=function(t){function e(e){return t.call(this,e)||this}return di(e,t),e.prototype.poolingFunction=function(t,e,n,r,i){return sa(i),oa(r),Ll(t,e,n,r,i,"avg")},e.className="AveragePooling3D",e}($l);e.serialization.registerClass(Ul);var jl=function(t){function e(e){var n=t.call(this,e)||this;return n.inputSpec=[new ys({ndim:3})],n}return di(e,t),e.prototype.computeOutputShape=function(t){return[t[0],t[2]]},e.prototype.call=function(t,e){throw new Si},e}(Ss),Vl=function(t){function n(e){return t.call(this,e||{})||this}return di(n,t),n.prototype.call=function(t,n){return e.tidy((function(){var n=cs(t);return e.mean(n,1)}))},n.className="GlobalAveragePooling1D",n}(jl);e.serialization.registerClass(Vl);var Kl=function(t){function n(e){return t.call(this,e||{})||this}return di(n,t),n.prototype.call=function(t,n){return e.tidy((function(){var n=cs(t);return e.max(n,1)}))},n.className="GlobalMaxPooling1D",n}(jl);e.serialization.registerClass(Kl);var ql=function(t){function e(e){var n=t.call(this,e)||this;return n.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,sa(n.dataFormat),n.inputSpec=[new ys({ndim:4})],n}return di(e,t),e.prototype.computeOutputShape=function(t){return t=t,"channelsLast"===this.dataFormat?[t[0],t[3]]:[t[0],t[1]]},e.prototype.call=function(t,e){throw new Si},e.prototype.getConfig=function(){var e={dataFormat:this.dataFormat},n=t.prototype.getConfig.call(this);return Object.assign(e,n),e},e}(Ss),Gl=function(t){function n(){return null!==t&&t.apply(this,arguments)||this}return di(n,t),n.prototype.call=function(t,n){var r=this;return e.tidy((function(){var n=cs(t);return"channelsLast"===r.dataFormat?e.mean(n,[1,2]):e.mean(n,[2,3])}))},n.className="GlobalAveragePooling2D",n}(ql);e.serialization.registerClass(Gl);var Hl=function(t){function n(){return null!==t&&t.apply(this,arguments)||this}return di(n,t),n.prototype.call=function(t,n){var r=this;return e.tidy((function(){var n=cs(t);return"channelsLast"===r.dataFormat?e.max(n,[1,2]):e.max(n,[2,3])}))},n.className="GlobalMaxPooling2D",n}(ql);e.serialization.registerClass(Hl);var Jl=function(t){function e(e){var n=t.call(this,e)||this;return n.layer=e.layer,n}return di(e,t),e.prototype.build=function(t){this.built=!0},Object.defineProperty(e.prototype,"trainable",{get:function(){return null!=this.layer&&this.layer.trainable},set:function(t){null!=this.layer&&(this.layer.trainable=t)},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"trainableWeights",{get:function(){return this.layer.trainableWeights},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"nonTrainableWeights",{get:function(){return this.layer.nonTrainableWeights},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"updates",{get:function(){return this.layer._updates},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"losses",{get:function(){return this.layer.losses},enumerable:!0,configurable:!0}),e.prototype.getWeights=function(){return this.layer.getWeights()},e.prototype.setWeights=function(t){this.layer.setWeights(t)},e.prototype.getConfig=function(){var e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},n=t.prototype.getConfig.call(this);return Object.assign(e,n),e},e.prototype.setFastWeightInitDuringBuild=function(e){t.prototype.setFastWeightInitDuringBuild.call(this,e),null!=this.layer&&this.layer.setFastWeightInitDuringBuild(e)},e.fromConfig=function(t,e,n){void 0===n&&(n={});var r=Ms(e.layer,n);delete e.layer;var i={layer:r};return Object.assign(i,e),new t(i)},e}(Ss),Zl=function(t){function n(e){var n=t.call(this,e)||this;return n.supportsMasking=!0,n}return di(n,t),n.prototype.build=function(e){if((e=hs(e)).length<3)throw new ki("TimeDistributed layer expects an input shape >= 3D, but received input shape "+JSON.stringify(e));this.inputSpec=[{shape:e}];var n=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(n),this.layer.built=!0),t.prototype.build.call(this,e)},n.prototype.computeOutputShape=function(t){var e=[(t=hs(t))[0]].concat(t.slice(2)),n=this.layer.computeOutputShape(e),r=t[1];return[n[0],r].concat(n.slice(1))},n.prototype.call=function(t,n){var r=this;return e.tidy((function(){return Ku((function(t,e){return[cs(r.layer.call(t,n)),[]]}),t=cs(t),[],!1,null,null,!1,!0)[1]}))},n.className="TimeDistributed",n}(Jl);e.serialization.registerClass(Zl);var Yl=function(t){function n(e){var n=t.call(this,e)||this,r=e.layer.getConfig(),i={};i.className=e.layer.getClassName(),i.config=r,n.forwardLayer=Ms(i),r.goBackwards=!0!==r.goBackwards;var a,s={};if(s.className=e.layer.getClassName(),s.config=r,n.backwardLayer=Ms(s),n.forwardLayer.name="forward_"+n.forwardLayer.name,n.backwardLayer.name="backward_"+n.backwardLayer.name,n.mergeMode=void 0===e.mergeMode?"concat":e.mergeMode,a=n.mergeMode,Bi(ia,"BidirectionalMergeMode",a),e.weights)throw new Si("weights support is not implemented for Bidirectional layer yet.");return n._stateful=e.layer.stateful,n.returnSequences=e.layer.returnSequences,n.returnState=e.layer.returnState,n.supportsMasking=!0,n._trainable=!0,n.inputSpec=e.layer.inputSpec,n.numConstants=null,n}return di(n,t),Object.defineProperty(n.prototype,"trainable",{get:function(){return this._trainable},set:function(t){this._trainable=t,null!=this.forwardLayer&&(this.forwardLayer.trainable=t),null!=this.backwardLayer&&(this.backwardLayer.trainable=t)},enumerable:!0,configurable:!0}),n.prototype.getWeights=function(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())},n.prototype.setWeights=function(t){var e=t.length,n=Math.floor(e/2);this.forwardLayer.setWeights(t.slice(0,n)),this.backwardLayer.setWeights(t.slice(n))},n.prototype.computeOutputShape=function(t){var e,n,r,i=this.forwardLayer.computeOutputShape(t);return Array.isArray(i)&&Array.isArray(i[0])||(i=[i]),i=i,this.returnState?(r=i.slice(1),e=i[0]):e=i[0],e=e,"concat"===this.mergeMode?(e[e.length-1]*=2,n=[e]):n=null==this.mergeMode?[e,e.slice()]:[e],this.returnState?null==this.mergeMode?n.concat(r).concat(r.slice()):[e].concat(r).concat(r.slice()):Ai(n)},n.prototype.apply=function(e,n){var r=null==n?null:n.initialState,i=null==n?null:n.constants;null==n&&(n={});var a=Vu(e,r,i,this.numConstants);if(e=a.inputs,r=a.initialState,i=a.constants,Array.isArray(e)&&(r=e.slice(1),e=e[0]),(null==r||0===r.length)&&null==i)return t.prototype.apply.call(this,e,n);var s=[],o=[];if(null!=r){var u=r.length;if(u%2>0)throw new ki("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");n.initialState=r,s.push.apply(s,r);var l=r.map((function(t){return new ys({shape:t.shape})}));this.forwardLayer.stateSpec=l.slice(0,u/2),this.backwardLayer.stateSpec=l.slice(u/2),o.push.apply(o,l)}if(null!=i)throw new Si("Support for constants in Bidirectional layers is not implemented yet.");for(var c=s[0]instanceof vs,h=0,p=s;h<p.length;h++){if(p[h]instanceof vs!==c)throw new ki("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors")}if(c){var d=[e].concat(s),f=this.inputSpec.concat(o),g=this.inputSpec;this.inputSpec=f;var m=t.prototype.apply.call(this,d,n);return this.inputSpec=g,m}return t.prototype.apply.call(this,e,n)},n.prototype.call=function(t,n){var r=this;return e.tidy((function(){var i,a,s,o,u=n.initialState;if(null==u)i=r.forwardLayer.call(t,n),a=r.backwardLayer.call(t,n);else{var l=u.slice(0,u.length/2),c=u.slice(u.length/2);i=r.forwardLayer.call(t,Object.assign(n,{initialState:l})),a=r.backwardLayer.call(t,Object.assign(n,{initialState:c}))}return r.returnState&&(Array.isArray(i)&&(s=i.slice(1).concat(a.slice(1))),i=i[0],a=a[0]),r.returnSequences&&(a=e.reverse(a,1)),"concat"===r.mergeMode?o=xa([i,a]):"sum"===r.mergeMode?o=e.add(i,a):"ave"===r.mergeMode?o=e.mul(.5,e.add(i,a)):"mul"===r.mergeMode?o=e.mul(i,a):null==r.mergeMode&&(o=[i,a]),r.returnState?null==r.mergeMode?o.concat(s):[o].concat(s):o}))},n.prototype.resetStates=function(t){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()},n.prototype.build=function(t){var e=this;ca(this.forwardLayer.name,(function(){e.forwardLayer.build(t)})),ca(this.backwardLayer.name,(function(){e.backwardLayer.build(t)})),this.built=!0},n.prototype.computeMask=function(t,e){var n;if(Array.isArray(e)&&(e=e[0]),n=this.returnSequences?null==this.mergeMode?[e,e]:e:null==this.mergeMode?[null,null]:null,this.returnState){var r=this.forwardLayer.states.map((function(t){return null}));return Array.isArray(n)?n.concat(r).concat(r):[n].concat(r).concat(r)}return n},Object.defineProperty(n.prototype,"trainableWeights",{get:function(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"nonTrainableWeights",{get:function(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)},enumerable:!0,configurable:!0}),n.prototype.setFastWeightInitDuringBuild=function(e){t.prototype.setFastWeightInitDuringBuild.call(this,e),null!=this.forwardLayer&&this.forwardLayer.setFastWeightInitDuringBuild(e),null!=this.backwardLayer&&this.backwardLayer.setFastWeightInitDuringBuild(e)},n.prototype.getConfig=function(){var e={mergeMode:this.mergeMode},n=t.prototype.getConfig.call(this);return Object.assign(e,n),e},n.fromConfig=function(t,e){var n=Ms(e.layer);if(delete e.layer,null!=e.numConstants)throw new Si("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");var r=e;return r.layer=n,new t(r)},n.className="Bidirectional",n}(Jl);function Xl(t){return new Ol(t)}function Ql(t){return new Pl(t)}function tc(t){return new Ul(t)}function ec(t){return new Kl(t)}function nc(t){return new Hl(t)}function rc(t){return new Rl(t)}function ic(t){return new Bl(t)}e.serialization.registerClass(Yl);var ac={__proto__:null,inputLayer:function(t){return new zs(t)},elu:function(t){return new xu(t)},reLU:function(t){return new ku(t)},leakyReLU:function(t){return new Su(t)},prelu:function(t){return new Nu(t)},softmax:function(t){return new Iu(t)},thresholdedReLU:function(t){return new zu(t)},conv1d:function(t){return new $u(t)},conv2d:function(t){return new Ru(t)},conv2dTranspose:function(t){return new Mu(t)},conv3d:function(t){return new Ou(t)},conv3dTranspose:function(t){return new Bu(t)},separableConv2d:function(t){return new Pu(t)},cropping2D:function(t){return new Wu(t)},upSampling2d:function(t){return new Uu(t)},depthwiseConv2d:function(t){return new ju(t)},activation:function(t){return new ll(t)},dense:function(t){return new ol(t)},dropout:function(t){return new al(t)},spatialDropout1d:function(t){return new sl(t)},flatten:function(t){return new ul(t)},repeatVector:function(t){return new cl(t)},reshape:function(t){return new hl(t)},permute:function(t){return new pl(t)},embedding:function(t){return new fl(t)},add:function(t){return new ml(t)},average:function(t){return new vl(t)},concatenate:function(t){return new kl(t)},maximum:function(t){return new bl(t)},minimum:function(t){return new wl(t)},multiply:function(t){return new yl(t)},dot:function(t){return new Nl(t)},batchNormalization:function(t){return new Tl(t)},layerNormalization:function(t){return new El(t)},zeroPadding2d:function(t){return new Fl(t)},averagePooling1d:Xl,avgPool1d:function(t){return Xl(t)},avgPooling1d:function(t){return Xl(t)},averagePooling2d:Ql,avgPool2d:function(t){return Ql(t)},avgPooling2d:function(t){return Ql(t)},averagePooling3d:tc,avgPool3d:function(t){return tc(t)},avgPooling3d:function(t){return tc(t)},globalAveragePooling1d:function(t){return new Vl(t)},globalAveragePooling2d:function(t){return new Gl(t)},globalMaxPooling1d:ec,globalMaxPooling2d:nc,maxPooling1d:rc,maxPooling2d:ic,maxPooling3d:function(t){return new Wl(t)},gru:function(t){return new Yu(t)},gruCell:function(t){return new Zu(t)},lstm:function(t){return new Qu(t)},lstmCell:function(t){return new Xu(t)},simpleRNN:function(t){return new Ju(t)},simpleRNNCell:function(t){return new Hu(t)},convLstm2d:function(t){return new il(t)},convLstm2dCell:function(t){return new rl(t)},rnn:function(t){return new qu(t)},stackedRNNCells:function(t){return new tl(t)},bidirectional:function(t){return new Yl(t)},timeDistributed:function(t){return new Zl(t)},globalMaxPool1d:ec,globalMaxPool2d:nc,maxPool1d:rc,maxPool2d:ic,Layer:Ss,RNN:qu,RNNCell:Gu,input:Jo,gaussianNoise:function(t){return new xl(t)},gaussianDropout:function(t){return new zl(t)},alphaDropout:function(t){return new Il(t)},masking:function(t){return new dl(t)}};var sc={__proto__:null,binaryAccuracy:function(t,e){return Hs(t,e)},binaryCrossentropy:function(t,e){return Qs(t,e)},sparseCategoricalAccuracy:function(t,e){return to(t,e)},categoricalAccuracy:function(t,e){return Js(t,e)},categoricalCrossentropy:function(t,e){return eo(t,e)},precision:function(t,e){return Ys(t,e)},recall:function(t,e){return Xs(t,e)},cosineProximity:function(t,e){return Ks(t,e)},meanAbsoluteError:function(t,e){return $s(t,e)},meanAbsolutePercentageError:function(t,e){return Ws(t,e)},MAPE:function(t,e){return Ws(t,e)},mape:function(t,e){return Ws(t,e)},meanSquaredError:function(t,e){return Ps(t,e)},MSE:function(t,e){return Ps(t,e)},mse:function(t,e){return Ps(t,e)}},oc={__proto__:null,modelFromJSON:function(t,n){return mi(this,void 0,void 0,(function(){var r,i,a,s,o,u,l,c;return yi(this,(function(h){switch(h.label){case 0:return"modelTopology"in t||(t={modelTopology:t}),null!=(r=(t=t).modelTopology).model_config&&(r=r.model_config),i=fo(r),a=Ms(i,n),null==t.weightsManifest?[3,2]:[4,e.io.loadWeights(t.weightsManifest,t.pathPrefix,a.weights.map((function(t){return t.originalName})))];case 1:for(s=h.sent(),o={},u=0,l=a.weights;u<l.length;u++)c=l[u],o[c.originalName]=s[c.originalName];a.loadWeights(o),e.dispose(s),h.label=2;case 2:return[2,a]}}))}))}};var uc={__proto__:null,l1l2:function(t){return new mu(t)},l1:function(t){return fu(e=t),new mu({l1:null!=e?e.l1:null,l2:0});var e},l2:function(t){return fu(e=t),new mu({l2:null!=e?e.l2:null,l1:0});var e}},lc=function(t){function e(){var e=null!==t&&t.apply(this,arguments)||this;return e.model=null,e}return di(e,t),e.prototype.setModel=function(t){if(!(t instanceof Ko))throw new Error("model must be a LayersModel, not some other Container");this.model=t},e}(Ts);function cc(t,e){return t<e}function hc(t,e){return t>e}var pc=function(t){function e(e){var n=t.call(this)||this;if(null==e&&(e={}),e.restoreBestWeights)throw new Si("restoreBestWeights = True is not implemented in EarlyStopping yet.");return n.monitor=e.monitor||"val_loss",n.minDelta=Math.abs(e.minDelta||0),n.patience=e.patience||0,n.verbose=e.verbose||0,n.mode=e.mode||"auto",n.baseline=e.baseline,-1===["auto","min","max"].indexOf(n.mode)&&(console.warn("EarlyStopping mode '"+n.mode+"' is invalid. Falling back to mode 'auto'."),n.mode="auto"),"min"===n.mode?n.monitorFunc=cc:"max"===n.mode||-1!==n.monitor.indexOf("acc")?n.monitorFunc=hc:n.monitorFunc=cc,n.monitorFunc===cc&&(n.minDelta*=-1),n}return di(e,t),e.prototype.onTrainBegin=function(t){return mi(this,void 0,void 0,(function(){return yi(this,(function(t){return this.wait=0,this.stoppedEpoch=0,null!=this.baseline?this.best=this.baseline:this.best=this.monitorFunc===cc?1/0:-1/0,[2]}))}))},e.prototype.onEpochEnd=function(t,e){return mi(this,void 0,void 0,(function(){var n;return yi(this,(function(r){switch(r.label){case 0:return[4,As(e)];case 1:return r.sent(),null==(n=this.getMonitorValue(e))?[2]:(this.monitorFunc(n-this.minDelta,this.best)?(this.best=n,this.wait=0):(this.wait++,this.wait>=this.patience&&(this.stoppedEpoch=t,this.model.stopTraining=!0)),[2])}}))}))},e.prototype.onTrainEnd=function(t){return mi(this,void 0,void 0,(function(){return yi(this,(function(t){return this.stoppedEpoch>0&&this.verbose&&console.log("Epoch "+this.stoppedEpoch+": early stopping."),[2]}))}))},e.prototype.getMonitorValue=function(t){null==t&&(t={});var e=t[this.monitor];return null==e&&console.warn("Metric for EarlyStopping "+this.monitor+" is not available. Available metrics are: "+Object.keys(t)),e},e}(lc);var dc={earlyStopping:function(t){return new pc(t)}};t.Callback=lc,t.CallbackList=Es,t.CustomCallback=Ls,t.EarlyStopping=pc,t.History=Ds,t.InputSpec=ys,t.LayerVariable=fs,t.LayersModel=Ko,t.RNN=qu,t.Sequential=Ho,t.SymbolicTensor=vs,t.callbacks=dc,t.constraints=Qi,t.initializers=rs,t.input=Jo,t.layers=ac,t.loadLayersModel=function(t,n){return null==n&&(n={}),function(t,n){return mi(this,void 0,void 0,(function(){var r;return yi(this,(function(i){if(null==n&&(n={}),"string"==typeof t){if(0===(r=e.io.getLoadHandlers(t,n)).length)r.push(e.io.browserHTTPRequest(t,n));else if(r.length>1)throw new ki("Found more than one ("+r.length+") load handlers for URL '"+t+"'");t=r[0]}return[2,Go(t,void 0,n)]}))}))}(t,n)},t.metrics=sc,t.model=function(t){return new Ko(t)},t.models=oc,t.registerCallbackConstructor=function(t,e){Rs.registerCallbackConstructor(t,e)},t.regularizers=uc,t.sequential=function(t){return new Ho(t)},t.version_layers=mo,Object.defineProperty(t,"__esModule",{value:!0})}));
//# sourceMappingURL=tf-layers.min.js.map
